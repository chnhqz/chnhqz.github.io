<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="力扣, 刀刀博客">
    <meta name="description" content="1.哈希
1.两数之和
如果直接暴力很简单，但是时间复杂度为 \(O(n)\)
。这里其实时间的复杂度主要来自于内层循环的复杂度，外层循环，的 \(O(n)\) 时间复杂度是不可避免的，对于 \(nums[i]\) 来说，我们在数组中找到一">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>力扣 | 刀刀博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.0.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">刀刀博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">刀刀博客</div>
        <div class="logo-desc">
            
            欢迎来到刀刀的笔记空间(^_^)
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">力扣</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-05-06
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="哈希">1.哈希</h2>
<h4 id="两数之和">1.两数之和</h4>
<p>如果直接暴力很简单，但是时间复杂度为 <span
class="math inline">\(O(n)\)</span>
。这里其实时间的复杂度主要来自于内层循环的复杂度，外层循环，的 <span
class="math inline">\(O(n)\)</span> 时间复杂度是不可避免的，对于 <span
class="math inline">\(nums[i]\)</span> 来说，我们在数组中找到一个数等于
<span class="math inline">\(target - nums[i]\)</span>
。只是循环的话，还是 <span class="math inline">\(O(n)\)</span>
的时间复杂度，我们可以使用哈希的方法，直接用 <span
class="math inline">\(O(1)\)</span> 的时间复杂度找到 <span
class="math inline">\(target - nums[i]\)</span> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 找一个键值为 target - nums[i] 的索引</span></span><br><span class="line">            <span class="keyword">auto</span> it  = mp.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="comment">// 如果找到了键值为 target - nums[i] 的索引，那么返回答案</span></span><br><span class="line">            <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字母异位词分组">49.字母异位词分组</h4>
<p>我们可以选择将排序后的字符串作为键，无序的字符串作为键值
<code>unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</code>
这样遍历一边字符串，就可以筛选出所有的答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str : strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最长连续序列">128.最长连续序列</h4>
<p>首先我们考虑枚举数组中的每个数 <span class="math inline">\(x\)</span>
。考虑不断尝试 <span class="math inline">\(x+1,x+2,x+3,...\)</span>
是否存在。对于匹配的过程，直接的方法是 <span
class="math inline">\(O(n)\)</span>
遍历数组去看是否存在这个数，但是我们可以使用更高效的方法，用一个哈希表存储数组中的数，这样查看一个数是否存在能优化至
<span class="math inline">\(O(1)\)</span> 的时间复杂度。</p>
<p>但是仅仅这样，我们的算法时间复杂度最坏情况还是会达到 <span
class="math inline">\(O(n^2)\)</span> （即外层需要枚举 <span
class="math inline">\(n\)</span> 个数，内层也需要暴力匹配 <span
class="math inline">\(n\)</span> 次）。这样无法满足题目时间复杂度 <span
class="math inline">\(O(n)\)</span>
的要求。但是我们仔细分析这个枚举的过程，我们会发现其实我们进行了很多不必要的枚举，如果已知有一个
<span class="math inline">\(x, x+1, x+2, ..., x+y\)</span>
的连续序列，而我们在下一个数字 <span class="math inline">\(x+ 2\)</span>
的时候仍然一个一个的枚举，这样得到的结果是一定不会优于以 <span
class="math inline">\(x\)</span>
为起点的的答案的。所以我们需要在外层判断 <code>x - 1</code>
是否在数组中存在，如果存在，那么他就是已经判断过的，不需要在判断，直接跳过即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> currentNum = num;</span><br><span class="line">                <span class="type">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (num_set.<span class="built_in">count</span>(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longestStreak = <span class="built_in">max</span>(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针">2.双指针</h2>
<h4 id="移动零">283.移动零</h4>
<p>双指针，<code>left</code> 和 <code>right</code> 当<code>left</code>
为0时，<code>right</code>找到<code>left</code>后边第一个不为零的数字进行交换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>; left &lt; right &amp;&amp; right &lt; nums.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                    right ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right == nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left ++;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="盛最多水的容器">11.盛最多水的容器</h4>
<p>这道题目，观察数据的规模，如果采用暴力的双层<code>for</code>循环进行枚举，那么时间复杂度一定超标。这里我们观察，是解决两条线之间的面积最大的问题，那么自然而然想到可以使用双指针来解决，我们接下来注意如何解决指针的移动，首先在<code>height[0]</code>
和 <code>height[8]</code>之间指针如何移动呢？此时指针
<code>height[0] &lt; height[8]</code> 那就是说我们此时找到比
<code>height[0]</code>大的值即可。可以照样理解，我们此时在数组中寻找只要比
<code>height[8]</code>小的值，那么面积一定比此时面积小，所以我们选择移动两个数值之间较小的数字，这样才有可能出现比现在大的面积。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[left], height[right]) * (right - left));</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt; height[right]) right --;</span><br><span class="line">            <span class="keyword">else</span> left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="三数之和">15.三数之和</h4>
<p>利用双指针进行时间复杂度的压缩，首先我们对数组进行排序，这样可以方便后续进行左右指针的移动。排序后，我们要对数组中一样的数字进行去重，<code>if (i - 1 &gt;= 0 &amp;&amp; nums[i] == nums[i - 1]) continue</code>
这句代码就是进行去重的代码。之后我们定义左指针指向<code>nums[i]</code>
的下一个数字，右指针指向最后一个数字。定义 <code>target</code>
为目标数字，这样我们就可以用二分查找的方法进行时间复杂度的压缩，我们将三数之和问题转化为两个数字的和等于
<code>-nums[i]</code> 。我们计算这个和<code>sum</code>。如果这个和
<code>sum &gt; 0</code> <code>right--</code> 否则 <code>left++</code>
。但是这里有个问题，就是会有一样的数字造成答案数组重复。所以我们要进行一样的数字跳过的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> target = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> sum = target + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;target, nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">for</span> (left ++; left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]; left++);</span><br><span class="line">                    <span class="keyword">for</span> (right--; left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]; right--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="接雨水">42.接雨水</h4>
<figure>
<img src="截屏2024-05-06%2010.21.59.png"
alt="截屏2024-05-06 10.21.59" />
<figcaption aria-hidden="true">截屏2024-05-06 10.21.59</figcaption>
</figure>
<p>这里我们将每一块区域都视为一个底边长度为<code>1</code>
的木桶，这是木桶的容水量为
<code>min(左边最高的木板，右边最高的木板)- height[i]</code>
那么如何求对于一个位置的左边最高木板和右边最高木板呢？这里我们用到前后缀的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 1 1 2 2 2 2 3 3 3 3 3</span></span><br><span class="line"><span class="comment">// 3 3 3 3 3 3 3 3 2 2 2 1</span></span><br><span class="line"><span class="comment">// 0 0 1 0 1 2 1 0 0 1 0 0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre_max</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">suf_max</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        pre_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        suf_max[height.<span class="built_in">size</span>() - <span class="number">1</span>] = height[height.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            pre_max[i] = <span class="built_in">max</span>(pre_max[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = height.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            suf_max[i] = <span class="built_in">max</span>(suf_max[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res += <span class="built_in">min</span>(pre_max[i], suf_max[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>相向双指针的做法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, pre_max = <span class="number">0</span>, suf_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            pre_max = <span class="built_in">max</span>(pre_max, height[left]);</span><br><span class="line">            suf_max = <span class="built_in">max</span>(suf_max, height[right]);</span><br><span class="line">            <span class="keyword">if</span> (pre_max &lt; suf_max) &#123;</span><br><span class="line">                <span class="comment">// 左边木桶的容量就知道了</span></span><br><span class="line">                res += pre_max - height[left];</span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += suf_max - height[right];</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口">3.滑动窗口</h2>
<h4 id="无重复字符的最长字串">3.无重复字符的最长字串</h4>
<p>滑动窗口，利用集合维护一个没有重复字符的字符串，不断枚举右指针指向的字符，并在集合中判断它在所维护的字符串中是否出现过，如果出现过，就不断移动所维护的字符串的左边界，使得所维护的字符串中没有与此时右指针指向的字符串重复的字符。然后插入右指针指向的字符，更新答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>, left = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="comment">// 不断滑动右指针，直到当前右指针指向的字符没有重复</span></span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">count</span>(s[right])) &#123;</span><br><span class="line">                <span class="comment">// 当前右指针指向的字符在st中有重复的，所以不断滑动左指针，并擦去st中的左指针字符</span></span><br><span class="line">                st.<span class="built_in">erase</span>(s[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当滑动完成，此时右指针指向的字符在st中没有重复的，插入右指针的字符 更新答案</span></span><br><span class="line">            st.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到字符串中所有字母异位词">438.找到字符串中所有字母异位词</h4>
<p>首先我想到的是暴力解法，利用每次在<code>s</code>中截取一段长度等于<code>p</code>的子字符串。然后比较两个字符串是否是异位字符串。这种方法比较直接，实现起来也没有难度。我用的是字典来比较字符串是否是异位字符串，但是时间复杂度很高。不出意料的超时了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp_1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            mp_1[p[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp_2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = p.<span class="built_in">size</span>() - <span class="number">1</span>; right &lt; s.<span class="built_in">size</span>();left++, right++) &#123;</span><br><span class="line">            mp_2.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                mp_2[s[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> mp_1_ : mp_1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp_2[mp_1_.first] != mp_1_.second) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着想，这个解法中可以优化的点在哪里？首先分析时间复杂度，一个最外层的循环，内部是有两个循环，一个循环记录当前的子字符串的字典集合，另外一个循环进行比较两个字符串。最坏的情况就是
<span class="math inline">\(O(n^2)\)</span>。</p>
<p>此时其实有一个可以优化的点，就是不需要每次重复循环计算<code>mp_2</code>，我们只需要减去上次的左端点，在加上这次的右端点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; p.<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp_1;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp_2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            mp_1[p[i]] ++;</span><br><span class="line">            mp_2[s[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = p.<span class="built_in">size</span>() - <span class="number">1</span>; right &lt; s.<span class="built_in">size</span>();left++, right++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="number">0</span>) &#123;</span><br><span class="line">                mp_2[s[left - <span class="number">1</span>]] --;</span><br><span class="line">                mp_2[s[right]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> mp_1_ : mp_1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp_2[mp_1_.first] != mp_1_.second) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过这次优化，就通过了。</p>
<h2 id="子串">子串</h2>
<h4 id="和为k的子数组">560.和为k的子数组</h4>
<p>首先想到暴力解决的方法，我们遍历整个数组，依次计算从 <code>i</code>
到<code>j</code> 之间的和，然后与 <code>k</code> 进行大小的比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cla_nums_i_j</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">cla_nums_i_j</span>(nums, i, j); </span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j] == k) &#123;  </span><br><span class="line">                        res ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很明显，这样的时间复杂度至少为 <span
class="math inline">\(O(n^2)\)</span>
（没有计算<code>cla_nums_i_j</code>的时间复杂度）。所以这样是一定会超时的，我们需要进行优化。首先我们有必要逐个计算<code>dp[i][j]</code>
吗？我们能否只计算其他的值，然后用这些值把所有的值推算出来？例如<code>dp[i][j] = dp[0][j] - dp[0][i]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cla_nums_i_j</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">cla_nums_i_j</span>(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == k) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] - dp[i - <span class="number">1</span>] == k) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这次进行了简单的优化，但是仍然使用了双层循环来进行<code>i~j</code>
之间的元素和的判断。这次通过了<code>87/93</code>
个样例。仍然是时间复杂度过高。还有优化的空间，我在计算<code>dp[i]</code>时每次都调用了<code>cla_nums_i_j</code>
这里每次都有重复计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tmp += nums[i];</span><br><span class="line">            dp[i] = tmp;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == k) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] - dp[i - <span class="number">1</span>] == k) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这次通过了，但是时间复杂度仍然很高*_*!。</p>
<h2 id="动态规划">动态规划</h2>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/image-20240624100453657.png"
alt="image-20240624100453657" />
<figcaption aria-hidden="true">image-20240624100453657</figcaption>
</figure>
<p><strong>完全背包理论</strong></p>
<p>有 <span class="math inline">\(N\)</span> 件物品和一个最多能背重量为
<span class="math inline">\(W\)</span> 的背包。第 <span
class="math inline">\(i\)</span> 件物品的重量是 <span
class="math inline">\(weight[i]\)</span> ，得到的价值是 <span
class="math inline">\(value[i]\)</span>
。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。<strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p><strong>01背包遍历顺序的核心思路</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> 		dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内层的循环，从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p><strong>完全背包核心思路</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt; bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> 		dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换ii">518.零钱兑换II</h4>
<p><code>vector&lt;int&gt;dp(amount + 1, 0);</code> <code>dp[i]</code>
表示当前 <code>amount</code> 为 <code>i</code> ，有 <code>dp[i]</code>
种方法可以凑成 <code>i</code>
。由于每种硬币可以使用无限次。所以这是一个完全背包题目。先进行物品的遍历，之后进行背包容量的遍历。</p>
<p><strong>递推公式</strong></p>
<blockquote>
<p><code>dp[j]</code> （考虑<code>coins[i]</code>的组合总和）就是所有的
<code>dp[j - coins[i]]</code> 相加</p>
<p>例如在考虑第一层循环时
<code>dp[5] = dp[0] + dp[1] + dp[2] + d[3] + dp[4]</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(amount + <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// dp[j]表示当前amount为j，有dp[j]种方法可以凑成j。</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里外层循环只能是物品，因为如果外层是背包容量的话，我们计算的是排列数。</p>
<h4 id="组合总合iv">377.组合总合IV</h4>
<p>这道题目跟前一个题目（518.零钱兑换II）不一样的点在于，这个题目的顺序不同的序列被视为不同的组合。这道题目我们将背包容量放到外层循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] += dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题目还有一种 <code>DFS</code> 的解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> sum, <span class="type">int</span> target, <span class="type">int</span> end, <span class="type">int</span> *res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                (*res)++;</span><br><span class="line">                cout &lt;&lt; *res &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="built_in">DFS</span>(nums, sum, target, end, res);</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;|&quot;</span>&lt;&lt; sum &lt;&lt;<span class="string">&quot;|&quot;</span>&lt;&lt;*res &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(nums, sum, target, nums.<span class="built_in">size</span>(), &amp;res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单词拆分">139.单词拆分</h4>
<p><code>dp[i]</code> 代表字符串<code>i</code>
前边的字符串能够被拼接出来。只有当 <code>dp[j]</code> 为真，且
在字符串列表内能够找到 <code>s[j, i - j]</code> 的字符时
<code>dp[i]</code> 才为真。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> wordDictSet = unordered_set &lt;string&gt; ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordDict) wordDictSet.<span class="built_in">insert</span>(word);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j ,i - j)) != wordDictSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="编辑距离">72.编辑距离</h4>
<p>给出两个单词<code>word1</code>和<code>word2</code>，返回将
<code>word1</code> 转换为 <code>word2</code>
所使用的最小操作次数。这里单词之间的转换有三种方式</p>
<ol type="1">
<li>删除</li>
<li>插入</li>
<li>替换</li>
</ol>
<p><code>dp[i][j]</code>代表 <code>word1[0 ~ i]</code> 转换为
<code>word[0 ~ j]</code> 所用的最少操作数</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>r - 1</th>
<th>o - 2</th>
<th>s - 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>h - 1</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="even">
<td>o - 2</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="odd">
<td>r - 3</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>s - 4</td>
<td>3</td>
<td>3</td>
<td>2</td>
</tr>
<tr class="odd">
<td>e - 5</td>
<td>4</td>
<td>4</td>
<td><strong>3</strong></td>
</tr>
</tbody>
</table>
<p>根据这个图可以明显看出，当 <code>word1[i] == word2[j]</code>
时，<code>dp[i][j] = dp[i - 1][j - 1]</code>
这也就是说我们可以确定一个状态转换 <span class="math display">\[
dp[i][j] = dp[i - 1][j - 1] \qquad word1[i] == word2[j]
\]</span> 接下来我们需要判断当 <code>word1[i] != word2[j]</code>
时的情况，我们很容易写出 <span class="math display">\[
dp[i][j] = \min (dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
\qquad word1[i] != word2[j]
\]</span> 但是，这其中代表什么意思？<code>dp[i - 1][j]</code>
从表格中可以看出，是 <code>h -&gt; ros</code> 的次数，而它的下一步变换
<code>ho -&gt; ros</code> 。如果 <code>ho - &gt; ros</code> 的状态可以从
<code>h - &gt; ros</code> 转化，那么也就是说不需要使用 <code>o</code>
。也就是删除了 <code>o</code> 。所以这个
<code>dp[i][j] = dp[i - 1][j]</code> 代表删除。同理
<code>hor -&gt; ros = hor -&gt; ro</code> 代表插入<code>r</code>
。<code>hor -&gt; ros = ho -&gt; ro</code> 代表替换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len_word1 = word1.<span class="built_in">size</span>(), len_word2 = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len_word1 == <span class="number">0</span>) <span class="keyword">return</span> len_word2;</span><br><span class="line">        <span class="comment">// dp[i][j] 代表 word1[0 ~ i] 转换为 word[0 ~ j] 所用的最少操作数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(len_word1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len_word2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dp.size() &lt;&lt; &quot; &quot; &lt;&lt; dp[0].size() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_word1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len_word2; j++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = j;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;j:&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len_word1][len_word2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间dp">区间DP</h3>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26%2015.46.24.png"
alt="截屏2024-06-26 15.46.24" />
<figcaption aria-hidden="true">截屏2024-06-26 15.46.24</figcaption>
</figure>
<h4 id="最长回文子序列">516.最长回文子序列</h4>
<p><strong>思路一：</strong></p>
<p>求 <code>s</code> 和反转后的 <code>s</code> 的 <code>LCS</code></p>
<h4 id="lcs">1143.LCS</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> text1Len = text1.<span class="built_in">size</span>(), text2Len = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[text1Len + <span class="number">1</span>][text2Len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= text1Len; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= text2Len; j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text1Len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; text2Len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[text1Len][text2Len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string&amp; text1, string&amp; text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len_text1 = text1.<span class="built_in">size</span>(), len_text2 = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 定义 dp[i][j] 代表 text1[0, i - 1] 和 text2[0, j - 1] 之间的最长公共子序列长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len_text1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len_text2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_text1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len_text2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len_text1][len_text2];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string s1 = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">longestCommonSubsequence</span>(s, s1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>思路二：</strong></p>
<p>【选或不选】从两侧向内缩小问题规模</p>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26%2015.49.28.png"
alt="截屏2024-06-26 15.49.28" />
<figcaption aria-hidden="true">截屏2024-06-26 15.49.28</figcaption>
</figure>
<p>（类似LCS）定义 <code>dfs(i,j)</code> 表示从 <code>s[i]</code> 到
<code>s[j]</code> 的最长回文子序列的长度</p>
<p><img src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26 15.51.46.png" alt="截屏2024-06-26 15.51.46" style="zoom:50%;" /></p>
<p>递归边界 ： <span class="math display">\[
dfs(i,i) = 1 \\
dfs(i + 1, i) = 0
\]</span> 递归入口：<span class="math inline">\(dfs(0, n -
1)\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end, string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[begin] == s[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(begin + <span class="number">1</span>, end - <span class="number">1</span>, s) + <span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(begin + <span class="number">1</span>, end, s), <span class="built_in">dfs</span>(begin, end - <span class="number">1</span>, s));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>循环的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] 代表从 i 到 j 之间的最大回文子序列长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[len + <span class="number">1</span>][len + <span class="number">1</span>];   <span class="comment">// dp[i][j] 为 i 到 j 之间最长回文子序列的长度</span></span><br><span class="line">        <span class="comment">// 递推公式 ：if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="lcr-回文子串">020.LCR 回文子串</h4>
<p>也是同样的方法，<code>dp[i][j]</code> 表示 <code>[i,j]</code>
之间的字符串是不是回文字符串。如果是，或者<code>j - i == 1</code>就是指两个只相差一个字符，那么
此时回文子串的数量就加一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i == <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res + s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="每日一题">每日一题</h2>
<h4 id="轮转数组">189.轮转数组</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> second = nums[i];</span><br><span class="line">            <span class="type">int</span> first = (i + k) % nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// pair.insert(&#123;first, second&#125;);</span></span><br><span class="line">            pair[first] = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; pair.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pair_ : pair) &#123;</span><br><span class="line">            nums[pair_.first] = pair_.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="合并区间">56.合并区间</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b) &#123;<span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res_tmp;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res_tmp.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;intervals[i][0]:&quot;</span> &lt;&lt; intervals[i][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">            <span class="type">int</span> end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            cnt = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (cnt; cnt &lt; intervals.<span class="built_in">size</span>(); cnt ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (end &gt;= intervals[cnt][<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (end &lt;= intervals[cnt][<span class="number">1</span>]) &#123;</span><br><span class="line">                        end = intervals[cnt][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res_tmp.<span class="built_in">push_back</span>(end);</span><br><span class="line">            i = cnt - <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res_tmp);</span><br><span class="line">            res_tmp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4
id="年5月24日-1673.找出最具竞争力的子序列">2024年5月24日-1673.找出最具竞争力的子序列</h4>
<p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>
，返回长度为 <code>k</code> 且最具 <strong>竞争力</strong> 的
<code>nums</code> 子序列。</p>
<p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p>
<p>在子序列 <code>a</code> 和子序列 <code>b</code>
第一个不相同的位置上，如果 <code>a</code> 中的数字小于 <code>b</code>
中对应的数字，那么我们称子序列 <code>a</code> 比子序列
<code>b</code>（相同长度下）更具 <strong>竞争力</strong> 。
例如，<code>[1,3,4]</code> 比 <code>[1,3,5]</code>
更具竞争力，在第一个不相同的位置，也就是最后一个位置上， <code>4</code>
小于 <code>5</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,5,2,6], k = 2</span><br><span class="line">输出：[2,6]</span><br><span class="line">解释：在所有可能的子序列集合 &#123;[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]&#125; 中，[2,6] 最具竞争力。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,4,3,3,5,4,9,6], k = 4</span><br><span class="line">输出：[2,3,3,4]</span><br></pre></td></tr></table></figure>
<p>能够想到使用单调栈来进行单调递增数组的维护。比如<code>nums = [3, 5, 2, 6]</code>
可以计算出此时对于这个数组的单调递增数组序列为<code>[2, 6]</code>
。同理此时 <code>nums = [2, 4, 3, 3, 5, 4, 9, 6]</code>
可以计算出单调递增数组序列为<code>[2, 3, 3, 4, 6]</code> 。然后截取前
<code>k</code>个数字。由此可以知道，单调栈其实是符合这道题目的思想的。但是题目中有要求返回的数组的长度必须是
<code>k</code>。这就造成这种解法的局限性，比如<code>nums = [2, 4, 3, 3, 5, 4, 9, 6, 1]</code>
这种情况就无法解出正确答案，我们需要在每次维护单调栈的时候加入判断条件，就是栈顶元素出栈的时候，此时栈内元素数量加上数组<code>nums</code>
剩余元素的数量是否大于<code>k</code>。如果比<code>k</code>小，那么此时就不能出栈。</p>
<p>我们在实现的时候可以直接用<code>vector</code>进行栈操作的模拟。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mostCompetitive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == k) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; x &lt; res.<span class="built_in">back</span>() &amp;&amp; res.<span class="built_in">size</span>() + nums.<span class="built_in">size</span>() - i &gt; k) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-1">1.动态规划</h3>
<h5 id="回文串判定">回文串判定</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">longestPalindrome</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];                             <span class="comment">//用来记录字串是否是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1005</span>; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= len; L++) &#123;            <span class="comment">//枚举字串长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;          <span class="comment">//枚举左边界</span></span><br><span class="line">                <span class="type">int</span> j = L + i - <span class="number">1</span>;                  <span class="comment">//生成右边界</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) <span class="keyword">break</span>;                <span class="comment">//如果右边界越界则循环退出</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;                   <span class="comment">//此时s[i][j]字串不是回文串</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; (j - i + <span class="number">1</span>) &gt; maxLen) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[maxLen + start] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> &amp;s[start];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串中的额外字符">2707.字符串中的额外字符</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-09%2020.36.45.png"
alt="截屏2024-01-09 20.36.45" />
<figcaption aria-hidden="true">截屏2024-01-09 20.36.45</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minExtraChar</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划 dp[i] 为 s[0:i] 中剩余字符最小</span></span><br><span class="line">        <span class="comment">// 正常情况下：dp[i + 1] = dp[i] + 1</span></span><br><span class="line">        <span class="comment">// 当出现子串：dp[i + 1] = min(dp[i + 1], dp[j])(遍历 0 - i 之间的子串)</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(dictionary.begin(), dictionary.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] = dp[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dict.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j + <span class="number">1</span>))) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="最长公共子串">1143.最长公共子串</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-02-18%2022.37.52.png"
alt="截屏2024-02-18 22.37.52" />
<figcaption aria-hidden="true">截屏2024-02-18 22.37.52</figcaption>
</figure>
<p>定义：<code>dp[i][j]:=s1...si和t1...tj</code>
对应的LCS的长度。由此，<code>s1...si+1和t1...tj+1</code>
对应的公共子列可能是：</p>
<ul>
<li>当 <code>si+1 = tj+1</code> 时， 在 <code>s1...si 和 t1...tj</code>
的公共子列末尾追加上 <code>si+1</code></li>
<li><code>s1...si+1 和 t1...tj</code> 的公共子序列</li>
<li><code>s1...si 和 t1...tj+1</code> 的公共子序列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> text1Len = text1.<span class="built_in">size</span>(), text2Len = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[text1Len + <span class="number">1</span>][text2Len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= text1Len; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= text2Len; j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text1Len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; text2Len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[text1Len][text2Len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单词拆分-1">139.单词拆分</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> wordDictSet = unordered_set &lt;string&gt; ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordDict) wordDictSet.<span class="built_in">insert</span>(word);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j ,i - j)) != wordDictSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="相向双指针">2.相向双指针</h3>
<h4 id="盛最多水的容器-1">11.盛最多水的容器</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-19 23.00.57.png" alt="截屏2023-12-19 23.00.57" style="zoom:50%;" /></p>
<p>使用相向双指针，<code>left</code>
和<code>right</code>。回到这个题目，你会发现，对于最后一根线，在中间任何比他矮的线替换他都无法使得当前的面积大于现在的面积。也就是说，我们要想获得可能（因为更换后还是可能小于当前面积的）大于当前面积的情况，我们只能选择较小的<code>left</code>
和 <code>right</code> 来进行替换。举个🌰，对于<code>height[0]</code> 和
<code>height[8]</code>
来说，当前的面积是<code>7</code>。要想获得大于当前面积的选择，我们只能选择<code>height[0]</code>和<code>height[8]</code>
之间较小的值进行替换才有可能获得大于当前的面积。也就是说，我们此时选择<code>left++</code>
，得到 <code>height[1]</code> ，此时的面积是<code>49</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[left], height[right]) * (right - left));</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h3 id="同向双指针">3.同向双指针</h3>
<h4
id="统计最大元素出现至少k次的子数组">100137.统计最大元素出现至少K次的子数组</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 14.15.07.png" alt="截屏2023-12-10 14.15.07" style="zoom:50%;" /></p>
<p><strong>同向双指针+滑动窗口</strong></p>
<p>在子数组子串问题中，经常会用到双指针这一技巧 。举个例子：给定一个含有
<code>n</code> 个正整数的数组和一个正整数 <code>target</code>
。找出该数组中满足其和 <code>&gt;=target</code>的长度最小的
<strong>连续子数组</strong> <code>nums</code>
，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> .</p>
<p>例如209题目。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minLen = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; right &lt; nums.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> ((sum - nums[left]) &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target) minLen = <span class="built_in">min</span>(minLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt;= nums.<span class="built_in">size</span>() ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再比如<strong>713.乘积小于K的子数组</strong> 给定一个整数数组
<code>nums</code> 和一个整数 <code>k</code>
，返回子数组内所有元素的乘积严格小于 <code>k</code>
的连续子数组的数目。万变不离其宗，元素都是正数，方法和上一题一样，对于
<code>[10, 5, 2, 6]</code> 比如枚举到 <code>2</code> 的时候，就把
<code>2</code> 接到上一次计算的结果后面。那如果元素的乘积
<code>&gt;=k</code> 就把左端点右移，缩小子数组的长度，直到乘积小于
<code>k</code>
为止。那么问题的关键，也是与上题不同的点，<strong>子数组的数目要怎么算</strong>
这里，我们枚举到 <code>2</code> ，需要算的就是以 <code>2</code>
为右端点的满足要求的子数组的个数。<code>[5, 2]</code>算是一个，
<code>[2]</code>
单独算一个。用代码来计算，就需要推导出来一个公式，假设此时左端点为
<code>l</code>，右端点为<code>r</code> 。那么我们现在需要计算的就是以
<code>r</code> 为右端点的子数组的个数。注意右端点是固定的，如果从
<code>l</code> 到 <code>r</code> 的这一段的乘积是小于 <code>k</code>
的。那么从 <code>l+1</code> 到 <code>r</code> 的这一段也是小于
<code>k</code> 的。一直到 <code>[r, r]</code>
这些子数组都是满足要求的。那么子数组的个数其实就是从 <code>l</code> 到
<code>r</code> 的元素个数。那么就是 <code>r-l+1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxNums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; right &lt; nums.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum  &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                sum /= nums[left];</span><br><span class="line">                left ++;  </span><br><span class="line">            &#125;</span><br><span class="line">            maxNums += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着还有 <strong>3.无重复字符的最长子串</strong> 给定一个字符串
<code>s</code> ,找出其中不含重复字符的 <strong>最长子串</strong>
的长度。由于如果出现的重复字符的唯一情况就是刚刚加入的字符与之前的字符发生重复，所以我们只需要使用哈希的方法，统计一下刚加入的字符是否出现重复即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (right; right &lt; s.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[s[right]] ++;</span><br><span class="line">            <span class="keyword">while</span> (mp[s[right]] &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[s[left]] --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到这个题目，首先找到数组中的最大数，设 <span
class="math inline">\(mx=max(nums)\)</span> 右端点 <span
class="math inline">\(right\)</span> 从左到右遍历 <span
class="math inline">\(nums\)</span> 。遍历到元素<span
class="math inline">\(x=nums[right]\)</span> 如果 <span
class="math inline">\(x=mx\)</span> ，就把计数器 <span
class="math inline">\(cntMx\)</span> 加一。如果此时 <span
class="math inline">\(cntMx = k\)</span> 则不断右移左指针 <span
class="math inline">\(left\)</span> ，直到窗内的 <span
class="math inline">\(mx\)</span> 的出现次数 <strong>小于</strong> <span
class="math inline">\(k\)</span> 为止。此时，对于右端点为 <span
class="math inline">\(right\)</span> 且左端点小于 <span
class="math inline">\(left\)</span> 的子数组，<span
class="math inline">\(mx\)</span> 的出现次数都至少为 <span
class="math inline">\(k\)</span> ，把答案增加 <span
class="math inline">\(left\)</span> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) maxVal = <span class="built_in">max</span>(maxVal, nums[i]);</span><br><span class="line">        <span class="type">int</span> maxValCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (right; right &lt; nums.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == maxVal) maxValCnt ++;</span><br><span class="line">            <span class="keyword">while</span> (maxValCnt == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == maxVal) maxValCnt --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找法-红蓝染色法">4.二分查找法 红蓝染色法</h3>
<h4
id="在排序数组中查找元素的第一个元素和最后一个位置">34.在排序数组中查找元素的第一个元素和最后一个位置</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.05.14.png" alt="截屏2023-12-20 22.05.14" style="zoom:50%;" /></p>
<p>暴力做法，从左到右依次遍历，但是暴力做法没有利用到数组是有序的这一性质。但是我们要如何利用到数组是有序的这一性质呢？我们可以利用两个指针<code>L</code>和<code>R</code>。我们把这两个指针初始化<code>L=0, R=n-1</code>，即分别指向数组的最左边元素和最右边元素。表示我们现在需要知道这个闭区间内的每个数和8的大小关系。即现在闭区间内的颜色都是不确定的。比如目前<code>M</code>这个位置，它比8小，由于数组是有序的，那么它左边的数一定比8小。如果它大于等于8，它右边的数也是大于等于8的。现在是<code>M</code>的取值问题，如果<code>M</code>取在中间，那么我们立刻就知道数组中一半的数与8的大小关系。</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.12.15.png" alt="截屏2023-12-20 22.12.15" style="zoom:50%;" /></p>
<p>我们用红色表示小于8的数，用蓝色表示大于8的数。</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.20.02.png" alt="截屏2023-12-20 22.20.02" style="zoom:50%;" /></p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.21.44.png" alt="截屏2023-12-20 22.21.44" style="zoom:50%;" /></p>
<p>注意⚠️这里<code>L</code>更新为<code>M+1</code>，如果<code>L</code>更新为<code>M</code>。那么考虑只有一个元素的情况，这时候就是死循环。</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.24.25.png" alt="截屏2023-12-20 22.24.25" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// lower_bound 返回最小的满足 nums[i] &gt;= target 的 i</span></span><br><span class="line">    <span class="comment">// 如果数组为空，或者所有数都 &lt; target，则返回 nums.size()</span></span><br><span class="line">    <span class="comment">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭区间写法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = (<span class="type">int</span>) nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 区间不为空</span></span><br><span class="line">            <span class="comment">// 循环不变量：</span></span><br><span class="line">            <span class="comment">// nums[left-1] &lt; target</span></span><br><span class="line">            <span class="comment">// nums[right+1] &gt;= target</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 范围缩小到 [mid+1, right]</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 范围缩小到 [left, mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 或者 right+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左闭右开区间写法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>(); <span class="comment">// 左闭右开区间 [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 区间不为空</span></span><br><span class="line">            <span class="comment">// 循环不变量：</span></span><br><span class="line">            <span class="comment">// nums[left-1] &lt; target</span></span><br><span class="line">            <span class="comment">// nums[right] &gt;= target</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 范围缩小到 [mid+1, right)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid; <span class="comment">// 范围缩小到 [left, mid)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 或者 right</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开区间写法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">-1</span>, right = nums.<span class="built_in">size</span>(); <span class="comment">// 开区间 (left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123; <span class="comment">// 区间不为空</span></span><br><span class="line">            <span class="comment">// 循环不变量：</span></span><br><span class="line">            <span class="comment">// nums[left] &lt; target</span></span><br><span class="line">            <span class="comment">// nums[right] &gt;= target</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid; <span class="comment">// 范围缩小到 (mid, right)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid; <span class="comment">// 范围缩小到 (left, mid)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right; <span class="comment">// 或者 left+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="built_in">lower_bound</span>(nums, target); <span class="comment">// 使用其中一种写法即可</span></span><br><span class="line">        <span class="keyword">if</span> (start == nums.<span class="built_in">size</span>() || nums[start] != target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// 如果 start 存在，那么 end 必定存在</span></span><br><span class="line">        <span class="type">int</span> end = <span class="built_in">lower_bound</span>(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="寻找峰值">162.寻找峰值</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01%2020.48.21.png"
alt="截屏2024-01-01 20.48.21" />
<figcaption aria-hidden="true">截屏2024-01-01 20.48.21</figcaption>
</figure>
<p>对于这道题目，主要的点在于要求时间复杂度必须在 <span
class="math inline">\(O(\log
n)\)</span>。这就要求我们不能够考虑暴力解答的方法。而对于一个数组，从中查找数字时，一般反应是用到二分查找的方法。但是二分查找只适用于有序数组中。这里其实我们也是可以用二分的，跟之前的二分查找方法是一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找旋转排序数组中的最小值">153.寻找旋转排序数组中的最小值</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01%2022.18.01.png"
alt="截屏2024-01-01 22.18.01" />
<figcaption aria-hidden="true">截屏2024-01-01 22.18.01</figcaption>
</figure>
<p>找到小于左右的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> minNum = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; minNum) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; minNum) &#123;</span><br><span class="line">                minNum = nums[mid];</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="搜索旋转排序数组">33.搜索旋转排序数组</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01%2022.33.46.png"
alt="截屏2024-01-01 22.33.46" />
<figcaption aria-hidden="true">截屏2024-01-01 22.33.46</figcaption>
</figure>
<p>两次二分的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> minNum = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; minNum) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; minNum) &#123;</span><br><span class="line">                minNum = nums[mid];</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == minNum) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]) &#123;</span><br><span class="line">            right = left;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]) &#123;</span><br><span class="line">            right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一次二分法：我们分3种情况讨论，什么时候，<code>nums[mid]</code>在<code>target</code>及其右侧，那么都染成蓝色。</p>
<ol type="1">
<li>如果<code>nums[mid]</code>比最后一个数大，说明<code>nums[mid]</code>在左边这段，如果此时<code>target</code>也大于最后一个数。那么<code>target</code>跟<code>nums[mid]</code>在同一段。并且如果这个时候<code>nums[mid]</code>大于等于<code>target</code>。（说明<code>nums[mid]</code>在<code>target</code>及其右侧）那么<code>mid</code>及其右侧就染成蓝色。</li>
<li>就是<code>nums[mid]</code>小于等于最后一个数，那么在右边这段。如果此时<code>target</code>还是大于最后一个数，那么<code>target</code>在左边这段，（直接就说明）<code>mid</code>及其右侧也染成蓝色。</li>
<li>情况二不成立，<code>target</code>在第二段，<code>nums[mid]</code>大于等于<code>target</code>，那么也是蓝色。</li>
<li>其余情况都是红色。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_blue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> end = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> target &gt; end &amp;&amp; nums[i] &gt;= target;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target &gt; end || nums[i] &gt;= target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">-1</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_blue</span>(nums, mid, target)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right == nums.<span class="built_in">size</span>() || nums[right] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈">5.单调栈</h3>
<p>单调栈分为单调递增栈和单调递减栈。对于一组数，从左到右依次入栈，如果栈为空或入栈元素小于栈顶元素，则入栈，否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。这是单调递增栈，单调递减栈相反。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解</span></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">	&#123;</span><br><span class="line">		入栈;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">		&#123;</span><br><span class="line">			栈顶元素出栈;</span><br><span class="line">			更新结果;</span><br><span class="line">		&#125;</span><br><span class="line">		当前数据入栈;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="队列中可以看到的人数">1944.队列中可以看到的人数</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-05%2014.21.34.png"
alt="截屏2024-01-05 14.21.34" />
<figcaption aria-hidden="true">截屏2024-01-05 14.21.34</figcaption>
</figure>
<p>倒过来看问题，这个问题从左向右看问题会很复杂，但是从右向左看就很好维护一个单调递减的单调栈。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">canSeePersonsCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> heightsLen = heights.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(heightsLen, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (heightsLen == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heightsLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt; heights[i]) &#123;</span><br><span class="line">                res[i]++;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                res[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="美丽塔">2866.美丽塔</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-21 13.13.15.png" alt="截屏2023-12-21 13.13.15" style="zoom:50%;" /></p>
<p>根据题意可以知道，假设数组长度为 <span
class="math inline">\(n\)</span> ，对于 <strong>山状数组</strong> <span
class="math inline">\(heights\)</span> 定义如下：</p>
<ul>
<li>假设 <span class="math inline">\(heights[i]\)</span>
为数组中的最大值，则 <span class="math inline">\(i\)</span>
左边的值均小于等于 <span class="math inline">\(heigjts[i]\)</span>
，<span class="math inline">\(i\)</span> 右边的值均小于等于 <span
class="math inline">\(heights[i]\)</span> 。</li>
<li><span class="math inline">\(i\)</span> 的左侧，从 <span
class="math inline">\(0\)</span> 开始到 <span
class="math inline">\(i\)</span> 为 <strong>非递减</strong> 关系，即
<span class="math inline">\(j\in [1,i]\)</span> 时，均满足 <span
class="math inline">\(heights[j-1] \leq heights[j]\)</span></li>
<li><span class="math inline">\(i\)</span> 的右侧，从 <span
class="math inline">\(i\)</span> 开始到 <span
class="math inline">\(n-1\)</span> 为 <strong>非递增</strong> 关系，即
<span class="math inline">\(j\in[i,n-2]\)</span> 时，均满足 <span
class="math inline">\(heights[j+1] \leq heights[j]\)</span></li>
</ul>
<p>题目给出了 <strong>山状数组</strong> 中每个元素的上限，即 <span
class="math inline">\(heights[i]\leq
maxHeights[i]\)</span>，题目要求返回山状数组所有元素之和的最大值。</p>
<ul>
<li>对于 <span class="math inline">\(j\in[0, i - 1]\)</span> 时，此时
<span class="math inline">\(\max(heights[j])=\min(heights[j+1],
maxHeights[j])\)</span></li>
<li>对于 <span class="math inline">\(j\in [i + 1, n - 1]\)</span>
时，此时 <span
class="math inline">\(\max(heights[j])=\min(heights[j-1],maxHeights[j])\)</span></li>
<li>假设此时山状数组的山顶为 <span
class="math inline">\(heights[i]\)</span>
，此时整个山状数组的所有元素的最大值即可确定，此时数组元素和的最大值也可确定</li>
<li>对于数组中的每个元素尽可能取最大值使得整个数组元素之和最大</li>
</ul>
<p>根据以上分析，我们依次枚举以 <span
class="math inline">\(maxHeights[i]\)</span>
为山顶的山状数组元素之和即可求出最大的高度和。最直接的办法是两层循环，但是此时需要的时间复杂度为
<span class="math inline">\(O(n^2)\)</span> ，会超时。</p>
<p>此时需要优化，对于每个索引 <span class="math inline">\(i\)</span>
可以将数组分为两部分处理，即保证数组的左侧构成非递减，右侧构成非递增。为了使得数组元素尽可能大，此时
<span class="math inline">\(heights[i]\)</span> 应取值为 <span
class="math inline">\(maxHeigths[i]\)</span>，设区间 <span
class="math inline">\([0,i]\)</span> 构成的非递减数组元素和的最大值为
<span class="math inline">\(prefix[i]\)</span> ，区间 <span
class="math inline">\([i,n-1]\)</span> 构成的非递增数组元素和最大值为
<span class="math inline">\(suffix[i]\)</span>
，此时构成的山状数组的元素之和为 <span
class="math inline">\(prefix[i]+suffix[i]-maxHeights[i]\)</span> 。</p>
<p>如何使得数组成为递增或递减，此时我们想到 <code>单调栈</code>
，它可以保证栈中数据的单调性，利用单调栈将连续子数组变为非递减或非递增。</p>
<ul>
<li>对于左侧的非递减：将 <span class="math inline">\(maxHeights\)</span>
依次入栈，对于第 <span class="math inline">\(i\)</span>
个元素来说，不断从栈顶弹出元素，直到栈顶元素小于等于 <span
class="math inline">\(maxHeights[i]\)</span> 。假设此时栈顶元素为 <span
class="math inline">\(maxHeights[j]\)</span> ，则区间 <span
class="math inline">\([j+1,i-1]\)</span> 中的元素最多只能取到 <span
class="math inline">\(maxHeights[i]\)</span> ，则 <span
class="math inline">\(prefix[i]=prefix[j]+(i-j)\times
maxHeights[i]\)</span></li>
<li>对于右侧的非递减：将 <span class="math inline">\(maxHeights\)</span>
依次入栈，对于第 <span class="math inline">\(i\)</span>
个元素来说，不断从栈顶弹出元素，直到栈顶元素 直到栈顶元素小于等于 <span
class="math inline">\(maxHeights[i]\)</span> 。假设此时栈顶元素为 <span
class="math inline">\(maxHeights[j]\)</span> ，则区间 <span
class="math inline">\([i+1,j-1]\)</span> 中的元素最多只能取到 <span
class="math inline">\(maxHeights[i]\)</span> ，则 <span
class="math inline">\(suffix[i]=suffix[j]+(j-i)\times
maxHeights[i]\)</span></li>
</ul>
<p>我们按照上述规则枚举每个位置 <span class="math inline">\(i\)</span>
，并计算出以 <span class="math inline">\(i\)</span>
为山顶的数组之和，此时山状数组的最大值即为 <span
class="math inline">\(\max(prefix[i]+suffix[i]-maxHeights[i])\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumSumOfHeights</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = maxHeights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">prefix</span><span class="params">(n)</span>, <span class="title">suffix</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack1, stack2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stack1.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                prefix[i] = (<span class="type">long</span> <span class="type">long</span>) (i + <span class="number">1</span>) * maxHeights[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix[i] = prefix[stack1.<span class="built_in">top</span>()] + (<span class="type">long</span> <span class="type">long</span>) (i - stack1.<span class="built_in">top</span>()) * maxHeights[i];</span><br><span class="line">            &#125;</span><br><span class="line">            stack1.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack2.<span class="built_in">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stack2.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                stack2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                suffix[i] = (<span class="type">long</span> <span class="type">long</span>) (n - i) * maxHeights[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                suffix[i] = suffix[stack2.<span class="built_in">top</span>()] + (<span class="type">long</span> <span class="type">long</span>) (stack2.<span class="built_in">top</span>() - i) * maxHeights[i];</span><br><span class="line">            &#125;</span><br><span class="line">            stack2.<span class="built_in">emplace</span>(i);</span><br><span class="line">            res = <span class="built_in">max</span>(res, prefix[i] + suffix[i] - maxHeights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3>
<h4 id="二进制枚举">二进制枚举</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::vector&lt;int&gt; res;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; 4; i++) res.push_back(i);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++) <span class="comment">//从0～2^n-1个状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) <span class="comment">//遍历二进制的每一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))<span class="comment">//判断二进制第j位是否存在</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);<span class="comment">//如果存在输出第j个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这种情况下，输出的值为</span></span><br><span class="line"><span class="comment">0 =&gt; 1000</span></span><br><span class="line"><span class="comment">1 =&gt; 0100</span></span><br><span class="line"><span class="comment">0 1 =&gt; 1100</span></span><br><span class="line"><span class="comment">2 =&gt; 0010</span></span><br><span class="line"><span class="comment">0 2 =&gt; 1010</span></span><br><span class="line"><span class="comment">1 2 =&gt; 0110</span></span><br><span class="line"><span class="comment">0 1 2 =&gt; 1110</span></span><br><span class="line"><span class="comment">3 =&gt; 1=0001</span></span><br><span class="line"><span class="comment">0 3 =&gt; 1001</span></span><br><span class="line"><span class="comment">1 3 =&gt; 0101</span></span><br><span class="line"><span class="comment">0 1 3 =&gt; 1101</span></span><br><span class="line"><span class="comment">2 3 =&gt; 0011</span></span><br><span class="line"><span class="comment">0 2 3 =&gt; 1011</span></span><br><span class="line"><span class="comment">1 2 3 =&gt; 0111</span></span><br><span class="line"><span class="comment">0 1 2 3 =&gt; 1111</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="被列覆盖的最多行数"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">2397.
被列覆盖的最多行数</a></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumRows</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> numSelect)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mask</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                mask[i] += matrix[i][j] &lt;&lt; (n - j - <span class="number">1</span>); <span class="comment">// 计算每一行的十进制值 0, 5, 3, 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mask:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); i++) cout &lt;&lt; mask[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> limit = (<span class="number">1</span> &lt;&lt; n); <span class="comment">// 进行二进制枚举，共有 2^n 种情况，就是1 左移 3 位的值</span></span><br><span class="line">        cout  &lt;&lt; <span class="string">&quot;limit: &quot;</span> &lt;&lt; limit &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> ((++cur) &lt; limit) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;cur: &quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot; cur的二进制：&quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">3</span>&gt;(cur) &lt;&lt; <span class="string">&quot; __builtin_popcount(cur): &quot;</span> &lt;&lt; __builtin_popcount(cur) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_popcount(cur) != numSelect) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask[j] &amp; cur) == mask[j]) &#123; <span class="comment">// 与运算，如果两位都为1结果才是1，</span></span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix&#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> res = s.<span class="built_in">maximumRows</span>(matrix, <span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="移除栅栏得到的正方形田地的最大面积">100169.<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/">移除栅栏得到的正方形田地的最大面积</a></h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-24 12.28.03.png" alt="截屏2023-12-24 12.28.03" style="zoom:50%;" /></p>
<p>相当于给顶一些横线竖线，找出这些横线竖线之间可能构造出来的最大正方形。正方形两条边边长一样，因此找到的横线的横坐标之差需要等于找到的竖线的纵坐标之差。由于横线竖线数量相对不多，我们可以直接枚举所有情况，看其中是否有公共元素，找出最大的公共元素算平方即可。这只需要通过哈希表记录判断即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximizeSquareArea</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; hFences, vector&lt;<span class="type">int</span>&gt;&amp; vFences)</span> </span>&#123;</span><br><span class="line">        hFences.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        hFences.<span class="built_in">push_back</span>(m);</span><br><span class="line">        vFences.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        vFences.<span class="built_in">push_back</span>(n);</span><br><span class="line">        <span class="built_in">sort</span>(hFences.<span class="built_in">begin</span>(), hFences.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vFences.<span class="built_in">begin</span>(), vFences.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> hFencesLen = hFences.<span class="built_in">size</span>(), vFencesLen = vFences.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hFencesLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                mp[<span class="built_in">abs</span>(hFences[i] - hFences[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vFencesLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp[<span class="built_in">abs</span>(vFences[i] - vFences[j])]) &#123;</span><br><span class="line">                    <span class="type">int</span> a = <span class="built_in">abs</span>(vFences[i] - vFences[j]);</span><br><span class="line">                    res = <span class="built_in">max</span>(res, a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">-1</span> ? <span class="number">-1</span> : ((<span class="type">long</span>)res * (<span class="type">long</span>)res) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4
id="找出出现至少三次的最长特殊子字符串-i">找出出现至少三次的最长特殊子字符串
I</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-31%2012.09.55.png"
alt="截屏2023-12-31 12.09.55" />
<figcaption aria-hidden="true">截屏2023-12-31 12.09.55</figcaption>
</figure>
<p>长度为 <span class="math inline">\(x\)</span>
的特殊字符串里包含几个长度为 <span class="math inline">\(y\)</span>
的子串？答案是 <span class="math inline">\((x - y + 1)\)</span> 个。</p>
<p>设原串中，最长的特殊子串长度为 <span class="math inline">\(m\)</span>
，那么长度为 <span class="math inline">\((m - 2)\)</span>
的子串在该串中至少出现 <span class="math inline">\(m - (m - 2) + 1 =
3\)</span> 次，因此答案至少是 <span
class="math inline">\((m-2)\)</span>，至多是 <span
class="math inline">\(m\)</span> 。</p>
<p>因此直接从 <span class="math inline">\(m\)</span> 到 <span
class="math inline">\((m - 2)\)</span>
枚举答案，并计算这个长度的特殊子串有几个即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumLength</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sLen = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> last = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != last) &#123;</span><br><span class="line">                vec[last - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>(len);</span><br><span class="line">                last = s[i];</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[last - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>(len);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec[i]) &#123;</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ans = mx; ans &gt;= mx - <span class="number">2</span> &amp;&amp; ans ; ans--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v &gt;= ans) cnt += (v - ans) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="建图-floyd">建图-floyd</h3>
<h4 id="转换字符串的最小成本-i"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-convert-string-i/">100156.
转换字符串的最小成本 I</a></h4>
<p>建图，从 <span class="math inline">\(original[i]\)</span> 向 <span
class="math inline">\(changed[i]\)</span> 连边，边权为 <span
class="math inline">\(cost[i]\)</span>
。然后用Floyd算法求图中任意两点最短路，得到 <span
class="math inline">\(dis\)</span> 矩阵，最后累加所有的 <span
class="math inline">\(dis[original[i]][changed[i]]\)</span>
，即为答案，如果答案为无穷啊，返回-1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumCost</span><span class="params">(string source, string target, vector&lt;<span class="type">char</span>&gt;&amp; original, vector&lt;<span class="type">char</span>&gt;&amp; changed, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = original.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(<span class="number">26</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">10000001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> o = original[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> c = changed[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            g[o][c] = <span class="built_in">min</span>(g[o][c], cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Floyd</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">26</span>; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">26</span>; y++) &#123;</span><br><span class="line">                    g[x][y] = <span class="built_in">min</span>(g[x][y], g[x][k] + g[k][y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = source.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> cur = g[source[j] - <span class="string">&#x27;a&#x27;</span>][target[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= <span class="number">10000001</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ans += cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="收集巧克力"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/collecting-chocolates/">2735.
收集巧克力</a></h4>
<p><strong>巧妙枚举</strong></p>
<ul>
<li>枚举操作次数，从操作<code>0</code>次枚举到操作<code>n-1</code>次</li>
<li>如果不操作，第 <span class="math inline">\(i\)</span>
个巧克力必须花费 <span class="math inline">\(nums[i]\)</span>
收集，总花费为所有 <span class="math inline">\(nums[i]\)</span>
之和。如果只操作一次，第 <span class="math inline">\(i\)</span>
个巧克力可以在操作前购买，取最小值，即 <span
class="math inline">\(\min(nums[i], num[(i + 1) \mod n])\)</span>
.如果操作两次，购买第 <span class="math inline">\(i\)</span>
个巧克力的花费为 <span class="math inline">\(\min(nums[i], nums[(i + 1)
\mod n], nums[(i + 2) \mod
n])\)</span>。例如示例1，我们可以操作两次，这样每块巧克力都只需要1的花费，总成本为
<span class="math inline">\(2x+1+1+1=13\)</span>。</li>
<li>如果暴力枚举操作次数，再枚举每个巧克力，再计算购买这个巧克力的最小花费，总的时间复杂度是
<span class="math inline">\(O(n^3)\)</span>。一个初步的优化是，用 <span
class="math inline">\(O(n^2)\)</span>
的时间预处理所有子数组的最小值，保存到一个二维数组中。这样做需要 <span
class="math inline">\(O(n^2)\)</span> 的时间和空间。但其实不需要与处理：
<ol type="1">
<li>用一个长为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(s\)</span> 统计不同操作次数下的总成本。</li>
<li>写一个二重循环，枚举子数组的左端点 <span
class="math inline">\(i\)</span> 和右端点 <span
class="math inline">\(j\)</span>。</li>
<li>在枚举右端点的同时，维护从 <span
class="math inline">\(nums[i]\)</span> 到 <span
class="math inline">\(nums[j]\)</span> 的最小值 <span
class="math inline">\(mn\)</span> 。</li>
<li>把 <span class="math inline">\(mn\)</span> 加到 <span
class="math inline">\(s[j - i]\)</span> 中，这是因为长为 <span
class="math inline">\(j - i + 1\)</span> 的子数组恰好对应着操作 <span
class="math inline">\(j-i\)</span> 次时要计算的子数组。</li>
<li>最后输出 <span class="math inline">\(\min(s)\)</span> 。</li>
</ol></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;  <span class="comment">// s[k] 统计操作 k 次的总成本</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s[i] = (<span class="type">long</span> <span class="type">long</span>) i * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> mn = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n + i; j++) &#123; <span class="comment">// 子数组右端点（把数组视为环形的） </span></span><br><span class="line">                mn = <span class="built_in">min</span>(mn, nums[j % n]);  <span class="comment">// 维护从 nums[i] 到 nums[j] 的最小值</span></span><br><span class="line">                s[j - i] += mn;  <span class="comment">// 累加操作 j - i 次的花费</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="链表">链表</h4>
<h5 id="反转链表">206反转链表</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2022.42.44.png"
alt="截屏2024-01-02 22.42.44" />
<figcaption aria-hidden="true">截屏2024-01-02 22.42.44</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="反转链表-1">92.反转链表</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2022.58.03.png"
alt="截屏2024-01-02 22.58.03" />
<figcaption aria-hidden="true">截屏2024-01-02 22.58.03</figcaption>
</figure>
<p>从上题可以知道，反转结束后，从原来的链表上看： <span
class="math inline">\(pre\)</span> 指向反转这一段的末尾，<span
class="math inline">\(cur\)</span> 指向反转这一段后续的下一个节点。</p>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2023.26.25.png"
alt="截屏2024-01-02 23.26.25" />
<figcaption aria-hidden="true">截屏2024-01-02 23.26.25</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* p0 = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) p0 = p0-&gt;next;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = p0-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p0-&gt;next-&gt;next = cur;</span><br><span class="line">        p0-&gt;next = pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="k个一组反转链表">25.K个一组反转链表</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2023.50.11.png"
alt="截屏2024-01-02 23.50.11" />
<figcaption aria-hidden="true">截屏2024-01-02 23.50.11</figcaption>
</figure>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2023.46.44.png"
alt="截屏2024-01-02 23.46.44" />
<figcaption aria-hidden="true">截屏2024-01-02 23.46.44</figcaption>
</figure>
<p>跟上边的题目类似，不过这里主要是注意，<span
class="math inline">\(p0\)</span>的变化，在一次反转之后，我们把 <span
class="math inline">\(next\)</span> 改为 <span
class="math inline">\(p0\to next\)</span>
，即1位置，其实这也是经过反转后的下一个 <span
class="math inline">\(p0\)</span>的起始位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ListNodeLen = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            ListNodeLen ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* p0 = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ListNodeLen &gt;= k) &#123;</span><br><span class="line">            ListNodeLen -= k;</span><br><span class="line">            ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">            cur = p0-&gt;next;</span><br><span class="line">            ListNode* next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = p0-&gt;next;</span><br><span class="line">            p0-&gt;next-&gt;next = cur;</span><br><span class="line">            p0-&gt;next = pre;</span><br><span class="line">            p0 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="从链表中移除节点">2487.从链表中移除节点</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2017.15.59.png"
alt="截屏2024-01-03 17.15.59" />
<figcaption aria-hidden="true">截屏2024-01-03 17.15.59</figcaption>
</figure>
<p>反过来遍历，每次保存遍历中的最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将链表反转</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;ListNode*&gt; vec;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pre) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;val &gt;= max) &#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(pre);</span><br><span class="line">                max = pre-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        res = vec[vec.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vec[<span class="number">0</span>]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="链表的中间结点">876.链表的中间结点</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.22.21.png"
alt="截屏2024-01-03 22.22.21" />
<figcaption aria-hidden="true">截屏2024-01-03 22.22.21</figcaption>
</figure>
<p>使用快慢指针，我们可以用两个指针，一个叫做慢指针，一个叫做快指针。每次循环，慢指针走一步，快指针走两步。我们可以通过数学归纳法，证明长度为奇数的时候，如果快指针在最后一个节点，那么慢指针一定在中间结点。对于偶数长度也是一样的。
如果快指针指向空，那么慢指针一定在中间结点上。</p>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.28.44.png"
alt="截屏2024-01-03 22.28.44" />
<figcaption aria-hidden="true">截屏2024-01-03 22.28.44</figcaption>
</figure>
<p>综合这两种情况，当快指针指向空，或者他的下一个节点指向空，这个时候就退出循环，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* node1 = head;</span><br><span class="line">        ListNode* node2 = head;</span><br><span class="line">        <span class="keyword">while</span> (node1 &amp;&amp; node1-&gt;next) &#123;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="环形链表">141.环形链表</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.35.14.png"
alt="截屏2024-01-03 22.35.14" />
<figcaption aria-hidden="true">截屏2024-01-03 22.35.14</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* node1 = head;</span><br><span class="line">        ListNode* node2 = head;</span><br><span class="line">        <span class="keyword">while</span> (node1 &amp;&amp; node1-&gt;next) &#123;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node1 == node2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="环形列表2">142.环形列表2</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.40.21.png"
alt="截屏2024-01-03 22.40.21" />
<figcaption aria-hidden="true">截屏2024-01-03 22.40.21</figcaption>
</figure>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.40.50.png"
alt="截屏2024-01-03 22.40.50" />
<figcaption aria-hidden="true">截屏2024-01-03 22.40.50</figcaption>
</figure>
<p>快指针移动距离是慢指针的两倍， <span class="math display">\[
2(a+b)=a+b+k(b+c)\\
2a+2b=a+b+b+c+(k-1)(b+c)\\
a-c=(k-1)(b+c)
\]</span> <img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.43.28.png"
alt="截屏2024-01-03 22.43.28" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* node1 = head;</span><br><span class="line">        ListNode* node2 = head;</span><br><span class="line">        <span class="keyword">while</span> (node1 &amp;&amp; node1-&gt;next) &#123;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node1 == node2) &#123;</span><br><span class="line">                <span class="keyword">while</span> (node2 != head) &#123;</span><br><span class="line">                    node2 = node2-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> node2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="重排链表">重排链表</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.59.08.png"
alt="截屏2024-01-03 22.59.08" />
<figcaption aria-hidden="true">截屏2024-01-03 22.59.08</figcaption>
</figure>
<p>找到中间结点，然后将中间结点之后的结点全部反转，之后再进行两个链表的交错排列即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将链表反转</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = slow;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// head2 为当前反转链表的头节点。</span></span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        ListNode* head2 = pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head2 != slow &amp;&amp; head2-&gt;next) &#123;</span><br><span class="line">            ListNode* next1 = head1-&gt;next;</span><br><span class="line">            ListNode* next2 = head2-&gt;next;</span><br><span class="line">            head1-&gt;next = head2;</span><br><span class="line">            head2-&gt;next = next1;</span><br><span class="line">            head1 = next1;</span><br><span class="line">            head2 = next2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="在链表中插入最大公约数">2807.在链表中插入最大公约数</h5>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-06%2020.21.08.png"
alt="截屏2024-01-06 20.21.08" />
<figcaption aria-hidden="true">截屏2024-01-06 20.21.08</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> temp = m % n;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertGreatestCommonDivisors</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        pre = head;</span><br><span class="line">        <span class="keyword">while</span> (pre &amp;&amp; pre-&gt;next) &#123;</span><br><span class="line">            next = pre-&gt;next;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">gcd</span>(pre-&gt;val, next-&gt;val);</span><br><span class="line">            ListNode* cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">            cur-&gt;val = tmp;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            pre = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="删除链表重复节点">237.删除链表重复节点</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="删除链表的倒数第n个节点">19.删除链表的倒数第N个节点</h5>
<p>首先，在之前的反转链表的题目，有些题目用到了哨兵节点这个技巧，那么什么时候需要哨兵节点，什么时候不需要哨兵节点？对于删除节点来说，一般来说需要删除头节点的话，需要哨兵节点。</p>
<p>对于这个题目来说，我们可以先让一个指针走完整个链表，求出链表长度，再结合n求出倒数第N个节点在链表哪个位置。</p>
<p>我们也可以初始化左右指针，当右指针走到第n个位置的时候，我们让左指针开始移动，这样左右指针中间相差n个位置。当右指针走到底的时候，左指针就是答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* left = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* right = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        left = dummy;</span><br><span class="line">        right = dummy;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &amp;&amp; right-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= n) &#123;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left-&gt;next = left-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="删除排序链表中的重复元素">83.删除排序链表中的重复元素</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy = head;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next ) <span class="keyword">return</span> dummy;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val == head-&gt;next-&gt;val) &#123;</span><br><span class="line">                head-&gt;next = head-&gt;next-&gt;next;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="删除排序链表中的重复元素2">82.删除排序链表中的重复元素2</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="type">int</span> val = cur-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树与递归">二叉树与递归</h3>
<p>如何计算二叉树的深度，不要一开始就陷入细节，而是思考整棵树与其左右子树的关系。整棵树的深度=max（左子树的最大深度，右子树的最大深度）+1.。这样思考后，你会发现，原问题：计算整棵树的最大深度，子问题：计算左/右子树的最大深度。子问题与原问题是相似的。类比循环，执行的代码也应该是相同的，但子问题需要把计算结果返给上一级问题，这更适合用递归实现。由于子问题的规模比原问题小，不断递归下去，总会有个尽头，即递归的边界条件（base
case）。直接返回它的答案（归）。</p>
<h4 id="二叉树的最大深度">104.二叉树的最大深度</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2015.22.07.png"
alt="截屏2024-01-19 15.22.07" />
<figcaption aria-hidden="true">截屏2024-01-19 15.22.07</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deep</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l_d = <span class="built_in">deep</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> l_r = <span class="built_in">deep</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l_d, l_r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deep</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="相同的树">100.相同的树</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2016.13.09.png"
alt="截屏2024-01-19 16.13.09" />
<figcaption aria-hidden="true">截屏2024-01-19 16.13.09</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对称二叉树">101.对称二叉树</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2016.18.30.png"
alt="截屏2024-01-19 16.18.30" />
<figcaption aria-hidden="true">截屏2024-01-19 16.18.30</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deep</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">deep</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">deep</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">-1</span> || <span class="built_in">abs</span>(r - l) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deep</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的右视图">199.二叉树的右视图</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2016.39.27.png"
alt="截屏2024-01-19 16.39.27" />
<figcaption aria-hidden="true">截屏2024-01-19 16.39.27</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth == ans.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">f</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">f</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">f</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="周赛">周赛</h3>
<h4 id="section">380-2024-1-14</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-14 18.46.28.png" alt="截屏2024-01-14 18.46.28" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFrequencyElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numsLen = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">105</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> max_nums = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            cnt[nums[i]] ++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[nums[i]] &gt; max_nums) &#123;</span><br><span class="line">                max_nums = cnt[nums[i]];</span><br><span class="line">                res = max_nums;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt[nums[i]] == max_nums) &#123;</span><br><span class="line">                res += max_nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-14%2018.47.10.png"
alt="截屏2024-01-14 18.47.10" />
<figcaption aria-hidden="true">截屏2024-01-14 18.47.10</figcaption>
</figure>
<p>一开始想的是直接暴力，结果就是超时。WAWA！</p>
<p>两种解法：</p>
<ol type="1">
<li>二分+数位DP</li>
<li>二分+枚举数位</li>
</ol>
<p>要用到二分，就要考虑是否有单调性，对于这道题目，我们观察到<code>num</code>
越大 其价值和越大，这就是题目包含的单调性。</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-14 18.58.33.png" alt="截屏2024-01-14 18.58.33" style="zoom:50%;" /></p>
<p>我们需要找到一个小于等于<code>k</code>
的最大的一个包含num的ans。这样就变成了，给定 <code>num</code> 统计
<code>1~num</code> 的价值和，判断价值和是否 <code>&lt;=k</code>
。二分相当于多花费 <code>log</code> 的时间，额外增加一个条件。</p>
<p><strong>数位DP模版</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">findMaximumNumber</span><span class="params">(<span class="type">long</span> <span class="type">long</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">long</span> <span class="type">long</span> num) &#123;</span><br><span class="line">            <span class="type">int</span> m = <span class="number">64</span> - __builtin_clzll(num);  <span class="comment">//确定一个整数的二进制表示中有多少位</span></span><br><span class="line">            vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">memo</span>(m, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">            function&lt;<span class="type">long</span> <span class="type">long</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>)&gt;dfs = [&amp;](<span class="type">int</span> i, <span class="type">int</span> cnt1, <span class="type">bool</span> is_limit) -&gt; <span class="type">long</span> <span class="type">long</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> cnt1;</span><br><span class="line">                <span class="keyword">if</span> (!is_limit &amp;&amp; memo[i][cnt1] &gt;= <span class="number">0</span>) <span class="keyword">return</span> memo[i][cnt1];</span><br><span class="line">                <span class="type">int</span> up = is_limit ? num &gt;&gt; i &amp; <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">                    res += <span class="built_in">dfs</span>(i - <span class="number">1</span>, cnt1 + (d == <span class="number">1</span> &amp;&amp; (i + <span class="number">1</span>) % x == <span class="number">0</span>), is_limit &amp;&amp; d == up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!is_limit) memo[i][cnt1] = res;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(m - <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>) &lt;= k;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = (k + <span class="number">1</span>) &lt;&lt; x;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            (<span class="built_in">check</span>(mid) ? left : right) = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="杂乱题目">杂乱题目</h3>
<h4 id="年5月">2023年5月</h4>
<h5
id="填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</h5>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-12 21.28.37.png" alt="截屏2023-05-12 21.28.37" style="zoom:50%;" /></p>
<p>对于二叉树问题，首先要想到几种遍历方法：</p>
<ol type="1">
<li><p>前序遍历</p></li>
<li><p>中序遍历</p></li>
<li><p>后序遍历</p></li>
<li><p>深度优先搜索DFS</p></li>
<li><p>宽度优先搜索BFS</p>
<p>这道题目要求的是把每一行都串联起来，那么BFS按层遍历就很合适。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这是一个BFS模版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">      queue&lt;TreeNode*&gt; q;</span><br><span class="line">      q.<span class="built_in">push</span>(root);																				<span class="comment">// 把节点添加到队列尾部</span></span><br><span class="line">      <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();												<span class="comment">// 出队列</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">          	q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">          	q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 具体解题代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len_level = q.<span class="built_in">size</span>();                   <span class="comment">// 代表每一层节点的数量</span></span><br><span class="line">            Node* pre = <span class="literal">nullptr</span>;                        <span class="comment">// 前一个节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != len_level; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>)</span><br><span class="line">                    pre-&gt;next = node;</span><br><span class="line">                pre = node;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="二叉搜索树中第k小的元素">二叉搜索树中第K小的元素</h5>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-13 21.48.17.png" alt="截屏2023-05-13 21.48.17" style="zoom:50%;" /></p>
<p>可以吧整个树都遍历一遍，然后吧结果存储到vector中，在进行排序找到第K小的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> vec[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>------------------2023年5月13日-----------</p>
<h5 id="岛屿数量">岛屿数量</h5>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-13 21.56.03.png" alt="截屏2023-05-13 21.56.03" style="zoom:50%;" /></p>
<p>题目思路：DFS解决，</p>
<p>这题让求的是岛屿的数量，二维数组中值是1的都是岛屿，如果多个1是连着的，那么他们只能算一个岛屿。最简单的一种方式是遍历数组中的每一个数值，如果是1就说明是岛屿，然后把它置为0或者其他的字符都可以，然后再遍历他的上下左右4个位置。如果是1，就说明这两个岛屿是连着的，只能算是一个岛屿。我们还要把它置为0，然后以它为中心遍历它的上下左右4个位置。如果是0，就说明不是岛屿，就不在往它的上下左右4个位置遍历了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 把当前格子以及他邻近为1的格子都置为1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>|| i &gt;= grid.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 把当前格子置为0，然后遍历他的上下左右4个方向</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lands_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != grid.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    lands_cnt ++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lands_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是显然，这种方法效率很差，单从两个嵌套的for循环来说，这里就已经是
<span class="math display">\[
O(n^2)
\]</span> 2023年5月16日22:22</p>
<hr />
<h5 id="电话号码的字母组合">电话号码的字母组合</h5>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-21 21.14.39.png" alt="截屏2023-05-21 21.14.39" style="zoom:50%;" /></p>
<p>可以使用BFS来进行搜索，将整个过程视为n叉树。</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-22 22.23.41.png" alt="截屏2023-05-22 22.23.41" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string digits = <span class="string">&quot;23&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != res.<span class="built_in">size</span>(); i++)</span><br><span class="line">            std::cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; tab = &#123;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;, &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;, &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line">                                &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != tab.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != tab[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; tab[i][j] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::queue&lt;std::string&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">front</span>().<span class="built_in">size</span>() != digits.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::string remove = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        std::vector&lt;<span class="type">char</span>&gt; chars = tab[digits[remove.<span class="built_in">size</span>()] - <span class="string">&#x27;2&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chars.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(remove + chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::string str = que.<span class="built_in">front</span>();</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">        res.<span class="built_in">push_back</span>(str);</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; digits &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-22 23.12.09.png" alt="截屏2023-05-22 23.12.09" style="zoom:50%;" /></p>
<h5 id="有效括号生成">有效括号生成</h5>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-26 22.46.13.png" alt="截屏2023-05-26 22.46.13" style="zoom:50%;" /></p>
<p>通过观察我们可以发现，生成的任何括号组合中都有两个规律：</p>
<ol type="1">
<li>括号组合中左括号的数量等于右括号的数量</li>
<li>括号组合中任何位置左括号的数量都是大于等于右括号的数量</li>
</ol>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-26 22.47.16.png" alt="截屏2023-05-26 22.47.16" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt; &amp;res, <span class="type">int</span> left, <span class="type">int</span> right, string cur_str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) <span class="comment">// 左右括号都不剩余了，说明找到了有效的括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur_str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号只有剩余的时候才可以选，如果左括号的数量已经选完了，是不能再选左括号</span></span><br><span class="line">        <span class="comment">// 如果选完了左括号我们还是可以选择右括号的</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果右括号剩余数量小于左括号的剩余数量，说明之前选择的无效</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(res, left - <span class="number">1</span>, right, cur_str + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(res, left, right - <span class="number">1</span>, cur_str + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(res, n, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5
id="全排列">全排列<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-27 21.40.35.png" alt="截屏2023-05-27 21.40.35" style="zoom:50%;" /></h5>
<p>首先根据数学定义：全排列的总个数为 <span
class="math inline">\(n!\)</span>个。根据之前的思路，可以从搜索的方法入手。</p>
<p><img src="/Users/huangqiuzhao/Downloads/IMG_6219E6E27471-1.jpeg" alt="IMG_6219E6E27471-1" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯模版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtrack</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> first, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == len)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[first]);</span><br><span class="line">            <span class="built_in">backTrack</span>(nums, first + <span class="number">1</span>, len);</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backTrack</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="单词搜索">单词搜索</h5>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-31 21.29.08.png" alt="截屏2023-05-31 21.29.08" style="zoom:50%;" /></p>
<p>首先反应就是之前遇到过的岛屿问题，进行DFS搜索，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 边界判断，如果越界直接返回false, index表示的是查找到字符串word的第几个字符</span></span><br><span class="line">        <span class="comment">// 如果这个字符不等于board[i][j], 说明这个坐标路径是走不通的, 直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.<span class="built_in">size</span>() || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || board[i][j] != word[index])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果word的每个字符都查找完了，直接返回truetrue</span></span><br><span class="line">        <span class="keyword">if</span> (index == word.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 把当前的坐标值保存下来，为了在最后复原</span></span><br><span class="line">        <span class="type">char</span> tmp = board[i][j];</span><br><span class="line">        <span class="comment">// 然后修改当前坐标的值</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="comment">// 走递归, 沿着当前坐标的上下左右4各方向查找</span></span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(board, word, i + <span class="number">1</span>, j, index + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i - <span class="number">1</span>, j, index + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i, j + <span class="number">1</span>, index + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i, j - <span class="number">1</span>, index + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归之后再把当前的坐标复原</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="年6月">2023年6月</h4>
<h5 id="颜色分类">1、颜色分类</h5>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-06-05 21.14.20.png" alt="截屏2023-06-05 21.14.20" style="zoom:50%;" /></p>
<p>感觉可以使用冒泡排序啊，原地进行排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j != nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = nums[i];</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt;= nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>嘿嘿，果然一个冒泡排序就可以解决。但是效率太差了。这里还有一个三指针的做法，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> right, <span class="type">int</span> left)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = nums[right];</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">        nums[left] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0的右边界</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2的左边界</span></span><br><span class="line">        <span class="type">int</span> left = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 指向当前数字</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt;= left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, right++, index++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, left--, index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr />
<p>2023年6月5日21:28</p>
<h4 id="week1">2023-7-10（WEEK1）</h4>
<p>😮‍💨最近这一个月太堕落了，一个月都没有做力扣题目QAQ！要好好补一下。</p>
<p><strong>认识复杂度和简单排序算法</strong></p>
<p>评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/选择排序</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">      minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> tmp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">swap</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; arr; <span class="type">int</span> i; <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e = arr.<span class="built_in">size</span>() - <span class="number">1</span>; e &gt; <span class="number">0</span>; e --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="section-1">2023-10-8</h4>
<p>周赛错题记录：</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 12.09.20.png" alt="截屏2023-10-08 12.09.20" style="zoom:50%;" /></p>
<p>考虑两个数 <span class="math inline">\(a\)</span>和 <span
class="math inline">\(b\)</span>的二进制表示，讨论二进制第 <span
class="math inline">\(i\)</span>位在 <span
class="math inline">\(a\)</span>和 <span
class="math inline">\(b\)</span>中是否为1的情况：</p>
<ul>
<li>若a和b的第i位都是0，那么<code>a AND b</code>
和<code>a OR b</code>的第i位也都是0.</li>
<li>若a和b的第i位恰有一个1，那么<code>a AND b</code>
的第i位是0，<code>a OR b</code>的第i位是1.</li>
<li>若 <em>a</em> 和 <em>b</em> 的第 i<em>i</em> 位都是 1，那么
<code>a AND b</code> 和 <code>a OR b</code> 的第 i 位也都是 1。</li>
</ul>
<p>令<code>f(a)</code>表示<code>a</code>的二进制表示中有几个1，不难发现<code>f(a) + f(b) = f(a AND b) + f(a OR b)</code>。只不过所有的1首先都被
<code>a OR b</code>抢了，剩下的1才会留给
<code>a AND b</code>。也就是说，每个二进制位中，1的总数不变。只不过我们可以通过任意次操作，把1都集中在某个数里。为了选择<span
class="math inline">\(k\)</span>个元素使得平方和最大，我们首先 要让<span
class="math inline">\(k\)</span>个元素尽可能大。在 <span
class="math inline">\(k\)</span>个元素的总和相同的情况下，我们还要让最大值尽可能大（证明可以考虑
<span class="math inline">\(y=x^2+(c-x)^2\)</span>的函数图像） 我们把 1
都集中在某个数里，完美符合这两条性质。</p>
<p>因此做法就是统计每个二进制位里有多少个1，然后用这些1拼出尽可能大的数。</p>
<blockquote>
<h3 id="按位与运算符">按位与<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=运算符&amp;spm=1001.2101.3001.7020">运算符</a>（&amp;）</h3>
<p>参加运算的两个数据，按<strong>二进制位</strong>进行“与”运算。
运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;
即：<strong>两位同时为“1”，结果才为“1”，否则为0</strong></p>
<h3 id="按位或运算符">按位或运算符（|）</h3>
<p>参加运算的两个对象，按二进制位进行“或”运算。 运算规则：0|0=0；
0|1=1； 1|0=1； 1|1=1； 即
：<strong>参加运算的两个对象只要有一个为1，其值为1</strong>。</p>
<h3 id="异或运算符">异或运算符（^）</h3>
<p>参加运算的两个数据，按二进制位进行“异或”运算。 运算规则：0^0=0；
0^1=1； 1^0=1； 1^1=0；
即：<strong>参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</strong></p>
<h3 id="按位取反运算符">按位取反运算符（~）</h3>
<p>按位取反运算符（~）是指将整数的各个二进制位都取反，即1变为0，0变为1。</p>
<h3 id="按位左移运算符">按位左移运算符（&lt;&lt;）</h3>
<p>左移运算符是用来将一个数的各二进制位左移若干位，移动的位数由右操作数指定（右操作数必须是非负值），其右边空出的位用0填补，高位左移溢出则舍弃该高位。</p>
<p>在高位没有1的情况下，左移1位相当于该数乘以2，左移2位相当于该数乘以2*2＝4,15＜＜2=60，即乘了４。
但此结论只适用于该数左移时被溢出舍弃的高位中不包含1的情况。</p>
<h3 id="按位右移运算符">按位右移运算符（&gt;&gt;）</h3>
<p>右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负值），移到右端的低位被舍弃，对于无符号数，高位补0。对于有符号数，某些机器将对左边空出的部分用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MAXP = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">// cnt[i]表示第i个二进制位有几个1</span></span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">35</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAXP; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[i] += x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// x 右移 i 位 第i位与1进行与运算。判断该位是否是1.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 拼出尽可能大的k个数</span></span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = MAXP; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i])</span><br><span class="line">                    <span class="comment">// 表示 第i位为1 把第i位拼进now中。</span></span><br><span class="line">                &#123;</span><br><span class="line">                    now |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                    cnt[i]--;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + <span class="number">1LL</span> * now * now) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 12.41.46.png" alt="截屏2023-10-08 12.41.46" style="zoom:50%;" /></p>
<p>什么时候返回-1？</p>
<p>注意到，反转两个字符：</p>
<ul>
<li>如果都是0或者1，那么反转后1的个数会加2或者减2；</li>
<li>如果一个是0另一个是1，那么反转后1的个数不变。</li>
<li>所以，无论是那种操作，都不会改变字符串中的1的个数的奇偶性。</li>
</ul>
<p>故，只要两个字符串中的1的个数的奇偶性不同，就直接返回-1.</p>
<p>然后，先考虑DP，在考虑贪心。毕竟DP就是对暴力搜索的优化。</p>
<p>考虑 <span class="math inline">\(s_1\)</span>和 <span
class="math inline">\(s_2\)</span>的最后一对字符（也可以考虑第一对字符）：</p>
<p>如果相同，那么无需修改。</p>
<p>如果不同：</p>
<p>选择第一种操作，相当于后面可以免费反转一个字符。</p>
<p>选择第二种操作，那么下个字符要把0看作1，把1看作0.</p>
<p>所以除了知道当前下标i，还需要知道免费反转次数j，以及上一个字符是否选择了第二种操作preRew.</p>
<p>定义<span
class="math inline">\(dfs（i,j,preRew)\)</span>，参数含义如下，返回值是在这种状态下的最小操作代价之和。</p>
<p>分类讨论：</p>
<p>如果<code>(s1[i] == s2[i]) == (not pre_rev)</code>表示s1[i]和s2[i]是相等的，无需操作，返回
<span class="math inline">\(dfs(i - 1, j, false)\)</span>。</p>
<p>否则：</p>
<p>选择第一种操作： <span class="math inline">\(dfs(i - 1, j + 1, false)
+ x\)</span>。</p>
<p>选择第二种操作：<span class="math inline">\(dfs(i - 1, j, true) +
1\)</span></p>
<p>如果 <span class="math inline">\(j &gt; 0\)</span>免费反转一次：
<span class="math inline">\(dfs(i - 1, j - 1, false)\)</span>。</p>
<p>这三种情况取最小值。</p>
<p>递归边界，当 <span class="math inline">\(i &lt; 0\)</span>时：</p>
<p>如果 <span class="math inline">\(j &gt; 0\)</span>或者 <span
class="math inline">\(preRew\)</span>为真，那么不合法，返回 无穷大</p>
<p>否则返回0.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(string s1, string s2, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 算出我们要处理的字符串</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) vec.<span class="built_in">push_back</span>(s1[i] == s2[i] ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> f[n + <span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) f[i][j][k] = INF;</span><br><span class="line">        <span class="comment">// 初值</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> nxt = vec[i] ^ j;</span><br><span class="line">            <span class="keyword">if</span> (nxt) &#123;</span><br><span class="line">                f[i + <span class="number">1</span>][<span class="number">1</span>][k] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][<span class="number">1</span>][k], f[i][j][k] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">0</span>) f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], f[i][j][k] + x);</span><br><span class="line">                <span class="keyword">else</span> f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], f[i][j][k]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i + <span class="number">1</span>][<span class="number">0</span>][k] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][<span class="number">0</span>][k], f[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>][<span class="number">0</span>] &lt; INF ? f[n][<span class="number">0</span>][<span class="number">0</span>] : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 20.54.56.png" alt="截屏2023-10-08 20.54.56" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSetSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[arr[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mp) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += res[i];</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= arr.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="子数组的最小值之和">907.子数组的最小值之和</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-11-27 20.16.44.png" alt="截屏2023-11-27 20.16.44" style="zoom:50%;" /></p>
<p>一般来说，计算每个子数组的最小值之和，先是枚举每个子数组，在求出每个子数组的最小值，最后累加最小值。但是枚举每个子数组需要
<span
class="math inline">\(O(n^2)\)</span>的时间，而顺序扫描子数组并计算子数组的最小值，又需要
<span
class="math inline">\(O(n)\)</span>的时间，也就是说，对于正向思维来说，算法的时间复杂度为
<span class="math inline">\(O(n^3)\)</span>，这对于 <span
class="math inline">\(1 &lt;= n &lt; 3 *
10^4\)</span>的数据规模来说，是不可接受的，</p>
<p>一种优化方向是 逆向思维。</p>
<p>正向思维是枚举所有子数组，计算每个子数组的最小值，那么逆向思维是枚举数组中每个元素
<span class="math inline">\(arr[i]\)</span>作为最小值，然后统计以 <span
class="math inline">\(arr[i]\)</span>为最小值的子数组个数。</p>
<p>首先，枚举数组中每个元素 <span
class="math inline">\(arr[i]\)</span>作为最小值，这个很简单，只需要
<span class="math inline">\(O(n)\)</span>时间，接下来，如何统计以 <span
class="math inline">\(arr[i]\)</span>为最小值的子数组个数，这是解决问题的关键。</p>
<p>枚举元素 <span class="math inline">\(arr[i]\)</span>，计算以 <span
class="math inline">\(arr[i]\)</span>为最小值的子数组个数，我们希望这个子问题能够在
<span class="math inline">\(O(1)\)</span>的时间内解决，或者至少在 <span
class="math inline">\(O（log n）\)</span>时间内解决，因为如果是 <span
class="math inline">\(O(n)\)</span>的话，算法整体时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>，这也是不行的。</p>
<p>那么，问题就变成，如何在 <span
class="math inline">\(O(1)\)</span>时间内统计以 <span
class="math inline">\(arr[i]\)</span>为最小值的子数组个数，<code>在线计算</code>
显然不可能，唯一可行的是，<code>离线</code>
对数组进行预处理，而我们离线预处理信息，能够帮助我们在 <code>O(1)</code>
时间内统计以 <code>arr[i]</code> 为最小值的子数组个数。</p>
<p>计算
<code>以 arr[i] 结尾且 arr[i] 为最小值的子数组个数</code>，我们只需要找到
<code>arr[i]</code> 左侧第一个比 <code>arr[i]</code> 大的数；计算
<code>以 arr[i] 开始且 arr[i] 为最小值的子数组个数</code>，我们只需要找到
<code>arr[i]</code> 右侧第一个比 <code>arr[i]</code>
大的数。从而把问题转化为求解两个 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">496.
下一个更大元素 I</a> 的子问题。这时候，使用 <code>单调栈</code>
就非常显然了，因为求解 <code>下一个更大元素问题</code> 是
<code>单调栈</code> 的 <code>模板题</code> ~</p>
<p>上面我们定义了两个子问题：1. 计算
<code>以 arr[i] 结尾且 arr[i] 为最小值的子数组个数</code>；2. 计算
<code>以 arr[i] 开始且 arr[i] 为最小值的子数组个数</code>。稍加思考后，我们就会发现，这两个子问题的定义是有问题的，因为这样会出现
<code>重复的子数组</code>。如果说一开始的 <code>逆向思维</code>
是解决本题的
<code>第一个难点</code>，那么，<code>如何重新定义上述两个子问题，使得不会统计重复的子数组</code>，则是解决本题的
<code>第二个难点</code>，这个官解已经说了，大家看官解的时候，需要特别留意这一点
~</p>
<p>考虑所有满足以数组<code>arr</code>中的某个元素
<code>arr[i]</code>为最右且最小的元素的子序列个数
<code>C[i]</code>那么题目要求求连续子数组的最小值之和即为 <span
class="math inline">\(\sum^{(n-1)}_{i = 0} arr_i \times
C_i\)</span>，其中数组
<code>arr</code>的长度为<code>n</code>。我们必须假设当前元素为最右边且最小的元素，这样才可以构造出互不相交的子序列。</p>
<p>经过以上思考，我们只需要找到每个元素
<code>arr[i]</code>以该元素为最右且最小的子序列的数目
<code>left[i]</code>，以及以该元素为最左且最小的子序列的数目
<code>right[i]</code>，则以
<code>arr[i]</code>为最小元素的子序列的数目合计为
<code>left[i]*right[i]</code>。为了防止重复计算，我们可以设置
<code>arr[i]</code>左边的元素都必须满足小于等于<code>arr[i]</code>，<code>arr[i]</code>右边的元素必须满足严格小于<code>arr[i]</code>。当然这就变成求最小的下标
<span class="math inline">\(j&lt;=i\)</span>,且连续子序列中的元素
<code>arr[j], arr[j+1], ..., arr[i]</code>都满足大于等于
<code>arr[i]</code>，以及最大的下标 <span
class="math inline">\(k&gt;i\)</span>满足连续子序列
<code>arr[i+1],...,arr[k]</code>都满足严格大于
<code>arr[i]</code>上述即转化为经典的单调栈问题，即求数组中当前元素
<span class="math inline">\(x\)</span>左边第一个小于 <span
class="math inline">\(x\)</span>的元素以及右边第一个小于等于 <span
class="math inline">\(x\)</span>的元素。</p>
<p>具体做法：</p>
<ul>
<li><p>求左边第一个小于<code>arr[i]</code>的元素：从左向右遍历数组，并维护一个单调递增的栈，遍历当前元素<code>arr[i]</code>，如果遇到当前栈顶的元素大于等于<code>arr[i]</code>则将其弹出，直到栈顶元素小于<code>arr[i]</code>，栈顶元素即为左边第一个小于<code>arr[i]</code>的元素<code>arr[j]</code>，此时<code>left[i]=i-j</code>.</p></li>
<li><p>求右边第一个大于等于 arr[i]
的元素：从右向左遍历数组，维护一个单调递增的栈，遍历当前元素
arr[i]，如果遇到当前栈顶的元素大于 arr[i]
则将其弹出，直到栈顶的元素小于等于
arr[i]，栈顶的元素即为右边第一个小于等于 arr[i] 的元素 arr[k]，此时
right[i]=k−i。</p></li>
<li><p>连续子数组 arr[j],arr[j+1],⋯ ,arr[k]的最小元素即为 arr[i]，以
arr[i] 为最小元素的连续子序列的数量为 (i−j)×(k−i)(i - j)。</p></li>
<li></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; monoStack;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!monoStack.<span class="built_in">empty</span>() &amp;&amp; arr[i] &lt;= arr[monoStack.<span class="built_in">back</span>()]) monoStack.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">            left[i] = i - (monoStack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : monoStack.<span class="built_in">back</span>());</span><br><span class="line">            monoStack.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        monoStack.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!monoStack.<span class="built_in">empty</span>() &amp;&amp; arr[i] &lt; arr[monoStack.<span class="built_in">back</span>()]) monoStack.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">            right[i] = (monoStack.<span class="built_in">empty</span>() ? n : monoStack.<span class="built_in">back</span>()) - i;</span><br><span class="line">            monoStack.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ans = (ans + (<span class="type">long</span> <span class="type">long</span>)left[i] * right[i] * arr[i]) % mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="无限集中的最小数字">2336.无限集中的最小数字</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-11-29%2010.54.01.png"
alt="截屏2023-11-29 10.54.01" />
<figcaption aria-hidden="true">截屏2023-11-29 10.54.01</figcaption>
</figure>
<p>利用哈希的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallestInfiniteSet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallestInfiniteSet</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1005</span>; i++) hash[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popSmallest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; <span class="number">1000</span> &amp;&amp; !hash[cnt])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[cnt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addBack</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        hash[num % <span class="number">1005</span>] = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">1005</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SmallestInfiniteSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SmallestInfiniteSet* obj = new SmallestInfiniteSet();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;popSmallest();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addBack(num);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="个位数为k的整数之和">2310.个位数为K的整数之和</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-11-29 13.41.51.png" alt="截屏2023-11-29 13.41.51" style="zoom:50%;" /></p>
<p>枚举+利用同余性质优化至 <span
class="math inline">\(O(1)\)</span>时间复杂度</p>
<p>首先分析一下答案至少之多是多少，答案范围比较小，我们可以尝试枚举答案
<span
class="math inline">\(n\)</span>。把个位数单独拆开看，每个数可以表示为<span
class="math inline">\(10\)</span>的倍数加上 <span
class="math inline">\(k\)</span>的形式。由于这 <span
class="math inline">\(n\)</span>个数都以 <span
class="math inline">\(k\)</span>结尾，那么 <span
class="math inline">\(num-nk\)</span>必须是 <span
class="math inline">\(10\)</span> 的倍数。从小到大枚举 <span
class="math inline">\(n\)</span> ，找到第一个满足 <span
class="math inline">\(num-nk\)</span> 是 $ 10$ 倍数的 <span
class="math inline">\(n\)</span> 。由于 <span
class="math inline">\(n\)</span> 不会超过 <span
class="math inline">\(num\)</span> ，我们至多枚举到 <span
class="math inline">\(num\)</span> 时停止。注意特判 <span
class="math inline">\(num=0\)</span> 的情况，此时返回 <span
class="math inline">\(0\)</span> 。</p>
<p>进一步，由于 <span class="math display">\[
n \cdot k \equiv (n \mod 10) \cdot k (\mod 10)
\]</span></p>
<p>枚举到 <span class="math inline">\(n = 11\)</span> 时， $(num -
nk)mod 10 $ 的结果会和 <span class="math inline">\(n=1\)</span>
时相同，对于更大的 <span class="math inline">\(n\)</span> 也会和 <span
class="math inline">\(n mod 10\)</span> 相同。因此，至多枚举到 <span
class="math inline">\(n=10\)</span> 就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumNumbers</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt;= <span class="number">10</span> &amp;&amp; num - k * n &gt;= <span class="number">0</span>; ++n) <span class="keyword">if</span> ((num - k * n) % <span class="number">10</span> == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="拼车">1094.拼车</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 13.41.48.png" alt="截屏2023-12-02 13.41.48" style="zoom:50%;" /></p>
<p>首先第一想法是记录每个站点的人数，简单的哈希算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sumPassengers = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1005</span>; i++) sum[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1005</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; trips.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; trips[j][<span class="number">2</span>] &amp;&amp; i &gt;= trips[j][<span class="number">1</span>]) sum[i] += trips[j][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1005</span>; i++) <span class="keyword">if</span> (sum[i] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后续看到别人的方法，还有差分的方法，</p>
<p><strong>图解差分 入门 （“前缀和” 到 “差分” 丝滑过度）</strong></p>
<p><strong>差分</strong></p>
<p>从朴素的想法开始：创建一个数组 <code>cnt</code>
，用于存储从某个站点出发时，车上的乘客数量。例如 <span
class="math inline">\(cnt[x]=c\)</span> 含义为在站点 <span
class="math inline">\(x\)</span>
出发时（在该站点的下车和上车均完成），车上乘客数为 <span
class="math inline">\(c\)</span> 个。对于每个 <span
class="math inline">\(trips[i]=(x,a,b)\)</span> ，我们需要对 <span
class="math inline">\([a,b)\)</span> 范围内的 <span
class="math inline">\(cnt[j]\)</span> 进行加 <span
class="math inline">\(c\)</span> 操作。处理完 <code>trips</code>
后，检查所有站点的乘客人数，根据是否满足 <code>capacity</code>
限制返回答案。因此，这是一个关于 <code>区间修改，单点查询</code>
的经典问题，可使用差分求解。</p>
<p>所谓<strong>差分</strong> ，是指
<strong>原数组中每个元素与前一元素之差所形成的数组</strong>
，与之相对应的是“前缀和”
。我们知道，对原数组进行诸位累加（前缀计算操作），所得到的数组为前缀和数组。差分数组，则是对其执行前缀计算后，能够得到原数组的那个数组。</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 14.16.30.png" alt="截屏2023-12-02 14.16.30" style="zoom:50%;" /></p>
<p>前缀和数组的主要作用，是利用 <code>容斥原理</code>
快速求解某段之和。例如要查询原数组 <code>nums</code> 中下标范围
<code>[l,r]</code> 的和，可通过 <code>sum[r]-sum[l-1]</code>
快速求解。</p>
<p>差分数组的主要作用，是帮助快速修改某段区间。</p>
<p>由于差分数组执行 <code>前缀计算</code>
后得到的是原数组，因此在差分数组上修改某个值，会对原数组某段后缀产生相同的影响。</p>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 14.20.56.png" alt="截屏2023-12-02 14.20.56" style="zoom:50%;" /></p>
<p>因此，<strong>当我们想要对原数组的 <code>[l,r]</code>
进行整体修改时，只需要对差分数组的 <code>l</code> 和 <code>r+1</code>
位置执行相应操作即可。</strong></p>
<p>举个例子，假设想对原数组 <code>nums</code> 的 <code>[l,r]</code>
进行整体“加一”操作，那么可转换为对差分数组 <code>c[l]</code>
的加一操作（等价对原数组的 <code>[l,n-1]</code>
进行加一），以及对差分数组 <code>c[r+1]</code>
的减一操作（等价于对原数组的 <code>[r+1,n-1]</code> 进行减一， 最终只有
<code>[l,r]</code> 有加一效果）。</p>
<p>至此，我们完成了对差分的基本学习：<strong>将原数组的区间修改等价为差分数组的特定位置修改</strong>。</p>
<p>回到本题，起始先用 <code>nums</code> 来作为差分数组，对于 <span
class="math inline">\(trips[i]=(c,a,b)\)</span> ，有 <span
class="math inline">\(c\)</span> 个乘客在 <span
class="math inline">\(a\)</span> 点上车，在 <span
class="math inline">\(b\)</span> 点下车，因此对 <code>[a,b)</code>
进行整体加 <span class="math inline">\(c\)</span> 操作，对应差分数组操作
<code>nums[a] += c; nums[b] -= c</code>。</p>
<p>处理完 <span class="math inline">\(trips\)</span> 后，对差分数组
<code>nums</code> 进行前缀计算 （可直接复用
<code>nums</code>，进行原地计算），便可得到各个站点的乘客数量，与
<code>capacity</code> 比较答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">1010</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; t :trips)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c = t[<span class="number">0</span>], a = t[<span class="number">1</span>], b = t[<span class="number">2</span>];</span><br><span class="line">            nums[a + <span class="number">1</span>] += c;</span><br><span class="line">            nums[b + <span class="number">1</span>] -= c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="可获得的最大点数">1423.可获得的最大点数</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-03%2012.32.08.png"
alt="截屏2023-12-03 12.32.08" />
<figcaption aria-hidden="true">截屏2023-12-03 12.32.08</figcaption>
</figure>
<p><strong>滑动窗口</strong></p>
<p>从两边选卡片，选 <code>k</code> 张，卡片总数量为 <code>n</code>
张，即有 <code>n-k</code> 张不被选择。所有卡片总和 <code>sum</code>
固定，要使选择的 <code>k</code> 张的总和最大，反过来就是要让不被选择的
<code>n-k</code> 张总和最小。原问题等价为
：<strong>从<code>cardPoints</code> 中找长度为 <code>n-k</code>
的连续段，使其总和最小</strong>。</p>
<p>具体来说，用变量 <code>sum</code> 代指 <code>cardPoints</code> 总和，
<code>cur</code>代表长度固定为 <code>n-k</code>的当前窗口总和，
<code>minv</code> 代表所有长度为 <code>n-k</code>
的窗口总和最小的值。</p>
<p>起始先将滑动窗口压满，取得第一个滑动窗口的目标值 <code>cur</code>
（同时更新为 <code>minv</code>） ，随后往后继续处理
<code>cardPoints</code>
，每往前滑动一位，需要删除一个和添加一个元素，并不断更新
<code>minv</code> ，最终 <code>sum-minv</code>即是答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cardPoints, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cardPoints.<span class="built_in">size</span>(); i++) sum += cardPoints[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cardPoints.<span class="built_in">size</span>() - k; i++) cur += cardPoints[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minv = cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cardPoints.<span class="built_in">size</span>() - k; i &lt; cardPoints.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur + cardPoints[i] - cardPoints[i - cardPoints.<span class="built_in">size</span>() + k];</span><br><span class="line">            minv = <span class="built_in">min</span>(minv, cur); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum - minv;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="需要添加的硬币的最小数量">100153.需要添加的硬币的最小数量</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-03%2013.22.21.png"
alt="截屏2023-12-03 13.22.21" />
<figcaption aria-hidden="true">截屏2023-12-03 13.22.21</figcaption>
</figure>
<p><strong>用归纳法思考</strong></p>
<p>为了方便描述，把0也算作可以得到的数。假设现在得到了 <span
class="math inline">\([1,s-1]\)</span>
内的所有整数，如果此时新发现了一个整数 <span
class="math inline">\(x\)</span> ,那么把 <span
class="math inline">\(x\)</span> 加到已得到的数字中，就得到了 <span
class="math inline">\([x,s + x-1]\)</span> 内的所有整数。</p>
<p>分类讨论：</p>
<ol type="1">
<li>如果 <span class="math inline">\(x\leq s\)</span>
，那么合并这两个区间，我们可以得到 <span
class="math inline">\([0,s+x-1]\)</span> 内的所有整数。</li>
<li>如果 <span class="math inline">\(x&gt;s\)</span>
，这意味着我们无法得到 <span class="math inline">\(s\)</span>
，那么就一定要把 <span class="math inline">\(s\)</span>
加到数组中，这样就可以得到 <span class="math inline">\([s,2s-1]\)</span>
内的所有整数，再与 <span class="math inline">\([0,s-1]\)</span>
合并，可以得到 <span class="math inline">\([0,2s-1]\)</span>
内的所有整数。</li>
</ol>
<p>把 <span class="math inline">\(coins\)</span> 排序，从小到大考虑
<span class="math inline">\(x=coins[i]\)</span>
。按照上述分类讨论来看是否要添加数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumAddedCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; coins.<span class="built_in">size</span>() &amp;&amp; coins[i] &lt;= s)</span><br><span class="line">            &#123;</span><br><span class="line">                s += coins[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s *= <span class="number">2</span>;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="统计完全子字符串">100145.统计完全子字符串</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-03 13.37.33.png" alt="截屏2023-12-03 13.37.33" style="zoom:50%;" /></p>
<p><strong>相邻字母相差至多为2</strong> 这个约束把 <code>word</code>
划分成了多个子串 <code>s</code>
每个子串分别处理。可以用<strong>分组循环</strong>找到每个子串
<code>s</code>。</p>
<blockquote>
<p>分组循环</p>
<p>指的是将整个数组或者字符串分成很多片段，这些片段的判断处理逻辑是一样的。分组循环需要使用同向双指针，但是与滑动窗口不同的是，滑动窗口是收集左右区间内连续数组或者字符串，当不满足收集要求时移动右指针，而当满足后移动左指针，此时左指针移动到原来左指针的下一位，而分组循环是左指针移动到右指针下一位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版 l,r 分别表示左右指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 每一次求新区间则重新赋值l</span></span><br><span class="line">	l = r；</span><br><span class="line"> <span class="comment">// r 表示最长连续区间最后一个</span></span><br><span class="line"> <span class="keyword">while</span> (r &lt; n - <span class="number">1</span> &amp;&amp; s[r] == s[r + <span class="number">1</span>])</span><br><span class="line"> &#123;</span><br><span class="line">   	r ++;</span><br><span class="line"> &#125;</span><br><span class="line">	<span class="comment">// 求完区间后收集结果</span></span><br><span class="line">	res = <span class="built_in">max</span>(r - l + <span class="number">1</span>, res);</span><br><span class="line">	<span class="comment">// 并移动r到下一个</span></span><br><span class="line">	r ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于每个子串，由于每个字符恰好出现 <code>k</code> 次，我们可以枚举有
<code>m</code> 种字符，这样问题就变成了：</p>
<p>长度固定为 <code>m·k</code> 的滑动窗口，判断每种字符是否都出现了恰好
<code>k</code>次。</p>
<h4 id="从二叉搜索树到更大和树">1038.从二叉搜索树到更大和树</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04%2020.34.57.png"
alt="截屏2023-12-04 20.34.57" />
<figcaption aria-hidden="true">截屏2023-12-04 20.34.57</figcaption>
</figure>
<p>打卡题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bst</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">bst</span>(root-&gt;right);</span><br><span class="line">        cnt += root-&gt;val;</span><br><span class="line">        root-&gt;val = cnt;</span><br><span class="line">        <span class="built_in">bst</span>(root-&gt;left);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bst</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="有序数组中差绝对值之和">1685.有序数组中差绝对值之和</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04%2020.37.32.png"
alt="截屏2023-12-04 20.37.32" />
<figcaption aria-hidden="true">截屏2023-12-04 20.37.32</figcaption>
</figure>
<p>利用前缀和解决，首先计算出前缀和，然后遍历<code>nums</code>，以当前元素<code>nums[i]</code>
为分界点， <code>i</code>前边的元素一定是比
<code>nums[i]</code>小，<code>i</code>后边的元素一定比
<code>nums[i]</code>大。这时，我们把这个问题放在二维空间看。</p>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04%2020.46.32.png"
alt="截屏2023-12-04 20.46.32" />
<figcaption aria-hidden="true">截屏2023-12-04 20.46.32</figcaption>
</figure>
<p>比如在 <code>i=1</code>的位置在<code>nums[1]</code>左边的比
<code>nums[1]</code> 小，此时<code>sum(|nums[i]-nums[j]|)</code>
为左边的橙色面积。可以写为 <code>left=nums[i] * i - f[i]</code>
。同理，右边部分为 右边橙色面积 ，可以写为
<code>f[n]-f[i] - (n - i) * nums[i]</code>
。这样，就可以把<code>result[i]</code> 的求解过程等价为
<code>nums[i]</code> 左右两边的面积。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSumAbsoluteDifferences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> f[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[i + <span class="number">1</span>] = f[i] + nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> target = nums[i];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> left = target * i - f[i];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> right = f[n] - f[i] - (n - i) * target;</span><br><span class="line">            res[i] = left + right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="到达首都的最少油耗">2477.到达首都的最少油耗</h4>
<p><img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-05%2010.27.40.png"
alt="截屏2023-12-05 10.27.40" /><strong>贪心+深度优先搜索 </strong></p>
<p>题目等价于给出了一棵以节点<span class="math inline">\(0\)</span>
为根结点的树，并且初始树上的每一个节点上都有一个人，现在所有人都需要通过
<code>车子</code> 向节点 <span class="math inline">\(0\)</span>
移动。</p>
<p>对于某一节点 <span class="math inline">\(x\)</span> ，<span
class="math inline">\(x\neq 0\)</span> ，其父节点为 <span
class="math inline">\(y\)</span> 。因为以节点 <span
class="math inline">\(x\)</span> 为根结点的子树上的人都需要通过边 <span
class="math inline">\(x\to y\)</span> 向节点 <span
class="math inline">\(0\)</span> 移动，所以为了使这条边上的
<code>车子</code> 利用率最高，我们贪心的让 <span
class="math inline">\(x\)</span> 的全部子节点上的人到了节点 <span
class="math inline">\(x\)</span> 后再一起坐车向上移动，我们不妨设以节点
<span class="math inline">\(x\)</span> 为根节点的子树大小为 <span
class="math inline">\(cnt_x\)</span> 那么我们至少需要
<code>车子</code>的数量为 <span class="math inline">\(\lceil
\frac{cnt_x}{seats} \rceil\)</span> ，其中 <span
class="math inline">\(seatx\)</span> 为一辆车的给定座位数。</p>
<p>那么，我们可以通过从根节点 <span class="math inline">\(0\)</span>
往下进行 <code>深度优先搜索</code> ，每一条边上
<code>车子🚗</code>的数目即为该条边上汽油的开销，统计全部边上汽油的开销即为最终答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumFuelCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads, <span class="type">int</span> seats)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = roads.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : roads)</span><br><span class="line">        &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            g[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> cur, <span class="type">int</span> fa) -&gt; <span class="type">int</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> peopleSum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ne : g[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ne != fa) <span class="comment">// 判断是否是同一棵子树</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> peopleCnt = <span class="built_in">dfs</span>(ne, cur);</span><br><span class="line">                    peopleSum += peopleCnt;</span><br><span class="line">                    res += (peopleCnt + seats - <span class="number">1</span>) / seats;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> peopleSum;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之前卡住的原因主要在，不知道怎么确定一条支路走到头。这里了很明显</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dfs(0, -1)</span></span><br><span class="line"><span class="comment">dfs(1, 0)</span></span><br><span class="line"><span class="comment">dfs(3, 1)</span></span><br><span class="line"><span class="comment">dfs(2, 3)</span></span><br><span class="line"><span class="comment">dfs(3, 3)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4
id="统计网格图中没有被保卫的格子数">2257.统计网格图中没有被保卫的格子数</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-06%2009.59.40.png"
alt="截屏2023-12-06 09.59.40" />
<figcaption aria-hidden="true">截屏2023-12-06 09.59.40</figcaption>
</figure>
<p><strong>广度优先搜索+存储每个格子的状态</strong></p>
<p>为了方便操作，我们可以用二维数组 <code>grid</code>
来表示网格图的状态。其中，警卫对应的状态值为<span
class="math inline">\(-1\)</span> ，墙对应的状态值为 <span
class="math inline">\(-2\)</span> ，未被保卫的格子对应的状态值为 <span
class="math inline">\(0\)</span>
，被保卫的格子对应的状态值为正整数。二维数组的初始值均为 <span
class="math inline">\(0\)</span> ，随后我们遍历 <code>guards</code> 和
<code>walls</code> 数组对应更新网格图。</p>
<p>在恢复了网格图后，我们可以使用广度优先搜索维护每个格子的状态。由于视线是向特定方向的，因此在广度优先搜索的过程中，除了要维护格子的横纵坐标，还要维护当前的视线方向。我们用
<span class="math inline">\((i,j,k)\)</span>
来表示广度优先搜索的状态，其中 <span
class="math inline">\((i,j)\)</span> 代表当前点的横纵坐标， <span
class="math inline">\(k\)</span> 为 <span
class="math inline">\([0,3]\)</span>
闭区间内整数，分别代表右、上、左、下的视线方向。同样的，为了防止每个非警卫或者墙的点被重复或遗漏，我们用
<span class="math inline">\(4\)</span>
个二进制位组成的正整数来表示该格子的状态，其中从低到高的第 <span
class="math inline">\(k\)</span> 位为 <span
class="math inline">\(1\)</span> 代表有指向第 <span
class="math inline">\(k\)</span>
个方向的视线经过该点，反之则代表没有。</p>
<p>我们用队列 <span class="math inline">\(q\)</span>
来进行广度优先搜索。首先，对于每个警卫点 <span
class="math inline">\((i,j)\)</span>
，由于警卫可以看到四个方向，因此我们需要将 <span
class="math inline">\(k\)</span> 为 <span
class="math inline">\([0,3]\)</span> 闭区间内对应的四种状态 <span
class="math inline">\((i,j,k)\)</span> 全部加进队列。</p>
<p>当遍历到 <span class="math inline">\((x,y,k)\)</span>
时，我们首先计算沿着该视线方向的下一个坐标 <span
class="math inline">\((n_x,n_y)\)</span>
，如果该坐标不合法或为墙或警卫，则我们直接跳过该坐标；对于余下的情况，我们需要检查该坐标对应状态
<span class="math inline">\(grid[i][j]\)</span> 中从低到高的第 <span
class="math inline">\(k\)</span> 位的数值。此时有两种情况：</p>
<ul>
<li>第 <span class="math inline">\(k\)</span> 位为<span
class="math inline">\(1\)</span> ，则说明该坐标及视线方向对应的状态
<span class="math inline">\((n_x,n_y,k)\)</span>
已被遍历过，我们直接跳过即可；</li>
<li>第 <span class="math inline">\(k\)</span> 位为 <span
class="math inline">\(0\)</span> ，则说明该坐标及视线方向对应的状态
<span class="math inline">\(n_x,n_y,k\)</span>
未被遍历过，我们需要将该位置为 <span class="math inline">\(1\)</span>
，并将该状态加入队列 <span class="math inline">\(q\)</span>
的尾部。</li>
</ul>
<p>最终，当广度优先搜索完成时，一个格子未被保卫当且仅当 <span
class="math inline">\(grid\)</span> 中的对应状态值为 <span
class="math inline">\(0\)</span> 。我们只需要遍历 <span
class="math inline">\(grid\)</span> ，维护数值为 <span
class="math inline">\(0\)</span> 的格子数量，并返回即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countUnguarded</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; guards, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; walls)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n));  <span class="comment">// 网格状态数组</span></span><br><span class="line">        queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;   <span class="comment">// 广度优先搜索队列</span></span><br><span class="line">        <span class="comment">// 每个方向的单位向量</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dx = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dy = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; guard : guards)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[guard[<span class="number">0</span>]][guard[<span class="number">1</span>]] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将四个方向视线对应的状态均添加进搜索队列中</span></span><br><span class="line">                q.<span class="built_in">emplace</span>(guard[<span class="number">0</span>], guard[<span class="number">1</span>], k);</span><br><span class="line">                <span class="comment">// 比如，(0, 0) 这时候加入的就是 (0, 0, 0), (0, 0, 1), (0, 0 ,2), (0, 0, 3)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; wall : walls) grid[wall[<span class="number">0</span>]][wall[<span class="number">1</span>]] = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y, k] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> nx = x + dx[k];</span><br><span class="line">            <span class="type">int</span> ny = y + dy[k];</span><br><span class="line">            <span class="comment">// 太优雅了， k = 0 时， 代表 (nx, ny) -&gt; (nx + 1, ny + 0) 这时候对应向下的视线</span></span><br><span class="line">            <span class="comment">//  k = 1 时，(nx, ny) -&gt; (nx + 0, ny + 1) 右</span></span><br><span class="line">            <span class="comment">// k = 2, (nx, ny) -&gt; (nx - 1, ny + 0) 上</span></span><br><span class="line">            <span class="comment">// k = 3, (nx, ny) -&gt; (nx + 0, ny - 1) 左</span></span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 沿着视线方向的下一个坐标合法，且不为警卫或墙</span></span><br><span class="line">                <span class="keyword">if</span> ((grid[nx][ny] &amp; (<span class="number">1</span> &lt;&lt; k)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 对应状态未遍历过</span></span><br><span class="line">                    grid[nx][ny] |= (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">                    q.<span class="built_in">emplace</span>(nx, ny, k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) res ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最小化旅行的价格总和">2646.最小化旅行的价格总和</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-06%2010.44.48.png"
alt="截屏2023-12-06 10.44.48" />
<figcaption aria-hidden="true">截屏2023-12-06 10.44.48</figcaption>
</figure>
<p><strong>暴力DFS每条路径</strong></p>
<p>对每个 <code>trips[i]</code> 都 DFS 一次这棵树，在 DFS 的过程中，把
<code>start</code> 到 <code>end</code> 的路径上的每个点 <span
class="math inline">\(x\)</span> 的经过次数 <span
class="math inline">\(cnt[x]\)</span> 都加一。</p>
<p>既然知道了每个点会被经过多少次，把 <code>price[i]</code> 更新为
<code>price[i]·cnt[i]</code> ，问题就转换为计算减半后的
<code>price[i]</code> 之和的最小值。注意 <code>cnt[i]=0</code> 时
<code>price[0]</code> 会被更新为 <span class="math inline">\(0\)</span>
，我们无需考虑没有经过的节点。</p>
<p>对于转换后的问题，我们随便选一个节点出发 DFS 。在 DFS
的过程中，对于节点 <span class="math inline">\(x\)</span> 及其儿子 <span
class="math inline">\(y\)</span> ，分类讨论：</p>
<ul>
<li>如果 <code>price[x]</code> 不变，那么 <code>price[y]</code>
可以减半，也可以不变，取这两种情况的最小值；</li>
<li>如果<code>price[x]</code> 减半，那么
<code>price[y]</code>只能不变。</li>
</ul>
<p>因此子树 <span class="math inline">\(x\)</span> 需要返回两个值</p>
<ul>
<li><code>price[x]</code> 不变时的子树 <span
class="math inline">\(x\)</span> 的最小价值总和；</li>
<li><code>price[x]</code> 减半时的子树 <span
class="math inline">\(x\)</span> 的最小价值总和；</li>
</ul>
<p>答案就是根结点不变/减半的最小值。</p>
<p>以 <code>start</code> 为树根 DFS ，找到 <code>end</code> 时，
<code>end</code> 及其祖先节点就恰好组成了从 <code>start</code> 到
<code>end</code> 的路径。</p>
<h4 id="最小路径和">64.最小路径和</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-07%2019.45.13.png"
alt="截屏2023-12-07 19.45.13" />
<figcaption aria-hidden="true">截屏2023-12-07 19.45.13</figcaption>
</figure>
<p>此题是典型的动态规划题目。</p>
<ol type="1">
<li>状态定义 设 <span class="math inline">\(dp\)</span> 为大小 <span
class="math inline">\(m\times n\)</span> 矩阵，其中 <span
class="math inline">\(dp[i][j]\)</span> 的值代表直到走到 <span
class="math inline">\((i, j)\)</span> 的最小路径和</li>
<li>转移方程 题目要求，只能向右或向下走，换句话说，当前单元格 <span
class="math inline">\((i,j)\)</span> 只能从左边的单元格 <span
class="math inline">\((i-1,j)\)</span> 或者上边的单元格 <span
class="math inline">\((i, j -1)\)</span>
走到，因此只需要考虑矩阵的左边界和上边界。</li>
</ol>
<p>走到当前单元格 <span class="math inline">\((i,j)\)</span>
的最小路径和 = “从左方单元格 <span
class="math inline">\((i-1,j)\)</span> 与从上方单元格 <span
class="math inline">\((i,j-1)\)</span> 走来的
<strong>两个最小路径和中较小的</strong> ”+当前单元格值 <span
class="math inline">\(grid[i][j]\)</span> 。具体分为以下 <span
class="math inline">\(4\)</span> 种情况：</p>
<ol type="1">
<li>当左边和上边都不是矩阵边界时：即当 <span class="math inline">\(i\neq
0,j\neq 0\)</span> 时， <span class="math inline">\(dp[i][j] =
min(dp[i-1][j], dp[i][j-1])+grid[i][j]\)</span></li>
<li>当只有左边是矩阵边界时：只能从上边来，即当 <span
class="math inline">\(i=0,j\neq 0\)</span> 时，<span
class="math inline">\(dp[i][j] = dp[i][j-1] + grid[i][j]\)</span></li>
<li>当只有上边是矩阵边界时：只能从左边来，即当 <span
class="math inline">\(i\neq0 j = 0\)</span> 时， <span
class="math inline">\(dp[i][j]=dp[i-1][j] + grid[i][j]\)</span></li>
<li>当左边和上边都是矩阵边界时：即当 <span
class="math inline">\(i=0,j=0\)</span> 时，<span
class="math inline">\(dp[i][j]=grid[i][j]\)</span></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) grid[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) grid[i][j] = <span class="built_in">min</span>(grid[i<span class="number">-1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="重新规划路线">1466.重新规划路线</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-07%2020.06.21.png"
alt="截屏2023-12-07 20.06.21" />
<figcaption aria-hidden="true">截屏2023-12-07 20.06.21</figcaption>
</figure>
<p>题目给定一张由 <code>n</code> 个点（使用 <code>0</code> 到
<code>n-1</code> 编号），<code>n-1</code>
条边构成的有向图，如果忽略变得方向，就变成了一棵树。我们需要改变某些边的方向使得每个点都可以访问到
<code>0</code> 号点。</p>
<p>如果忽略边的方向，将每条有向边以及其反向边加入到图中，那么从任意一点出发都能到达
<code>0</code>
号点。路径上可能会经过反向边，我们需要变更与之对应的原边的方向。需要变更的次数即为答案。</p>
<p>以每个点为起点进行搜索的代价会很大，因此我们考虑从 <code>0</code>
出发去遍历其他点（可以使用深度优先搜索或者广度优先搜索，本题解使用深度优先搜索），原来我们需要统计反向边的数量，现在需要统计原方向边的数量。</p>
<p>具体而言，我们使用<code>1</code>标记原方向的边，使用 <code>0</code>
标记反向边。然后从 <code>0</code>
号点开始遍历，访问到某个新的点时，所经过的边被 <code>1</code>
标记，就令答案加
<code>1</code>。最终统计得到的答案就是我们需要变更方向的最小路线数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> parent, vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里 parent 作用是保存了上一个节点</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里意思是，如果当前节点的下一个节点是上一个节点，那么说明到头了</span></span><br><span class="line">            <span class="comment">// 直接跳转下一个节点</span></span><br><span class="line">            <span class="comment">// 比如到2了，2的下一个节点到3且3是2的前一个节点，那么直接跳转到 (0, 4, 0) 此时 parent = x = 3继续dfs</span></span><br><span class="line">            <span class="keyword">if</span> (edge.first == parent) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            res += edge.second + <span class="built_in">dfs</span>(edge.first, x, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minReorder</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">e</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : connections)</span><br><span class="line">        &#123;</span><br><span class="line">            e[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(edge[<span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line">            e[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(edge[<span class="number">0</span>], <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="下一个更大的数值平衡数">2048.下一个更大的数值平衡数</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2012.46.46.png"
alt="截屏2023-12-09 12.46.46" />
<figcaption aria-hidden="true">截屏2023-12-09 12.46.46</figcaption>
</figure>
<p>我首先想到的是，直接对每个数字进行暴力判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgeBeautiful</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> n_ = n;</span><br><span class="line">        <span class="keyword">while</span> (n_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = n_ % <span class="number">10</span>;</span><br><span class="line">            mp[tmp] = <span class="number">0</span>;</span><br><span class="line">            n_ /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = n % <span class="number">10</span>;</span><br><span class="line">            mp[tmp] ++;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; mp_ : mp) <span class="keyword">if</span> (mp_.first != mp_.second) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextBeautifulNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">while</span> (n &lt;= <span class="number">666666</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judgeBeautiful</span>(n))</span><br><span class="line">            &#123;</span><br><span class="line">                res = n;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;= <span class="number">666666</span> ? res : <span class="number">1224444</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同路径">62.不同路径</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2013.23.57.png"
alt="截屏2023-12-09 13.23.57" />
<figcaption aria-hidden="true">截屏2023-12-09 13.23.57</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="不同路径-1">63.不同路径</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2014.09.07.png"
alt="截屏2023-12-09 14.09.07" />
<figcaption aria-hidden="true">截屏2023-12-09 14.09.07</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="三角形最小路径和">120.三角形最小路径和</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2014.48.17.png"
alt="截屏2023-12-09 14.48.17" />
<figcaption aria-hidden="true">截屏2023-12-09 14.48.17</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (triangle.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> m = triangle.<span class="built_in">size</span>(), n = triangle[m - <span class="number">1</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + triangle[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j == triangle[i].<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; i != <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; j != triangle[i].<span class="built_in">size</span>() - <span class="number">1</span>) dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> minVal = <span class="number">1e5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (minVal &gt; dp[m - <span class="number">1</span>][i]) minVal = dp[m - <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">return</span> minVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="下降路径最小和">931.下降路径最小和</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) dp[i][j] = matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) + matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == (n - <span class="number">1</span>)) dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span> &amp;&amp; j != (n - <span class="number">1</span>)) </span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j + <span class="number">1</span>]&#125;) + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> minVal = <span class="number">1e5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (minVal &gt; dp[n - <span class="number">1</span>][i]) minVal = dp[n - <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">return</span> minVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4
id="最多k个重复元素的最长子数组">100147.最多K个重复元素的最长子数组</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-10%2010.30.05.png"
alt="截屏2023-12-10 10.30.05" />
<figcaption aria-hidden="true">截屏2023-12-10 10.30.05</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarrayLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[nums[i]] ++;</span><br><span class="line">            <span class="keyword">while</span> (cnt[nums[i]] &gt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[nums[j++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最大正方形">221.最大正方形</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 13.40.25.png" alt="截屏2023-12-10 13.40.25" style="zoom:50%;" /></p>
<p>我们用 <code>dp[i][j</code>] 表示 以 <code>[i][j]</code>
为右下角，且只包含 <code>1</code>
的正方形的边长最大值。如果我们能计算出所有 <code>dp[i][j]</code>
的值，那么其中的最大值即为矩阵中只包含 <code>1</code>
的正方形的边长最大值，其平方即为最大正方形的面积。</p>
<p>那么如何计算 <code>dp</code> 中的每个元素值？对于每个位置
<code>[i][j]</code> ，检查在矩阵中该位置的值“</p>
<ul>
<li><p>如果该位置的值是 <code>0</code> ，则 <code>dp[i][j]=0</code>
因为当前位置不可能在由 <code>1</code> 组成的正方形中。</p></li>
<li><p>如果该位置的值是 <code>1</code> ，则 <code>dp[i][j]</code>
的值由其上方、左方和左上方的三个相邻位置的 <code>dp</code>
值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加<code>1</code>
状态转移方程： <span class="math display">\[
dp(i,j)=min(d(i-1,j),dp(i-1,j-1),dp(i,j-1)) + 1
\]</span> 此外，还需要考虑边界条件。如果 <code>i</code> 和
<code>j</code> 中至少有一个为 <code>0</code>
则以位置为右下角的最大正方形的边长就只能是 <code>1</code> ，因此
<code>dp[i][j]=1</code></p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; columns; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4
id="统计最大元素出现至少k次的子数组-1">100137.统计最大元素出现至少K次的子数组</h4>
<p><img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 14.15.07.png" alt="截屏2023-12-10 14.15.07" style="zoom:50%;" /></p>
<p><strong>同向双指针+滑动窗口</strong></p>
<p>在子数组子串问题中，经常会用到双指针这一技巧 。举个例子：给定一个含有
<code>n</code> 个正整数的数组和一个正整数 <code>target</code>
。找出该数组中满足其和 <code>&gt;=target</code>的长度最小的
<strong>连续子数组</strong> <code>nums</code>
，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> .</p>
<p>例如209题目。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minLen = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; right &lt; nums.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> ((sum - nums[left]) &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target) minLen = <span class="built_in">min</span>(minLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt;= nums.<span class="built_in">size</span>() ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再比如<strong>713.乘积小于K的子数组</strong> 给定一个整数数组
<code>nums</code> 和一个整数 <code>k</code>
，返回子数组内所有元素的乘积严格小于 <code>k</code>
的连续子数组的数目。万变不离其宗，元素都是正数，方法和上一题一样，对于
<code>[10, 5, 2, 6]</code> 比如枚举到 <code>2</code> 的时候，就把
<code>2</code> 接到上一次计算的结果后面。那如果元素的乘积
<code>&gt;=k</code> 就把左端点右移，缩小子数组的长度，直到乘积小于
<code>k</code>
为止。那么问题的关键，也是与上题不同的点，<strong>子数组的数目要怎么算</strong>
这里，我们枚举到 <code>2</code> ，需要算的就是以 <code>2</code>
为右端点的满足要求的子数组的个数。<code>[5, 2]</code>算是一个，
<code>[2]</code>
单独算一个。用代码来计算，就需要推导出来一个公式，假设此时左端点为
<code>l</code>，右端点为<code>r</code> 。那么我们现在需要计算的就是以
<code>r</code> 为右端点的子数组的个数。注意右端点是固定的，如果从
<code>l</code> 到 <code>r</code> 的这一段的乘积是小于 <code>k</code>
的。那么从 <code>l+1</code> 到 <code>r</code> 的这一段也是小于
<code>k</code> 的。一直到 <code>[r, r]</code>
这些子数组都是满足要求的。那么子数组的个数其实就是从 <code>l</code> 到
<code>r</code> 的元素个数。那么就是 <code>r-l+1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxNums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; right &lt; nums.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum  &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                sum /= nums[left];</span><br><span class="line">                left ++;  </span><br><span class="line">            &#125;</span><br><span class="line">            maxNums += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着还有 <strong>3.无重复字符的最长子串</strong> 给定一个字符串
<code>s</code> ,找出其中不含重复字符的 <strong>最长子串</strong>
的长度。由于如果出现的重复字符的唯一情况就是刚刚加入的字符与之前的字符发生重复，所以我们只需要使用哈希的方法，统计一下刚加入的字符是否出现重复即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (right; right &lt; s.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[s[right]] ++;</span><br><span class="line">            <span class="keyword">while</span> (mp[s[right]] &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[s[left]] --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到这个题目，首先找到数组中的最大数，设 <span
class="math inline">\(mx=max(nums)\)</span> 右端点 <span
class="math inline">\(right\)</span> 从左到右遍历 <span
class="math inline">\(nums\)</span> 。遍历到元素<span
class="math inline">\(x=nums[right]\)</span> 如果 <span
class="math inline">\(x=mx\)</span> ，就把计数器 <span
class="math inline">\(cntMx\)</span> 加一。如果此时 <span
class="math inline">\(cntMx = k\)</span> 则不断右移左指针 <span
class="math inline">\(left\)</span> ，直到窗内的 <span
class="math inline">\(mx\)</span> 的出现次数 <strong>小于</strong> <span
class="math inline">\(k\)</span> 为止。此时，对于右端点为 <span
class="math inline">\(right\)</span> 且左端点小于 <span
class="math inline">\(left\)</span> 的子数组，<span
class="math inline">\(mx\)</span> 的出现次数都至少为 <span
class="math inline">\(k\)</span> ，把答案增加 <span
class="math inline">\(left\)</span> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) maxVal = <span class="built_in">max</span>(maxVal, nums[i]);</span><br><span class="line">        <span class="type">int</span> maxValCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (right; right &lt; nums.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == maxVal) maxValCnt ++;</span><br><span class="line">            <span class="keyword">while</span> (maxValCnt == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == maxVal) maxValCnt --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最小体力消耗路径">1631.最小体力消耗路径</h4>
<figure>
<img
src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-11%2012.28.59.png"
alt="截屏2023-12-11 12.28.59" />
<figcaption aria-hidden="true">截屏2023-12-11 12.28.59</figcaption>
</figure>
<p>看到这个题目，最小路径，第一反应是DP，但是这里是往
<strong>上，下，左，右</strong>
四个方向移动，转念一想，这已经是DP解决不了的问题了。因为，你无法确定都有哪些位置能够到达你当前的位置，也就是无法推出状态转移方程。</p>
<p>事实上，当题目允许往任意方向移动时，考察的往往就不是DP了，而是图论。从本质上说，DP问题是一类特殊的图论问题。那为什么有一些DP题目简单修改条件后，就只能彻底转化为图论问题来解决呢？这是因为修改条件后，导致我们DP状态展开不再是一个拓扑序列。换句话说，DP题虽然都属于图论范畴。但对于不是拓扑图的图论问题，我们无法使用DP求解。而此类看似DP，实则图论的问题，通常是最小生成树或者最短路问题。</p>
<p><strong>Kruskal</strong></p>
<p><strong>当一道题我们决定往图论方向思考时，我们的重点应该放在如何建图上。</strong>
因为解决特定的图论问题时（最短路/最小生成树/二分图匹配），我们都是使用特定的算法。由于使用到的算法都有固定的模版，因此编码难度很低，而如何建图的思维难度则很高。对于本题，我们可以按照如下分析进行建图：</p>
<p>因为在任意格子可以往任意方向移动，所以相邻的格子之间存在一条无向边。题目要求我们求的就是从起点到终点，经过路径中的最小权重的最大值是多少。我们可以先遍历所有的格子，将所有的边加入集合。存储的格式为数组
<code>[a,b,w]</code> ，代表编号为 <code>a</code> 的点和编号为
<code>b</code> 的点之间的权重为 <code>w</code> 。按照题意，
<code>w</code> 为两者的高度差的绝对值。对集合进行排序，按照
<code>w</code> 进行从小到大排序
(Kruskal)当我们有了排好序的候选边集合之后，我们可以对边进行从前往后处理，每次加入一条边之后，使用并查集来查询起点和终点是否连通。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; size;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 当前连通分量数目</span></span><br><span class="line">    <span class="type">int</span> setCount;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> _n): <span class="built_in">n</span>(_n), <span class="built_in">setCount</span>(_n), <span class="built_in">parent</span>(_n), <span class="built_in">size</span>(_n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findset</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : parent[x] = <span class="built_in">findset</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findset</span>(x);</span><br><span class="line">        y = <span class="built_in">findset</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --setCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findset</span>(x);</span><br><span class="line">        y = <span class="built_in">findset</span>(y);</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> id = i * n + j;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    edges.<span class="built_in">emplace_back</span>(id - n, id, <span class="built_in">abs</span>(heights[i][j] - heights[i - <span class="number">1</span>][j]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    edges.<span class="built_in">emplace_back</span>(id - <span class="number">1</span>, id, <span class="built_in">abs</span>(heights[i][j] - heights[i][j - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; e1, <span class="type">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp;&amp; [x1, y1, v1] = e1;</span><br><span class="line">            <span class="keyword">auto</span>&amp;&amp; [x2, y2, v2] = e2;</span><br><span class="line">            <span class="keyword">return</span> v1 &lt; v2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(m * n)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> [x, y, v]: edges) &#123;</span><br><span class="line">            uf.<span class="built_in">unite</span>(x, y);</span><br><span class="line">            <span class="keyword">if</span> (uf.<span class="built_in">connected</span>(<span class="number">0</span>, m * n - <span class="number">1</span>)) &#123;</span><br><span class="line">                ans = v;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="反转二叉树的奇数层">2415.反转二叉树的奇数层</h4>
<p>方法一：广度优先搜索</p>
<p>我们直接按照层次遍历该二叉树，然后将奇数层中的值进行反转。二叉树按照层次遍历是一个基本的广度优先搜索问题，在遍历的同时，对每一层进行标记，如果当前该层为奇数层，则将该层中的节点用数组保存起来，然后将该层所有节点的值进行反转即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reverseOddLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="type">bool</span> isOdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sz = qu.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;TreeNode *&gt; arr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = qu.<span class="built_in">front</span>();</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (isOdd) arr.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isOdd) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = sz - <span class="number">1</span>; l &lt; r; l++, r--) <span class="built_in">swap</span>(arr[l]-&gt;val, arr[r]-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            isOdd ^= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hqz</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://chnhqz.github.io/2024/05/06/%E5%8A%9B%E6%89%A3/">https://chnhqz.github.io/2024/05/06/%E5%8A%9B%E6%89%A3/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hqz</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/05/16/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="英语六级作文">
                        
                        <span class="card-title">英语六级作文</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-05-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            hqz
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/05/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="论文阅读">
                        
                        <span class="card-title">论文阅读</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            hqz
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">hqz</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
