<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="刀刀博客" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="刀刀博客" type="application/atom+xml"><link rel="alternate" type="application/json" title="刀刀博客" href="https://chnhqz.github.io/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.25"><link rel="modulepreload" href="/js/chunk-IL2X63J4.js"></link><link rel="modulepreload" href="/js/chunk-M5VR23OQ.js"></link><link rel="modulepreload" href="/js/chunk-XHKLB5GQ.js"></link><link rel="modulepreload" href="/js/copy-tex-GUOCZ7ZN.js"></link><link rel="modulepreload" href="/js/index.esm-SADHELSH.js"></link><link rel="modulepreload" href="/js/post-BQRCAGKL.js"></link><link rel="modulepreload" href="/js/quicklink-DQWULNTI.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="https://tva4.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://tva4.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://tva4.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://tva4.sinaimg.cn/large/6833939bly1gicis3attqj20zk0m8k7l.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://tva4.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://tva4.sinaimg.cn/large/6833939bly1giciryrr3rj20zk0m8nhk.jpg" as="image" fetchpriority="high"><meta name="description" content="欢迎来到刀刀的笔记空间(^_^)"/><link rel="canonical" href="https://chnhqz.github.io/2024/05/05/%E9%9F%B3%E8%A7%86%E9%A2%91/"><title>音视频</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">音视频</h1><div class="meta"><span class="item" title="创建时间：2024-05-05 13:07:50"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2024-05-05T13:07:50+08:00">2024-05-05</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>88k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>1:20</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">testName</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://tva4.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://tva4.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://tva4.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://tva4.sinaimg.cn/large/6833939bly1gicis3attqj20zk0m8k7l.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://tva4.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://tva4.sinaimg.cn/large/6833939bly1giciryrr3rj20zk0m8nhk.jpg&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://chnhqz.github.io/2024/05/05/%E9%9F%B3%E8%A7%86%E9%A2%91/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="hqz"/><meta itemprop="description" content="=与其感慨路难行，不如马上出发=, 欢迎来到刀刀的笔记空间(^_^)"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="刀刀博客"/></span><div class="body md" itemprop="articleBody"><img loading="lazy" data-src="截屏2024-05-05 23.17.47.png" alt="截屏2024-05-05 23.17.47" style="zoom:50%;" />
<h4 id="将mp4转化为flv格式"><a class="markdownIt-Anchor" href="#将mp4转化为flv格式">#</a> 将 MP4 转化为 FLV 格式</h4>
<ul>
<li>
<p><code>avformat_alloc_output_context2()</code>  和  <code>avformat_free_context()</code>  是 FFmpeg 中用于操作输出格式上下文（output format context）的函数。</p>
<ul>
<li><code>avformat_alloc_output_context2()</code>  用于分配并初始化一个输出格式上下文。</li>
<li><code>avformat_free_context()</code>  用于释放一个输出格式上下文及其相关资源。</li>
</ul>
</li>
<li>
<p><code>avformat_new_stream()</code>  用于创建新的流（stream）。这个函数允许你在一个封装器（如 AVFormatContext）中添加一个新的音频或视频流。</p>
</li>
<li>
<p><code>avcodec_parameters_copy()</code>  是一个函数，用于复制编解码器参数（codec parameters）。它可以将源编解码器参数复制到目标编解码器参数，确保目标参数与源参数具有相同的属性和配置。</p>
</li>
<li>
<p><code>avformat_write_header()</code>  是一个函数，用于向输出容器（output container）写入容器头（container header）。在使用 FFmpeg 编码或封装媒体文件时，通常需要在写入数据流之前调用此函数。</p>
</li>
<li>
<p><code>av_write_frame()</code>  和  <code>av_interleaved_write_frame()</code>  是用于将音视频帧写入输出文件的函数。</p>
<ul>
<li><code>av_write_frame()</code>  用于将音视频帧写入输出文件，但不进行交错写入（interleaved writing）。</li>
<li><code>av_interleaved_write_frame()</code>  则是进行交错写入的版本，确保音频和视频帧以交错的方式写入输出文件，以便播放器能够按照正确的顺序解码和播放。</li>
</ul>
</li>
<li>
<p><code>av_write_trailer()</code>  是一个函数，用于写入封装器（muxer）的尾部（trailer），完成媒体文件的封装过程。在使用 FFmpeg 编码或封装媒体文件时，通常需要在写入所有数据流并关闭文件之前调用此函数。</p>
</li>
</ul>
<blockquote>
<p>错误记录：</p>
<p><code>error C2065: “INTMAX_MAX”: 未声明的标识符 (编译源文件 src\main.cpp)</code></p>
<p>打开项目属性 -&gt; C/C++ -&gt; 预处理器 -&gt; 预处理器定义</p>
<p>添加： <strong>__STDC_LIMIT_MACROS</strong></p>
<p>遇到  <code>不能将 const AVOutputformat * 类型的值分配到 AVOutputformat * 类型的实体 </code>  错误</p>
<p>这个错误可能是因为试图将一个  <code>const AVOutputFormat</code>  类型的值分配给一个  <code>AVOutputFormat</code>  类型的变量，而这两个类型不完全相同。</p>
<p>通常情况下，可以通过使用类型转换来解决这个问题。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> AVOutputFormat *const_format_ptr = ...; <span class="comment">// 指向常量 AVOutputFormat 的指针</span></span><br><span class="line">AVOutputFormat *format_ptr = (AVOutputFormat *)const_format_ptr; <span class="comment">// 转换为普通 AVOutputFormat 指针</span></span><br></pre></td></tr></table></figure>
<p>但是，确保应用程序逻辑和安全性不受影响，因为在将常量指针转换为非常量指针时可能会引入潜在的错误。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log_packet</span><span class="params">(<span class="type">const</span> AVFormatContext* fmt_ctx, <span class="type">const</span> AVPacket* pkt, <span class="type">const</span> <span class="type">char</span>* tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AVRational* time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mp42flv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AVOutputFormat* ofmt = <span class="literal">NULL</span>;</span><br><span class="line">	AVFormatContext* ifmt_ctx = <span class="literal">NULL</span>, * ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">	AVPacket pkt;</span><br><span class="line">	<span class="type">char</span> src[] = <span class="string">&quot;input.mp4&quot;</span>;</span><br><span class="line">	<span class="type">char</span> dst[] = <span class="string">&quot;output.flv&quot;</span>;</span><br><span class="line">	<span class="type">int</span> ret, i;</span><br><span class="line">	<span class="type">int</span> stream_index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> *stream_mapping = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> stream_mapping_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ret = <span class="built_in">avformat_open_input</span>(&amp;ifmt_ctx, src, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 打开输入的多媒体文件，生成多媒体上下文</span></span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not open input file &#x27;%s&#x27;.\n&quot;</span>, src);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ret = <span class="built_in">avformat_find_stream_info</span>(ifmt_ctx, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to retrieve input stream information.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">av_dump_format</span>(ifmt_ctx, <span class="number">0</span>, src, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">avformat_alloc_output_context2</span>(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, dst);	<span class="comment">// 输出的上下文</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ofmt_ctx) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not create output context.\n&quot;</span>);</span><br><span class="line">		ret = AVERROR_UNKNOWN;</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stream_mapping_size = ifmt_ctx-&gt;nb_streams;</span><br><span class="line">	stream_mapping = (<span class="type">int</span>*)<span class="built_in">av_malloc_array</span>(stream_mapping_size, <span class="built_in">sizeof</span>(*stream_mapping));</span><br><span class="line">	<span class="keyword">if</span> (!stream_mapping) &#123;</span><br><span class="line">		ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-1.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ofmt = (AVOutputFormat*)ofmt_ctx-&gt;oformat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">		AVStream* out_stream;</span><br><span class="line">		AVStream* in_stream = ifmt_ctx-&gt;streams[<span class="number">1</span>];</span><br><span class="line">		AVCodecParameters* in_codecpar = in_stream-&gt;codecpar;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (in_codecpar-&gt;codec_type != AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">			in_codecpar-&gt;codec_type != AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">			in_codecpar-&gt;codec_type != AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">			stream_mapping[i] = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		stream_mapping[i] = stream_index++;</span><br><span class="line">		out_stream = <span class="built_in">avformat_new_stream</span>(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!out_stream) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed allocating output stream.\n&quot;</span>);</span><br><span class="line">			ret = AVERROR_UNKNOWN;</span><br><span class="line">			<span class="keyword">goto</span> end;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = <span class="built_in">avcodec_parameters_copy</span>(out_stream-&gt;codecpar, in_codecpar);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to copy codec parameters.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> end;</span><br><span class="line">		&#125;</span><br><span class="line">		out_stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">av_dump_format</span>(ofmt_ctx, <span class="number">0</span>, dst, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">		ret = <span class="built_in">avio_open</span>(&amp;ofmt_ctx-&gt;pb, dst, AVIO_FLAG_WRITE);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not open file &#x27;%s&#x27;.\n&quot;</span>, dst);</span><br><span class="line">			<span class="keyword">goto</span> end;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">avformat_write_header</span>(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error occurred when opening output file.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		AVStream* in_stream, * out_stream;</span><br><span class="line">		ret = <span class="built_in">av_read_frame</span>(ifmt_ctx, &amp;pkt);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		in_stream = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">		<span class="keyword">if</span> (pkt.stream_index &gt;= stream_mapping_size || stream_mapping[pkt.stream_index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pkt.stream_index = stream_mapping[pkt.stream_index];</span><br><span class="line">		out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">		<span class="built_in">log_packet</span>(ifmt_ctx, &amp;pkt, <span class="string">&quot;in&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* copy packet*/</span></span><br><span class="line">		pkt.pts = <span class="built_in">av_rescale_q_rnd</span>(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base,</span><br><span class="line">			AV_ROUND_PASS_MINMAX);</span><br><span class="line">		pkt.dts = <span class="built_in">av_rescale_q_rnd</span>(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base,</span><br><span class="line">			AV_ROUND_PASS_MINMAX);</span><br><span class="line">		pkt.duration = <span class="built_in">av_rescale_q</span>(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">		pkt.pos = <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">log_packet</span>(ofmt_ctx, &amp;pkt, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">		ret = <span class="built_in">av_interleaved_write_frame</span>(ofmt_ctx, &amp;pkt);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error muxing packet.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">av_write_trailer</span>(ofmt_ctx);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">	<span class="built_in">avformat_close_input</span>(&amp;ifmt_ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">		<span class="built_in">avio_closep</span>(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">avformat_free_context</span>(ofmt_ctx);</span><br><span class="line">	<span class="built_in">av_freep</span>(&amp;stream_mapping);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="ffmpeg文件与目录操作"><a class="markdownIt-Anchor" href="#ffmpeg文件与目录操作">#</a> FFmpeg 文件与目录操作</h4>
<p>文件的删除与重命名</p>
<ul>
<li><code>avpriv_io_delete()</code>  是 FFmpeg 中的一个私有函数，用于删除指定的文件或目录。它可以删除本地文件系统上的文件或目录，并提供了一些选项来控制删除操作的行为。由于  <code>avpriv_io_delete()</code>  是一个私有函数，它并不是 FFmpeg 公共 API 的一部分，因此在正式的应用程序中使用它可能会有一些风险，因为它的行为和接口可能随时发生变化。通常情况下，您应该尽量避免使用私有函数，而是使用 FFmpeg 提供的公共 API。</li>
<li><code>avpriv_io_move()</code>  是 FFmpeg 中的一个私有函数，用于移动文件或目录。它可以将文件或目录从一个位置移动到另一个位置，并提供了一些选项来控制移动操作的行为。</li>
</ul>
<h4 id="实现一个简单的小咖秀"><a class="markdownIt-Anchor" href="#实现一个简单的小咖秀">#</a> 实现一个简单的小咖秀</h4>
<p>实现步骤：</p>
<ol>
<li>从两个媒体文件中分别抽取音频与视频轨</li>
<li>将音频与视频轨合并成一个新文件</li>
<li>对音频与视频轨进行裁剪</li>
</ol>
<h4 id="libavcodecavcodech"><a class="markdownIt-Anchor" href="#libavcodecavcodech">#</a> libavcodec/avcodec.h</h4>
<ul>
<li>
<p><code>AVCodec</code>  编码器结构体</p>
</li>
<li>
<p><code>AVCodecContext</code>  编码器上下文</p>
</li>
<li>
<p><code>AVFrame</code>  解码后的帧</p>
</li>
<li>
<p><code>av_frame_alloc()</code>  和  <code>av_frame_free()</code>  是 FFmpeg 中用于操作帧（frame）的函数。</p>
<ul>
<li>
<p><code>av_frame_alloc()</code>  用于分配一个新的帧，并返回一个指向该帧的指针。您可以使用此函数来创建一个空的帧，然后填充数据。</p>
</li>
<li>
<p><code>av_frame_free()</code>  用于释放先前分配的帧。当您完成对帧的使用后，应该调用此函数来释放相关的内存，并避免内存泄漏。</p>
</li>
</ul>
<p>这两个函数通常在编解码过程中用于分配和释放帧内存。</p>
</li>
<li>
<p><code>avcodec_alloc_context3()</code>  分配一个 <code>AVCodecContext</code>  结构体的实例，用于存储编解码器的参数和状态。</p>
</li>
<li>
<p><code>avcodec_free_context()</code>   释放上下文</p>
</li>
</ul>
<p><strong>解码步骤</strong></p>
<ol>
<li>查找解码器  <code>avcodec_find_decoder</code></li>
<li>打开解码器  <code>avcodec_open2</code></li>
<li>解码  <code>avcodec_decode_video2</code></li>
</ol>
<p><strong>编码步骤</strong></p>
<ol>
<li>
<p>查找编码器  <code>avcodec_find_encoder_by_name/avcodec_find_encoder</code>  在 FFmpeg 中， <code>avcodec_find_encoder_by_name()</code>  和  <code>avcodec_find_encoder()</code>  都是用于查找编码器的函数。</p>
<ul>
<li>
<p><code>avcodec_find_encoder_by_name()</code>  根据编码器的名称查找编码器。您需要传递编码器的名称作为参数，函数将返回一个指向  <code>AVCodec</code>  结构体的指针，该结构体包含了编码器的信息。</p>
</li>
<li>
<p><code>avcodec_find_encoder()</code>  则是根据编码器的 ID（编码器的枚举值）来查找编码器。您需要传递编码器的 ID 作为参数，函数将返回一个指向  <code>AVCodec</code>  结构体的指针，该结构体包含了编码器的信息。</p>
</li>
</ul>
</li>
<li>
<p>设置编码参数（分辨率、帧率、…），并打开编码器  <code>avcodec_open2</code></p>
</li>
<li>
<p>编码  <code>avcodec_encode_video2</code></p>
</li>
</ol>
<p><strong>注意：音频，视频的编解码大概类似，大体都分为三步：找到编解码器、（设置参数）打开编解码器、进行编解码。</strong></p>
<h4 id="从mp4截取一段视频"><a class="markdownIt-Anchor" href="#从mp4截取一段视频">#</a> 从 MP4 截取一段视频</h4>
<ul>
<li>
<p><code>av_seek_frame</code>  函数用于在媒体文件中定位到指定的帧。</p>
<p>参数解释：</p>
<ul>
<li><code>AVFormatContext *s</code> ：表示输入或输出媒体文件的格式上下文。</li>
<li><code>int stream_index</code> ：表示要寻找的媒体流的索引。</li>
<li><code>int64_t timestamp</code> ：表示要寻找的时间戳，以媒体流的基本时间单位为单位（通常是微秒）。</li>
<li><code>int flags</code> ：表示定位的标志位，可以是  <code>AVSEEK_FLAG_BACKWARD</code> （向后定位）、 <code>AVSEEK_FLAG_BYTE</code> （以字节为单位定位）等。</li>
</ul>
<p>该函数将在媒体文件中定位到距离给定时间戳最近的关键帧，并更新  <code>AVFormatContext</code>  中的信息以反映新的位置。</p>
</li>
</ul>
<blockquote>
<p>avformat_new_stream 的用法：</p>
<p>AVStream 即是流通道。例如我们将 H264 和 AAC 码流存储为 MP4 文件的时候，就需要在 MP4 文件中增加两个流通道，一个存储 Video：H264，一个存储 Audio：AAC。（假设 H264 和 AAC 只包含单个流通道）。</p>
<p>AVStream 包含很多参数，用于记录通道信息，其中最重要的是 :</p>
<p>AVCodecParameters * codecpar ：用于记录编码后的流信息，即通道中存储的流的编码信息。</p>
<p>AVRational time_base ：AVStream 通道的时间基，时间基是个相当重要的概念。（可参考之后的关于 ffmpeg 时间的文章）</p>
<p>需要注意的是：现在的 ffmpeg 3.1.4 版本已经使用 AVCodecParameters * codecpar 替换了原先的 CodecContext* codec !</p>
<p>avformat_new_stream 在 AVFormatContext 中创建 Stream 通道</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVFormatContext:</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nb_streams; <span class="comment">// 记录stream通道数目</span></span><br><span class="line">AVStream **streams;      <span class="comment">// 存储stream通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AVStream</span></span><br><span class="line"><span class="type">int</span> index;							<span class="comment">// 在AVFormatContext 中所处的通道索引</span></span><br></pre></td></tr></table></figure>
<p>![截屏 2024-05-07 16.22.19](/Users/huangqiuzhao/blog/source/_posts/ 音视频 / 截屏 2024-05-07 16.22.19.png)</p>
<p><code>avformat_new_stream</code>  之后便在 <code>AVFormatContext</code>  里增加了 <code>AVStream</code>  增加了 <code>AVStream</code>  通道（相关的 <code>index</code>  已经被设置了）。之后我们就可以自行设置 <code>AVStream</code>  的一些信息。例如  <code>codec_id,format,bit_rate,width,heoght.....</code></p>
<p>avformat_new_stream(AVFormatContext * s, const AVCodec * c)</p>
<p>AVCodec ：s 需要通信的视频对应的编码方式。<br>
在已知 codec_id 的情况下可以通过 codec=avcodec_find_decoder (codec_id)；的方式得到。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014162133/article/details/82258488">https://blog.csdn.net/u014162133/article/details/82258488</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kami_Jiang/article/details/106784580">https://blog.csdn.net/Kami_Jiang/article/details/106784580</a></p>
</blockquote>
<h4 id="sdl事件基本原理"><a class="markdownIt-Anchor" href="#sdl事件基本原理">#</a> SDL 事件基本原理</h4>
<ol>
<li>SDL 将所有事件都存放在一个队列中</li>
<li>所有对事件的操作，其实就是对队列的操作</li>
</ol>
<p><strong>SDL 事件种类</strong></p>
<ol>
<li><code>SDL_WindowEvent</code> ：窗口事件</li>
<li><code>SDL_KeyboardEvent</code>  ：键盘事件</li>
<li><code>SDL_MouseMotionEvent</code>  ：鼠标事件</li>
<li>自定义事件</li>
</ol>
<p><code>SDL_PollEvent</code>  DL 库中的一个函数，用于检查是否有任何事件发生。它会检查事件队列，并返回队列中的下一个事件（如果有）。轮询操作，要等待一段时间。如果不等待时间，CPU 过载</p>
<p><code>SDL_WaitEvent</code>  事件触发机制，用于等待事件的发生。如果当前事件队列为空，则该函数将会一直等待，直到有事件发生。</p>
<p><strong>纹理渲染</strong></p>
<p>![截屏 2024-05-08 14.22.58](/Users/huangqiuzhao/blog/source/_posts/ 音视频 / 截屏 2024-05-08 14.22.58.png)</p>
<ul>
<li><code>SDL_CreateTexture()</code>
<ul>
<li><code>format:YUV,RGB</code></li>
<li><code>access:Texture类型,Target,Stream</code></li>
</ul>
</li>
<li><code>SDL_DestroyTexture()</code></li>
<li><code>SDL_SetRenderTarget()</code>  用于设置渲染目标，即指定在哪个渲染器上进行绘制。你可以将渲染目标设置为一个纹理或者窗口。</li>
<li><code>SDL_RenderClear()</code>  用于清除当前渲染目标上的所有内容，将其填充为指定的颜色。</li>
<li><code>SDL_RenderCopy()</code>  用于将纹理复制到当前渲染目标上。</li>
<li><code>SDL_RenderPresent</code>  用于更新窗口显示，将之前所有的渲染操作绘制到窗口上。</li>
</ul>
<h4 id="yuv播放器"><a class="markdownIt-Anchor" href="#yuv播放器">#</a> YUV 播放器</h4>
<p><strong>创建线程</strong></p>
<ul>
<li><code>SDL_CreateThread()</code>  函数用于创建一个新的线程。它接受两个参数：一个指向函数的指针，这个函数将作为新线程的入口点；以及一个可选的参数，将传递给新线程的入口函数。函数返回一个指向新线程的  <code>SDL_Thread</code>  结构体的指针。
<ul>
<li><code>fn</code>  线程执行函数</li>
<li><code>name</code>  线程名</li>
<li><code>data</code>  执行函数参数</li>
</ul>
</li>
</ul>
<p><strong>更新纹理</strong></p>
<ul>
<li><code>SDL_UpdateTexture()</code>  函数用于更新纹理的像素数据。它接受纹理、矩形区域和像素数据作为参数，以更新纹理的一部分或全部像素。</li>
<li><code>SDL_UpdateYUVTexture</code>  函数用于更新 YUV 格式的纹理像素数据。它接受纹理、矩形区域、Y、U 和 V 平面的像素数据作为参数，以更新纹理的一部分或全部像素。</li>
</ul>
<h4 id="sdl音频api"><a class="markdownIt-Anchor" href="#sdl音频api">#</a> SDL 音频 API</h4>
<ul>
<li><code>SDL_OpenAudio/SDL_CloseAudio</code>   <code>SDL_OpenAudio()</code>  函数用于初始化音频子系统，并打开音频设备以进行音频播放或录制。而 <code>SDL_CloseAudio()</code>  函数用于关闭音频设备并释放音频子系统的资源。</li>
<li><code>SDL_PauseAudio</code>   <code>SDL_PauseAudio</code>  用于暂停或继续音频回放。</li>
<li><code>SDL_MixAudio</code>  用于将音频数据混合到音频缓冲区中。</li>
</ul>
<h4 id="pcm-音频播放器"><a class="markdownIt-Anchor" href="#pcm-音频播放器">#</a> PCM 音频播放器</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDL_MAIN_HANDLED</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SDL2/SDL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 4096000</span></span><br><span class="line"><span class="type">static</span> Uint8* audio_buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> buffer_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> Uint8* audio_pos = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_audio_data</span><span class="params">(<span class="type">void</span>* udata, Uint8* stream, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (buffer_len == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SDL_memset</span>(stream, <span class="number">0</span>, len);</span><br><span class="line">	len = (len &lt; buffer_len) ? len : buffer_len;</span><br><span class="line">	<span class="built_in">SDL_MixAudio</span>(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span><br><span class="line"></span><br><span class="line">	audio_pos += len;</span><br><span class="line">	buffer_len -= len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCM_play</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pcm_player</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// SDL 初始化</span></span><br><span class="line">		<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">char</span> path[] = <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">		FILE* audio_fd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">SDL_Init</span>(SDL_INIT_AUDIO)) &#123;</span><br><span class="line">			<span class="built_in">SDL_Log</span>(<span class="string">&quot;Failed to initial.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		audio_fd = <span class="built_in">fopen</span>(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!audio_fd) &#123;</span><br><span class="line">			<span class="built_in">SDL_Log</span>(<span class="string">&quot;Failed to open pcm file!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分配内存空间</span></span><br><span class="line">		audio_buf = (Uint8*)<span class="built_in">malloc</span>(BLOCK_SIZE);</span><br><span class="line">		<span class="keyword">if</span> (!audio_buf) &#123;</span><br><span class="line">			<span class="built_in">SDL_Log</span>(<span class="string">&quot;Failed to alloc memory!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// spec 音频参数 采样率</span></span><br><span class="line">		SDL_AudioSpec spec;</span><br><span class="line">		spec.freq = <span class="number">44100</span>;</span><br><span class="line">		spec.channels = <span class="number">2</span>;</span><br><span class="line">		spec.format = AUDIO_S16SYS;</span><br><span class="line">		spec.silence = <span class="number">0</span>;</span><br><span class="line">		spec.callback = read_audio_data;</span><br><span class="line">		spec.userdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">SDL_OpenAudio</span>(&amp;spec, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="built_in">SDL_Log</span>(<span class="string">&quot;Failed to open audio device!\n&quot;</span>);\</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SDL_PauseAudio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			buffer_len = <span class="built_in">fread</span>(audio_buf, <span class="number">1</span>, BLOCK_SIZE, audio_fd);</span><br><span class="line">			audio_pos = audio_buf;</span><br><span class="line">			<span class="keyword">while</span> (audio_pos &lt; (audio_buf + buffer_len)) &#123;</span><br><span class="line">				<span class="built_in">SDL_Delay</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (buffer_len != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SDL_CloseAudio</span>();</span><br><span class="line"></span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__FAIL:</span><br><span class="line">		<span class="keyword">if</span> (audio_buf) &#123;</span><br><span class="line">			<span class="built_in">free</span>(audio_buf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (audio_fd) &#123;</span><br><span class="line">			<span class="built_in">fclose</span>(audio_fd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">SDL_Quit</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="简单视频播放器"><a class="markdownIt-Anchor" href="#简单视频播放器">#</a> 简单视频播放器</h4>
<p>利用 <code>FFmpeg</code>  将 <code>h264</code>  等数据解码成 <code>YUV</code>  数据，通过 <code>SDL</code>  渲染。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sws_ctx = <span class="built_in">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">	pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">	AV_PIX_FMT_YUV420P, SWS_BILINEAR,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了 libswscale 库中的  <code>sws_getContext</code>  函数来创建一个图像转换上下文（sws_ctx）。这个上下文用于将一个像素格式的图像转换成另一种像素格式的图像，以便在播放或处理视频时进行必要的格式转换。</p>
<p>具体来说，这段代码的作用是将视频帧从输入编解码器上下文（pCodecCtx）的像素格式（pCodecCtx-&gt;pix_fmt）转换为 YUV420P 格式。在大多数情况下，YUV420P 是视频处理中常用的一种格式，因为它包含了亮度（Y）和色度（U、V）信息，而且是压缩视频格式的一种常见格式。</p>
<p>下面是这段代码的参数解释：</p>
<ul>
<li><code>pCodecCtx-&gt;width</code>  和  <code>pCodecCtx-&gt;height</code> : 输入视频帧的宽度和高度。</li>
<li><code>pCodecCtx-&gt;pix_fmt</code> : 输入视频帧的像素格式。</li>
<li><code>pCodecCtx-&gt;width</code>  和  <code>pCodecCtx-&gt;height</code> : 输出视频帧的宽度和高度，通常与输入视频帧的尺寸相同。</li>
<li><code>AV_PIX_FMT_YUV420P</code> : 输出视频帧的像素格式，这里选择了 YUV420P 格式。</li>
<li><code>SWS_BILINEAR</code> : 像素转换的算法，这里选择了双线性插值算法，用于平滑图像。</li>
</ul>
<p>最后三个参数是用于设置特殊选项的，通常情况下可以设为 NULL。</p>
<p>总之，这段代码的目的是创建一个图像转换上下文，以便在播放视频时将输入的像素格式转换为 YUV420P 格式，以便后续处理或显示。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pict = (AVPicture*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(AVPicture));</span><br><span class="line"><span class="built_in">avpicture_alloc</span>(pict, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码分配了一个大小合适的内存块来存储 YUV420P 格式的图像数据，并使用  <code>avpicture_alloc</code>  函数来初始化  <code>pict</code>  指针所指向的内存块，使其可以存储 YUV420P 格式的图像数据。</p>
<p>具体来说， <code>avpicture_alloc</code>  函数会根据指定的像素格式（AV_PIX_FMT_YUV420P）、宽度（pCodecCtx-&gt;width）和高度（pCodecCtx-&gt;height），为  <code>pict</code>  指向的内存块分配足够的空间，并根据像素格式的要求对内存块进行初始化，以便后续存储 YUV420P 格式的图像数据。</p>
<p>这段代码的目的是为后续的视频解码和处理准备一个用于存储图像数据的缓冲区，以便于在播放或处理视频时使用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sws_scale</span>(sws_ctx, (<span class="type">uint8_t</span> <span class="type">const</span>* <span class="type">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, pict-&gt;data, pict-&gt;linesize);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用  <code>sws_scale</code>  函数将解码后的视频帧数据转换为 YUV420P 格式，并将结果存储在  <code>pict</code>  所指向的内存块中。</p>
<p>具体来说， <code>sws_scale</code>  函数会将输入的视频帧数据（ <code>pFrame-&gt;data</code> ）按照指定的转换参数（ <code>sws_ctx</code> ）进行转换，转换后的数据存储在输出缓冲区（ <code>pict-&gt;data</code> ）中。参数  <code>pFrame-&gt;linesize</code>  表示输入数据每行的字节数，而  <code>pict-&gt;linesize</code>  表示输出数据每行的字节数。函数还会根据输入和输出的图像大小进行缩放和裁剪操作，以确保输出数据的正确性和一致性。</p>
<p>这段代码的作用是将解码后的视频帧数据转换为 YUV420P 格式，并存储在指定的内存块中，以便后续的视频处理和显示。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">player</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> filepath[] = <span class="string">&quot;input.mp4&quot;</span>;</span><br><span class="line">	<span class="comment">// 多媒体文件上下文</span></span><br><span class="line">	AVFormatContext* pFormatCtx = <span class="literal">NULL</span>;			</span><br><span class="line">	<span class="type">int</span> i, videoStream;</span><br><span class="line">	<span class="comment">// 编解码上下文</span></span><br><span class="line">	AVCodecContext* pCodecCtxOrig = <span class="literal">NULL</span>;</span><br><span class="line">	AVCodecContext* pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 图像裁剪上下文</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SwsContext</span>* sws_ctx = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 编解码器</span></span><br><span class="line">	AVCodec* pCodec = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 解码后的数据帧</span></span><br><span class="line">	AVFrame* pFrame = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 解码前的数据包</span></span><br><span class="line">	AVPacket packet;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> frameFinished;</span><br><span class="line">	<span class="type">float</span> aspect_ratio;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解码出来的YUV数据存放在</span></span><br><span class="line">	AVPicture* pict = <span class="literal">NULL</span>;</span><br><span class="line">	SDL_Rect rect;</span><br><span class="line">	Uint32 pixformat;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// render</span></span><br><span class="line">	SDL_Window* win = <span class="literal">NULL</span>;</span><br><span class="line">	SDL_Renderer* renderer = <span class="literal">NULL</span>;</span><br><span class="line">	SDL_Texture* texture = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置默认的窗口大小</span></span><br><span class="line">	<span class="type">int</span> w_width = <span class="number">640</span>;</span><br><span class="line">	<span class="type">int</span> w_height = <span class="number">480</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">SDL_Init</span>(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Could not initialize SDL - %s.\n&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">av_register_all</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, filepath, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Could not open video file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to find stream information.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">av_dump_format</span>(pFormatCtx, <span class="number">0</span>, filepath, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到第一个视频流</span></span><br><span class="line">	videoStream = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">			videoStream = i;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;视频流编号：%d\n&quot;</span>, i);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (videoStream == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Din&#x27;t find a video stream.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这行代码的目的是获取视频流的编解码上下文（`AVCodecContext`）。</span></span><br><span class="line"><span class="comment">	`pFormatCtx` 是输入格式上下文，`streams[videoStream]` 表示视频流，</span></span><br><span class="line"><span class="comment">	然后通过 `codec` 成员获取该流的编解码上下文。*/</span></span><br><span class="line">	pCodecCtxOrig = pFormatCtx-&gt;streams[videoStream]-&gt;codec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到视频流的解码器</span></span><br><span class="line">	pCodec = <span class="built_in">avcodec_find_decoder</span>(pCodecCtxOrig-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Unsupported codec.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制 上下文 为了不破坏原来的流</span></span><br><span class="line">	pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">avcodec_copy_context</span>(pCodecCtx, pCodecCtxOrig) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Couldn&#x27;t copy codec context.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开解码器</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to open decoder!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配视频帧</span></span><br><span class="line">	pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"></span><br><span class="line">	w_width = pCodecCtx-&gt;width;</span><br><span class="line">	w_height = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">	win = <span class="built_in">SDL_CreateWindow</span>(<span class="string">&quot;Media Player&quot;</span>,</span><br><span class="line">		SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">		SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">		w_width, w_height,</span><br><span class="line">		SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!win) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to create window by SDL&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	renderer = <span class="built_in">SDL_CreateRenderer</span>(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">		<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to create Renderer by SDL&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> __FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class="line">	texture = <span class="built_in">SDL_CreateTexture</span>(renderer, pixformat,</span><br><span class="line">		SDL_TEXTUREACCESS_STREAMING, w_width, w_height);</span><br><span class="line"></span><br><span class="line">	sws_ctx = <span class="built_in">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">		pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">		AV_PIX_FMT_YUV420P, SWS_BILINEAR,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pict = (AVPicture*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(AVPicture));</span><br><span class="line">	<span class="built_in">avpicture_alloc</span>(pict, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (packet.stream_index == videoStream) &#123;</span><br><span class="line">			<span class="comment">// 解码视频帧</span></span><br><span class="line">			<span class="built_in">avcodec_decode_video2</span>(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);</span><br><span class="line">			<span class="comment">// 得到解码后的视频帧</span></span><br><span class="line">			<span class="keyword">if</span> (frameFinished) &#123;</span><br><span class="line">				<span class="comment">// 将图片转化为 SDL 使用的 YUV 格式</span></span><br><span class="line">				<span class="built_in">sws_scale</span>(sws_ctx, (<span class="type">uint8_t</span> <span class="type">const</span>* <span class="type">const</span>*)pFrame-&gt;data,</span><br><span class="line">					pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, pict-&gt;data, pict-&gt;linesize);</span><br><span class="line">					</span><br><span class="line">				<span class="built_in">SDL_UpdateYUVTexture</span>(texture, <span class="literal">NULL</span>,</span><br><span class="line">					pict-&gt;data[<span class="number">0</span>], pict-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">					pict-&gt;data[<span class="number">1</span>], pict-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">					pict-&gt;data[<span class="number">2</span>], pict-&gt;linesize[<span class="number">2</span>]</span><br><span class="line">					);</span><br><span class="line"></span><br><span class="line">				rect.x = <span class="number">0</span>;</span><br><span class="line">				rect.y = <span class="number">0</span>;</span><br><span class="line">				rect.w = pCodecCtx-&gt;width;</span><br><span class="line">				rect.h = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">SDL_RenderClear</span>(renderer);</span><br><span class="line">				<span class="built_in">SDL_RenderCopy</span>(renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">				<span class="built_in">SDL_RenderPresent</span>(renderer);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">av_free_packet</span>(&amp;packet);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__FAIL:</span><br><span class="line">	<span class="comment">// Free the YUV frame</span></span><br><span class="line">	<span class="keyword">if</span> (pFrame) &#123;</span><br><span class="line">		<span class="built_in">av_frame_free</span>(&amp;pFrame);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close the codec</span></span><br><span class="line">	<span class="keyword">if</span> (pCodecCtx) &#123;</span><br><span class="line">		<span class="built_in">avcodec_close</span>(pCodecCtx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pCodecCtxOrig) &#123;</span><br><span class="line">		<span class="built_in">avcodec_close</span>(pCodecCtxOrig);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close the video file</span></span><br><span class="line">	<span class="keyword">if</span> (pFormatCtx) &#123;</span><br><span class="line">		<span class="built_in">avformat_close_input</span>(&amp;pFormatCtx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pict) &#123;</span><br><span class="line">		<span class="built_in">avpicture_free</span>(pict);</span><br><span class="line">		<span class="built_in">free</span>(pict);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (win) &#123;</span><br><span class="line">		<span class="built_in">SDL_DestroyWindow</span>(win);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">		<span class="built_in">SDL_DestroyRenderer</span>(renderer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (texture) &#123;</span><br><span class="line">		<span class="built_in">SDL_DestroyTexture</span>(texture);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SDL_Quit</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用队列存放音频包-播放器"><a class="markdownIt-Anchor" href="#使用队列存放音频包-播放器">#</a> 使用队列存放音频包 - 播放器</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDL_MAIN_HANDLED</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SDL2/SDL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/mem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 4096000</span></span><br><span class="line"><span class="type">static</span> Uint8* audio_buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> buffer_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> Uint8* audio_pos = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55, 28, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> av_frame_alloc avcodec_alloc_frame</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> av_frame_free avcodec_free_frame</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span></span><br><span class="line"><span class="type">int</span> quit = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">SwrContext</span>* audio_convert_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PacketQueue</span> &#123;</span><br><span class="line">	AVPacketList* first_pkt, * last_pkt;</span><br><span class="line">	<span class="type">int</span> nb_packets;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	SDL_mutex* mutex;</span><br><span class="line">	SDL_cond* cond;</span><br><span class="line">&#125; PacketQueue;</span><br><span class="line"></span><br><span class="line">PacketQueue audioq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">packet_queue_init</span><span class="params">(PacketQueue* q)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="built_in">sizeof</span>(PacketQueue));</span><br><span class="line">	q-&gt;mutex = <span class="built_in">SDL_CreateMutex</span>();</span><br><span class="line">	q-&gt;cond = <span class="built_in">SDL_CreateCond</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">packet_queue_put</span><span class="params">(PacketQueue* q, AVPacket* pkt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	AVPacketList* pkt1;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">av_dup_packet</span>(pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pkt1 = (AVPacketList*)<span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVPacketList));</span><br><span class="line">	<span class="keyword">if</span> (!pkt1)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	pkt1-&gt;pkt = *pkt;</span><br><span class="line">	pkt1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SDL_LockMutex</span>(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!q-&gt;last_pkt) &#123;</span><br><span class="line">		q-&gt;first_pkt = pkt1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q-&gt;last_pkt = pkt1;</span><br><span class="line">	q-&gt;nb_packets++;</span><br><span class="line">	q-&gt;size += pkt1-&gt;pkt.size;</span><br><span class="line">	<span class="built_in">SDL_CondSignal</span>(q-&gt;cond);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SDL_UnlockMutex</span>(q-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">packet_queue_get</span><span class="params">(PacketQueue* q, AVPacket* pkt, <span class="type">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AVPacketList* pkt1;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SDL_LockMutex</span>(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (quit) &#123;</span><br><span class="line">			ret = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pkt1 = q-&gt;first_pkt;</span><br><span class="line">		<span class="keyword">if</span> (pkt1) &#123;</span><br><span class="line">			q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (!q-&gt;first_pkt)</span><br><span class="line">				q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">			q-&gt;nb_packets--;</span><br><span class="line">			q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class="line">			*pkt = pkt1-&gt;pkt;</span><br><span class="line">			<span class="built_in">av_free</span>(pkt1);</span><br><span class="line">			ret = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">SDL_CondWait</span>(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SDL_UnlockMutex</span>(q-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">audio_decode_frame</span><span class="params">(AVCodecContext* aCodecCtx, <span class="type">uint8_t</span>* audio_buf, <span class="type">int</span> buf_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> AVPacket pkt;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span>* audio_pkt_data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> audio_pkt_size = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> AVFrame frame;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len1, data_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">while</span> (audio_pkt_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">			len1 = <span class="built_in">avcodec_decode_audio4</span>(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);</span><br><span class="line">			<span class="keyword">if</span> (len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				audio_pkt_size = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			audio_pkt_data += len1;</span><br><span class="line">			audio_pkt_size -= len1;</span><br><span class="line">			data_size = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">				data_size = <span class="number">2</span> * <span class="number">2</span> * frame.nb_samples;</span><br><span class="line">				<span class="built_in">assert</span>(data_size &lt;= buf_size);</span><br><span class="line">				<span class="built_in">swr_convert</span>(audio_convert_ctx,</span><br><span class="line">					&amp;audio_buf,</span><br><span class="line">					MAX_AUDIO_FRAME_SIZE * <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">					(<span class="type">const</span> <span class="type">uint8_t</span>**)frame.data,</span><br><span class="line">					frame.nb_samples);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (data_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> data_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pkt.data)</span><br><span class="line">			<span class="built_in">av_free_packet</span>(&amp;pkt);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (quit) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">packet_queue_get</span>(&amp;audioq, &amp;pkt, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		audio_pkt_data = pkt.data;</span><br><span class="line">		audio_pkt_size = pkt.size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">audio_callback</span><span class="params">(<span class="type">void</span>* userdata, Uint8* stream, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	AVCodecContext* aCodecCtx = (AVCodecContext*)userdata;</span><br><span class="line">	<span class="type">int</span> len1, audio_size;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="number">3</span>) / <span class="number">2</span>];</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> audio_buf_size = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> audio_buf_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (audio_buf_index &gt;= audio_buf_size) &#123;</span><br><span class="line">			<span class="comment">/* We have already sent all our data; get more*/</span></span><br><span class="line">			audio_size = <span class="built_in">audio_decode_frame</span>(aCodecCtx, audio_buf, <span class="built_in">sizeof</span>(audio_buf));</span><br><span class="line">			<span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				audio_buf_size = <span class="number">1024</span>;</span><br><span class="line">				<span class="built_in">memset</span>(audio_buf, <span class="number">0</span>, audio_buf_size);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				audio_buf_size = audio_size;</span><br><span class="line">			&#125;</span><br><span class="line">			audio_buf_index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		len1 = audio_buf_size - audio_buf_index;</span><br><span class="line">		<span class="keyword">if</span> (len1 &gt; len) len1 = len;</span><br><span class="line">		<span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span>*)audio_buf + audio_buf_index, len1);</span><br><span class="line">		len -= len1;</span><br><span class="line">		stream += len1;</span><br><span class="line">		audio_buf_index += len1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCM_play</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">player</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">char</span> filepath[] = <span class="string">&quot;input.mp4&quot;</span>;</span><br><span class="line">		<span class="comment">// 多媒体文件上下文</span></span><br><span class="line">		AVFormatContext* pFormatCtx = <span class="literal">NULL</span>;			</span><br><span class="line">		<span class="type">int</span> i, videoStream, audioStream;</span><br><span class="line">		<span class="comment">// 编解码上下文 视频流</span></span><br><span class="line">		AVCodecContext* pCodecCtxOrig = <span class="literal">NULL</span>;</span><br><span class="line">		AVCodecContext* pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 图像裁剪上下文</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">SwsContext</span>* sws_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 音频流</span></span><br><span class="line">		AVCodecContext* aCodecCtxtOrig = <span class="literal">NULL</span>;</span><br><span class="line">		AVCodecContext* aCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">		AVCodec* aCodec = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="type">int64_t</span> in_channel_layout;</span><br><span class="line">		<span class="type">int64_t</span> out_channel_layout;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 编解码器</span></span><br><span class="line">		AVCodec* pCodec = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">// 解码后的数据帧</span></span><br><span class="line">		AVFrame* pFrame = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">// 解码前的数据包</span></span><br><span class="line">		AVPacket packet;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> frameFinished;</span><br><span class="line">		<span class="type">float</span> aspect_ratio;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解码出来的YUV数据存放在</span></span><br><span class="line">		AVPicture* pict = <span class="literal">NULL</span>;</span><br><span class="line">		SDL_Rect rect;</span><br><span class="line">		Uint32 pixformat;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// render</span></span><br><span class="line">		SDL_Window* win = <span class="literal">NULL</span>;</span><br><span class="line">		SDL_Renderer* renderer = <span class="literal">NULL</span>;</span><br><span class="line">		SDL_Texture* texture = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置默认的窗口大小</span></span><br><span class="line">		<span class="type">int</span> w_width = <span class="number">640</span>;</span><br><span class="line">		<span class="type">int</span> w_height = <span class="number">480</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 事件</span></span><br><span class="line">		SDL_Event event;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 音频 指定音频播放的参数</span></span><br><span class="line">		SDL_AudioSpec wanted_spec, spec;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">SDL_Init</span>(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Could not initialize SDL - %s.\n&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">av_register_all</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, filepath, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Could not open video file\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to find stream information.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">av_dump_format</span>(pFormatCtx, <span class="number">0</span>, filepath, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到 视频流 音频流</span></span><br><span class="line">		videoStream = <span class="number">-1</span>;</span><br><span class="line">		audioStream = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">				videoStream = i;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;视频流编号：%d\n&quot;</span>, i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">				audioStream = i;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;音频流编号：%d\n&quot;</span>, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (videoStream == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Din&#x27;t find a video stream.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (audioStream == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Din&#x27;t find a audio stream.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 音频</span></span><br><span class="line">		aCodecCtxtOrig = pFormatCtx-&gt;streams[audioStream]-&gt;codec;</span><br><span class="line">		aCodec = <span class="built_in">avcodec_find_decoder</span>(aCodecCtxtOrig-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!aCodec) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Unsupported codec.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		aCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(aCodec);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">avcodec_copy_context</span>(aCodecCtx, aCodecCtxtOrig) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Couldn&#x27;t copy codec context.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置音频参数</span></span><br><span class="line">		wanted_spec.freq = aCodecCtx-&gt;sample_rate;</span><br><span class="line">		wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">		wanted_spec.channels = aCodecCtx-&gt;channels;</span><br><span class="line">		wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">		wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class="line">		wanted_spec.callback = audio_callback;</span><br><span class="line">		wanted_spec.userdata = aCodecCtx;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">SDL_OpenAudio</span>(&amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to open audio device -%s.\n&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 打开音频解码器</span></span><br><span class="line">		<span class="built_in">avcodec_open2</span>(aCodecCtx, aCodec, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">packet_queue_init</span>(&amp;audioq);</span><br><span class="line"></span><br><span class="line">		in_channel_layout = <span class="built_in">av_get_default_channel_layout</span>(aCodecCtx-&gt;channels);</span><br><span class="line">		out_channel_layout = in_channel_layout;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;in layout:%lld, out layout:%lld \n&quot;</span>, in_channel_layout, out_channel_layout);</span><br><span class="line"></span><br><span class="line">		audio_convert_ctx = <span class="built_in">swr_alloc</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (audio_convert_ctx) &#123;</span><br><span class="line">			<span class="built_in">swr_alloc_set_opts</span>(audio_convert_ctx,</span><br><span class="line">				out_channel_layout,</span><br><span class="line">				AV_SAMPLE_FMT_S16,</span><br><span class="line">				aCodecCtx-&gt;sample_rate,</span><br><span class="line">				in_channel_layout,</span><br><span class="line">				aCodecCtx-&gt;sample_fmt,</span><br><span class="line">				aCodecCtx-&gt;sample_rate,</span><br><span class="line">				<span class="number">0</span>,</span><br><span class="line">				<span class="literal">NULL</span></span><br><span class="line">				);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">swr_init</span>(audio_convert_ctx);</span><br><span class="line">		<span class="built_in">SDL_PauseAudio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 这行代码的目的是获取视频流的编解码上下文（`AVCodecContext`）。</span></span><br><span class="line"><span class="comment">		`pFormatCtx` 是输入格式上下文，`streams[videoStream]` 表示视频流，</span></span><br><span class="line"><span class="comment">		然后通过 `codec` 成员获取该流的编解码上下文。*/</span></span><br><span class="line">		pCodecCtxOrig = pFormatCtx-&gt;streams[videoStream]-&gt;codec;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到视频流的解码器</span></span><br><span class="line">		pCodec = <span class="built_in">avcodec_find_decoder</span>(pCodecCtxOrig-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Unsupported codec.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 复制 上下文 为了不破坏原来的流</span></span><br><span class="line">		pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">avcodec_copy_context</span>(pCodecCtx, pCodecCtxOrig) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Couldn&#x27;t copy codec context.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打开解码器</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to open decoder!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分配视频帧</span></span><br><span class="line">		pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"></span><br><span class="line">		w_width = pCodecCtx-&gt;width;</span><br><span class="line">		w_height = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">		win = <span class="built_in">SDL_CreateWindow</span>(<span class="string">&quot;Media Player&quot;</span>,</span><br><span class="line">			SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">			SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">			<span class="number">500</span>, <span class="number">500</span>,</span><br><span class="line">			SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!win) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class="string">&quot;Failed to create window by SDL&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		renderer = <span class="built_in">SDL_CreateRenderer</span>(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">			<span class="built_in">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION , <span class="string">&quot;Failed to create Renderer by SDL&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> __FAIL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class="line">		texture = <span class="built_in">SDL_CreateTexture</span>(renderer, pixformat,</span><br><span class="line">			SDL_TEXTUREACCESS_STREAMING, w_width, w_height);</span><br><span class="line"></span><br><span class="line">		sws_ctx = <span class="built_in">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">			pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">			AV_PIX_FMT_YUV420P, SWS_BILINEAR,</span><br><span class="line">			<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		pict = (AVPicture*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(AVPicture));</span><br><span class="line">		<span class="built_in">avpicture_alloc</span>(pict, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (packet.stream_index == videoStream) &#123;</span><br><span class="line">				<span class="comment">// 解码视频帧</span></span><br><span class="line">				<span class="built_in">avcodec_decode_video2</span>(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);</span><br><span class="line">				<span class="comment">// 得到解码后的视频帧</span></span><br><span class="line">				<span class="keyword">if</span> (frameFinished) &#123;</span><br><span class="line">					<span class="comment">// 将图片转化为 SDL 使用的 YUV 格式</span></span><br><span class="line">					<span class="built_in">sws_scale</span>(sws_ctx, (<span class="type">uint8_t</span> <span class="type">const</span>* <span class="type">const</span>*)pFrame-&gt;data,</span><br><span class="line">						pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, pict-&gt;data, pict-&gt;linesize);</span><br><span class="line">					</span><br><span class="line">					<span class="built_in">SDL_UpdateYUVTexture</span>(texture, <span class="literal">NULL</span>,</span><br><span class="line">						pict-&gt;data[<span class="number">0</span>], pict-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">						pict-&gt;data[<span class="number">1</span>], pict-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">						pict-&gt;data[<span class="number">2</span>], pict-&gt;linesize[<span class="number">2</span>]</span><br><span class="line">						);</span><br><span class="line"></span><br><span class="line">					rect.x = <span class="number">0</span>;</span><br><span class="line">					rect.y = <span class="number">0</span>;</span><br><span class="line">					rect.w = pCodecCtx-&gt;width;</span><br><span class="line">					rect.h = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">					<span class="built_in">SDL_RenderClear</span>(renderer);</span><br><span class="line">					<span class="built_in">SDL_RenderCopy</span>(renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">					<span class="built_in">SDL_RenderPresent</span>(renderer);</span><br><span class="line">					<span class="built_in">SDL_Delay</span>(<span class="number">40</span>);</span><br><span class="line">					<span class="built_in">av_free_packet</span>(&amp;packet);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (packet.stream_index == audioStream) &#123;</span><br><span class="line">				<span class="built_in">packet_queue_put</span>(&amp;audioq, &amp;packet);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">av_free_packet</span>(&amp;packet);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">SDL_PollEvent</span>(&amp;event);</span><br><span class="line">			<span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">			<span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">				quit = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">goto</span> __QUIT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">SDL_Log</span>(<span class="string">&quot;event type is %d&quot;</span>, event.type);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	__QUIT:</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	__FAIL:</span><br><span class="line">		<span class="comment">// Free the YUV frame</span></span><br><span class="line">		<span class="keyword">if</span> (pFrame) &#123;</span><br><span class="line">			<span class="built_in">av_frame_free</span>(&amp;pFrame);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Close the codec</span></span><br><span class="line">		<span class="keyword">if</span> (pCodecCtx) &#123;</span><br><span class="line">			<span class="built_in">avcodec_close</span>(pCodecCtx);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pCodecCtxOrig) &#123;</span><br><span class="line">			<span class="built_in">avcodec_close</span>(pCodecCtxOrig);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Close the video file</span></span><br><span class="line">		<span class="keyword">if</span> (pFormatCtx) &#123;</span><br><span class="line">			<span class="built_in">avformat_close_input</span>(&amp;pFormatCtx);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pict) &#123;</span><br><span class="line">			<span class="built_in">avpicture_free</span>(pict);</span><br><span class="line">			<span class="built_in">free</span>(pict);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (win) &#123;</span><br><span class="line">			<span class="built_in">SDL_DestroyWindow</span>(win);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">			<span class="built_in">SDL_DestroyRenderer</span>(renderer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (texture) &#123;</span><br><span class="line">			<span class="built_in">SDL_DestroyTexture</span>(texture);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SDL_Quit</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img loading="lazy" data-src="/Users/huangqiuzhao/blog/source/_posts/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%BB%84%E7%A7%8B%E9%92%8A.jpg" alt="黄秋钊"></p>
<h4 id="多线程与锁音视频的同步"><a class="markdownIt-Anchor" href="#多线程与锁音视频的同步">#</a> 多线程与锁（音视频的同步）</h4>
<p>实现音视频同步的本质就是多线程之间的同步。</p>
<ul>
<li><code>SDL_CreateThread</code>  用于创建一个新的线程。它接受一个函数指针和一个指向函数参数的指针作为参数，然后创建一个新的线程来执行指定的函数，并将指定的参数传递给该函数。</li>
<li><code>SDL_WaitThread</code>  函数用于等待一个指定线程的结束。它接受一个指向线程的指针作为参数，并在该线程结束后返回。</li>
<li><code>SDL_CteateMutex/SDL_DestroyMutex</code>   <code>SDL_CreateMutex</code>  函数用于创建一个互斥锁（mutex），用于线程间的同步。而 <code>SDL_DestroyMutex</code>  函数用于销毁互斥锁。</li>
<li><code>SDL_LockMutex/SDL_UnlockMutex</code>   <code>SDL_LockMutex</code>  函数用于尝试锁定互斥锁，如果互斥锁已经被锁定，则该函数会阻塞直到锁可用。 <code>SDL_UnlockMutex</code>  函数用于释放已经锁定的互斥锁。</li>
<li><code>SDL_CreateCond/SDL_DestroyCond</code>   <code>SDL_CreateCond</code>  函数用于创建条件变量，而 <code>SDL_DestroyCond</code>  函数用于销毁条件变量。条件变量通常与互斥锁一起使用，用于在线程之间等待某个条件的发生或通知其他线程。</li>
<li><code>SDL_CondWait/SDL_CondSignal</code>   <code>SDL_CondWait</code>  函数用于等待条件变量的信号。当线程调用该函数时，它会阻塞并等待条件变量的信号。在等待期间，该函数会释放传入的互斥锁，以允许其他线程修改共享数据。一旦条件变量被另一个线程发送信号，当前线程将重新获取互斥锁并继续执行。 <code>SDL_CondSignal</code>  函数用于向等待某个条件的线程发送信号，通知它们条件已经满足，可以继续执行。这个函数通常与 <code>SDL_CondWait</code>  配合使用，用于唤醒一个等待该条件的线程。</li>
</ul>
<h4 id="播放器线程模型"><a class="markdownIt-Anchor" href="#播放器线程模型">#</a> 播放器线程模型</h4>
<p>![截屏 2024-05-11 16.50.12](/Users/huangqiuzhao/blog/source/_posts/ 音视频 / 截屏 2024-05-11 16.50.12.png)</p>
<p>一共有四个线程：</p>
<ol>
<li>主线程，主要用于一些参数的检查，事件的处理，视频的渲染，主线程会定时从视频解码队列中取出视频帧。</li>
<li>第二个线程，解复用线程，在这个线程中会创建一个视频解码线程，紧接着对多媒体文件进行解复用，将视频包存放在视频流队列，将音频包存放在音频流队列中</li>
<li>第三个线程是视频解码线程，首先去视频流队列中取出一个个视频包，进行解码，解码后的视频帧，存放在解码视频队列。</li>
<li>最后一个线程是 <code>SDL</code>  在打开音频设备时创建的，在这个线程中，它会调用我们的回调函数，最终时从音频队列中取出一个个音频包，进行解码，解码后就交给声卡。</li>
</ol>
<blockquote>
<p>为什么要进行重采样？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SwrContext</span> *audio_swr_ctx;</span><br></pre></td></tr></table></figure>
<p>这是因为我们的音频设备的音频参数是固定的（采样率、通道数、采样大小等等）。这些都是我们已经固定的。也就是我们一旦初始化音频设备以后，这些参数就不能改变了，而在多媒体文件中，他就存在各种各样的音频格式，比如采样大小，有的是 32 位的，有的是 16 位的，有的是浮点的，有的是非浮点的。最终放到我们的音频设备中，统一的播放出来，我们应该对音频进行重采样。将我们见到的所有的音频格式统一到一个格式中，也就是我们打开音频设备时定义的。</p>
</blockquote>
<h4 id="音视频同步"><a class="markdownIt-Anchor" href="#音视频同步">#</a> 音视频同步</h4>
<p><strong>时间戳</strong></p>
<ul>
<li>
<p><code>PTS (Presentation timestamp)</code>  ：表示在解码视频时应该在特定时间显示帧的时间戳。PTS 告诉解码器何时将帧呈现给用户，以确保视频按照正确的顺序和时间显示。PTS 通常以时间基为单位（例如，以毫秒为单位）进行表示。</p>
</li>
<li>
<p><code>DTS (Decoding timestamp)</code> ：指解码器开始解码帧的时间戳。它指示视频帧何时应该开始解码，以确保在正确的时间呈现帧。DTS 通常以时间基为单位（例如，以毫秒为单位）进行表示。 DTS 和 PTS 之间的差异可以表示解码器需要多长时间来解码视频帧。</p>
</li>
<li>
<p><code>I (intra) / B (bidirectional) / P (predicted) 帧</code>  ：视频编码中常见的帧类型。它们用于表示视频序列中的不同类型的帧。</p>
<ol>
<li>
<p>I 帧（Intra Frame）：I 帧是视频序列中的关键帧或帧间隔。每个 I 帧都是独立的，不依赖于其他帧。它包含完整的图像信息，可以作为其他帧的参考点。通常，视频序列的开始和切换点（例如场景变化）会包含 I 帧。</p>
</li>
<li>
<p>P 帧（Predicted Frame）：P 帧是通过对前向参考帧（通常是前一个 I 帧或 P 帧）进行运动补偿来编码的。它只包含自身与前一帧之间的差异信息。P 帧依赖于之前的帧进行解码，并且可以用来预测未来帧的内容。</p>
</li>
<li>
<p>B 帧（Bidirectional Frame）：B 帧是通过对前后两个参考帧（通常是前一个和后一个 I 帧或 P 帧）进行运动补偿来编码的。它包含自身与前后两个参考帧之间的差异信息。B 帧通常具有最高的压缩率，因为它可以利用未来和过去帧之间的关联来减少信息冗余。</p>
</li>
</ol>
<p>这些帧类型通常在视频编码标准（如 H.264 / AVC 或 H.265 / HEVC）中使用，并且在压缩视频时起着重要作用。</p>
</li>
</ul>
<p><strong>时间戳顺序</strong></p>
<p>实际帧顺序：  <code>I B B P</code></p>
<p>存放帧顺序：  <code>I P B B</code></p>
<p>解码时间戳：  <code>1 4 2 3</code>   <code>DTS</code></p>
<p>展示时间戳：  <code>1 2 3 4</code>   <code>PTS</code></p>
<p><strong>从哪里获得 PTS</strong></p>
<ul>
<li><code>AVPacket PTS</code></li>
<li><code>AVFrame PTS</code></li>
<li><code>av_frame_get_best_effort_timestamp()</code>  当  <code>PTS</code>  无效时，我们可以调用推算出合适的  <code>PTS</code></li>
</ul>
<p><strong>时间基</strong></p>
<ul>
<li><code>tbr</code>  : 帧率 指在视频中每秒显示的帧数。帧速率决定了视频的流畅度，更高的帧速率通常会产生更加流畅的视频效果。通常，帧速率以每秒帧数（fps）的形式表示。</li>
<li><code>tbn (time base of stream)</code> ：指流的时间基准（time base of stream），它表示流中时间单位的基准。在视频处理中，时间单位通常以分数形式表示，例如 1/1000 秒。这个时间基准用于确定时间戳的单位，以及在视频流中的时间度量。</li>
<li><code>tbc (time base of codec)</code> ：编解码器的时间基准（time base of codec），它是指编解码器内部使用的时间单位的基准。与流的时间基准不同，编解码器的时间基准可能与流的时间基准不同，尤其是在处理不同类型的视频或音频流时。编解码器的时间基准用于确定编码器内部时间单位的度量，通常以分数形式表示，例如 1/1000 秒。</li>
</ul>
<p><strong>计算当前帧的 PTS</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PTS = PTS * <span class="built_in">av_q2d</span>(video_stream-&gt;time_base);</span><br><span class="line"><span class="built_in">av_q2d</span>(AVRotional a) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.num / (<span class="type">double</span>)a.den;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算下一帧的 PTS</strong></p>
<p><code>video_clock</code> ：预测的下一帧视频的  <code>PTS</code>  上一帧的  <code>PTS</code>  加上  <code>frame_delay</code></p>
<p><code>frame_delay</code> ： <code>1 / tbr</code></p>
<p><code>audio_clock</code> ：音频当前播放的时间戳</p>
<p><strong>音视频同步方式</strong></p>
<ol>
<li>
<p>视频同步到音频：</p>
</li>
<li>
<p>音频同步到视频：</p>
</li>
<li>
<p>音频和视频都同步到系统时钟：</p>
</li>
</ol>
<p><strong>视频播放的基本思路</strong></p>
<p>一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的  <code>PTS</code>  ，然后设置一个定时器，当定时器超时后，刷新新的视频帧，如此反复操作。</p>
<h4 id="player"><a class="markdownIt-Anchor" href="#player">#</a> <strong>player</strong></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AVPacketList *pkt1;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">av_dup_packet</span>(pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pkt1 = <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVPacketList));</span><br><span class="line">  <span class="keyword">if</span> (!pkt1)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  pkt1-&gt;pkt = *pkt;</span><br><span class="line">  pkt1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">SDL_LockMutex</span>(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!q-&gt;last_pkt)</span><br><span class="line">    q-&gt;first_pkt = pkt1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class="line">  q-&gt;last_pkt = pkt1;</span><br><span class="line">  q-&gt;nb_packets++;</span><br><span class="line">  q-&gt;size += pkt1-&gt;pkt.size;</span><br><span class="line">  <span class="built_in">SDL_CondSignal</span>(q-&gt;cond);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">SDL_UnlockMutex</span>(q-&gt;mutex);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>packet_queue_put</code>  函数用于将一个数据包放入  <code>PacketQueue</code>  队列中。以下是该函数的详细解释：</p>
<h3 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a class="markdownIt-Anchor" href="#参数">#</a> 参数</h3>
<ul>
<li><code>PacketQueue *q</code> : 指向需要添加数据包的队列的指针。</li>
<li><code>AVPacket *pkt</code> : 需要添加到队列中的数据包指针。</li>
</ul>
<h3 id="函数流程"><a class="markdownIt-Anchor" href="#函数流程">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>复制数据包</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(av_dup_packet(pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用  <code>av_dup_packet</code>  函数复制一个数据包。如果复制失败，返回 -1。</p>
<ol start="2">
<li>
<p><strong>分配新节点</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVPacketList *pkt1;</span><br><span class="line">pkt1 = av_malloc(<span class="keyword">sizeof</span>(AVPacketList));</span><br><span class="line"><span class="keyword">if</span> (!pkt1)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>为新的数据包节点分配内存。如果分配失败，返回 -1。</p>
</li>
<li>
<p><strong>初始化新节点</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkt1-&gt;pkt = *pkt;</span><br><span class="line">pkt1-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>将传入的数据包内容复制到新分配的节点中，并将节点的  <code>next</code>  指针设为  <code>NULL</code> ，表示这是队列的末尾节点。</p>
</li>
<li>
<p><strong>锁定互斥锁</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_LockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将节点添加到队列</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!q-&gt;last_pkt)</span><br><span class="line">  q-&gt;first_pkt = pkt1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class="line">q-&gt;last_pkt = pkt1;</span><br><span class="line">q-&gt;nb_packets++;</span><br><span class="line">q-&gt;size += pkt1-&gt;pkt.size;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果队列为空（ <code>last_pkt</code>  为  <code>NULL</code> ），将  <code>first_pkt</code>  指向新节点。</li>
<li>否则，将当前队列的最后一个节点的  <code>next</code>  指针指向新节点。</li>
<li>更新  <code>last_pkt</code>  指向新节点。</li>
<li>增加队列中数据包的计数  <code>nb_packets</code> 。</li>
<li>增加队列的大小  <code>size</code> 。</li>
</ul>
</li>
<li>
<p><strong>发出条件信号</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_CondSignal(q-&gt;cond);</span><br></pre></td></tr></table></figure>
<p>通知等待该条件的线程，队列中有新的数据包可用。</p>
</li>
<li>
<p><strong>解锁互斥锁</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_UnlockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>返回成功</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用">#</a> 作用</h3>
<p><code>packet_queue_put</code>  函数将一个数据包添加到  <code>PacketQueue</code>  队列中，同时使用互斥锁和条件变量确保线程安全和同步。该函数在多线程音视频处理应用中非常重要，确保多个线程可以安全地访问和修改数据包队列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">  AVPacketList *pkt1;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  SDL_LockMutex(q-&gt;mutex);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(global_video_state-&gt;quit) &#123;</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkt1 = q-&gt;first_pkt;</span><br><span class="line">    <span class="keyword">if</span> (pkt1) &#123;</span><br><span class="line">      q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (!q-&gt;first_pkt)</span><br><span class="line">				q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">      q-&gt;nb_packets--;</span><br><span class="line">      q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class="line">      *pkt = pkt1-&gt;pkt;</span><br><span class="line">      av_free(pkt1);</span><br><span class="line">      ret = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">      ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>packet_queue_get</code>  函数用于从  <code>PacketQueue</code>  队列中获取一个数据包。以下是该函数的详细解释：</p>
<h3 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> block)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-2"><a class="markdownIt-Anchor" href="#参数-2">#</a> 参数</h3>
<ul>
<li><code>PacketQueue *q</code> : 指向要从中获取数据包的队列的指针。</li>
<li><code>AVPacket *pkt</code> : 指向接收数据包的指针。</li>
<li><code>int block</code> : 指示函数是否应该阻塞等待数据包的标志。非零值表示阻塞，零值表示非阻塞。</li>
</ul>
<h3 id="函数流程-2"><a class="markdownIt-Anchor" href="#函数流程-2">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVPacketList *pkt1;</span><br><span class="line"><span class="type">int</span> ret;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>锁定互斥锁</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_LockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>进入循环</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>检查全局退出标志</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(global_video_state-&gt;quit) &#123;</span><br><span class="line">  ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果全局状态  <code>global_video_state</code>  的  <code>quit</code>  标志被设置，则退出循环并返回 -1。</p>
</li>
<li>
<p><strong>获取队列中的第一个数据包</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkt1 = q-&gt;first_pkt;</span><br><span class="line"><span class="keyword">if</span> (pkt1) &#123;</span><br></pre></td></tr></table></figure>
<p>如果队列不为空，获取队列的第一个数据包。</p>
</li>
<li>
<p><strong>更新队列状态</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!q-&gt;first_pkt)</span><br><span class="line">  q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">q-&gt;nb_packets--;</span><br><span class="line">q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class="line">*pkt = pkt1-&gt;pkt;</span><br><span class="line">av_free(pkt1);</span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将队列的  <code>first_pkt</code>  指针更新为下一个节点。</li>
<li>如果队列现在为空（ <code>first_pkt</code>  为  <code>NULL</code> ），更新  <code>last_pkt</code>  为  <code>NULL</code> 。</li>
<li>更新队列中数据包的计数  <code>nb_packets</code>  和总大小  <code>size</code> 。</li>
<li>将获取的数据包内容复制到参数  <code>pkt</code>  指向的结构体中。</li>
<li>释放节点  <code>pkt1</code>  的内存。</li>
<li>设置返回值为 1 表示成功获取数据包，并退出循环。</li>
</ul>
</li>
<li>
<p><strong>处理队列为空的情况</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果队列为空且  <code>block</code>  标志为 0（非阻塞），设置返回值为 0 并退出循环。</li>
<li>如果  <code>block</code>  标志为非零（阻塞），等待条件变量  <code>q-&gt;cond</code> ，在有新数据包添加到队列时被唤醒。</li>
</ul>
</li>
<li>
<p><strong>解锁互斥锁</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_UnlockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>返回结果</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2">#</a> 作用</h3>
<p><code>packet_queue_get</code>  函数用于从  <code>PacketQueue</code>  队列中取出一个数据包。它使用互斥锁来确保线程安全，并根据  <code>block</code>  参数决定是否阻塞等待新数据包。该函数在多线程音视频处理应用中非常重要，确保多个线程可以安全地从数据包队列中获取数据包。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">get_audio_clock</span><span class="params">(VideoState* is)</span> &#123;</span><br><span class="line">	<span class="type">double</span> pts;</span><br><span class="line">	<span class="type">int</span> hw_buf_size, bytes_per_sec, n;</span><br><span class="line"></span><br><span class="line">	pts = is-&gt;audio_clock;</span><br><span class="line">	hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">	bytes_per_sec = <span class="number">0</span>;</span><br><span class="line">	n = is-&gt;audio_ctx-&gt;channels * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (is-&gt;audio_st) &#123;</span><br><span class="line">		bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bytes_per_sec) &#123;</span><br><span class="line">		pts -= (<span class="type">double</span>)hw_buf_size / bytes_per_sec;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>get_audio_clock</code>  函数用于计算和返回当前音频时钟的值。音频时钟是音视频同步中的一个关键因素，用于确保音频和视频的播放保持一致。以下是对该函数的详细解释：</p>
<h3 id="函数原型-3"><a class="markdownIt-Anchor" href="#函数原型-3">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">get_audio_clock</span><span class="params">(VideoState* is)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-3"><a class="markdownIt-Anchor" href="#参数-3">#</a> 参数</h3>
<ul>
<li><code>VideoState* is</code> : 指向管理视频播放状态的结构体  <code>VideoState</code>  的指针。</li>
</ul>
<h3 id="函数流程-3"><a class="markdownIt-Anchor" href="#函数流程-3">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pts;</span><br><span class="line"><span class="type">int</span> hw_buf_size, bytes_per_sec, n;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>获取当前音频时钟</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pts = is-&gt;audio_clock;</span><br></pre></td></tr></table></figure>
<p>将当前的音频时钟值赋给  <code>pts</code>  变量。 <code>is-&gt;audio_clock</code>  存储的是解码器更新的音频时钟。</p>
</li>
<li>
<p><strong>计算音频硬件缓冲区的大小</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br></pre></td></tr></table></figure>
<p><code>hw_buf_size</code>  计算的是音频硬件缓冲区中尚未播放的音频数据量。 <code>is-&gt;audio_buf_size</code>  是音频缓冲区的总大小， <code>is-&gt;audio_buf_index</code>  是当前缓冲区中已播放的位置。</p>
</li>
<li>
<p><strong>初始化每秒字节数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes_per_sec = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>初始化  <code>bytes_per_sec</code>  为 0。</p>
</li>
<li>
<p><strong>计算每个音频样本的字节数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = is-&gt;audio_ctx-&gt;channels * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>每个音频样本的字节数  <code>n</code>  由音频通道数乘以每个样本的字节数（假设每个样本是 16 位，即 2 字节）。</p>
</li>
<li>
<p><strong>计算每秒的字节数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;audio_st) &#123;</span><br><span class="line">    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果音频流存在（ <code>is-&gt;audio_st</code>  非空），则计算每秒的字节数  <code>bytes_per_sec</code> 。这是由音频采样率乘以每个音频样本的字节数得到的。</p>
</li>
<li>
<p><strong>调整音频时钟</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bytes_per_sec) &#123;</span><br><span class="line">    pts -= (<span class="type">double</span>)hw_buf_size / bytes_per_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果  <code>bytes_per_sec</code>  非零，则调整音频时钟  <code>pts</code> 。调整量是未播放的音频数据量（ <code>hw_buf_size</code> ）除以每秒的字节数（ <code>bytes_per_sec</code> ），这样可以得到未播放音频数据对应的时间，并从当前音频时钟中减去这个时间。</p>
</li>
<li>
<p><strong>返回调整后的音频时钟</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pts;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3">#</a> 作用</h3>
<p><code>get_audio_clock</code>  函数用于返回当前准确的音频时钟值，通过考虑音频硬件缓冲区中尚未播放的数据量来调整音频时钟。这样可以确保在播放过程中音频和视频的同步。这在多媒体应用中非常重要，尤其是需要保持音视频同步的场景下。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState* is, <span class="type">uint8_t</span>* audio_buf, <span class="type">int</span> buf_size, <span class="type">double</span>* pts_ptr)</span> &#123;</span><br><span class="line">	<span class="type">int</span> len1, data_size = <span class="number">0</span>;</span><br><span class="line">	AVPacket* pkt = &amp;is-&gt;audio_pkt;</span><br><span class="line">	<span class="type">double</span> pts;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">while</span> (is-&gt;audio_pkt_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">			len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);</span><br><span class="line">			<span class="keyword">if</span> (len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				is-&gt;audio_pkt_size = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			data_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">				data_size = <span class="number">2</span> * is-&gt;audio_frame.nb_samples * <span class="number">2</span>;</span><br><span class="line">				assert(data_size &lt;= buf_size);</span><br><span class="line">				swr_convert(is-&gt;audio_swr_ctx,</span><br><span class="line">					&amp;audio_buf,</span><br><span class="line">					MAX_AUDIO_FRAME_SIZE * <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">					(<span class="type">const</span> <span class="type">uint8_t</span> **)is-&gt;audio_frame.data,</span><br><span class="line">					is-&gt;audio_frame.nb_samples);</span><br><span class="line">			&#125;</span><br><span class="line">			is-&gt;audio_pkt_data += len1;</span><br><span class="line">			is-&gt;audio_pkt_size -= len1;</span><br><span class="line">			<span class="keyword">if</span> (data_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pts = is-&gt;audio_clock;</span><br><span class="line">			*pts_ptr = pts;</span><br><span class="line">			n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line">			is-&gt;audio_clock += (<span class="type">double</span>)data_size / (<span class="type">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">			<span class="keyword">return</span> data_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pkt-&gt;data) &#123;</span><br><span class="line">			av_free_packet(pkt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (is-&gt;quit) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		is-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class="line">		is-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">			is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base) * pkt-&gt;pts;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>audio_decode_frame</code>  函数用于从  <code>VideoState</code>  中解码音频数据，并将解码后的音频数据存储在  <code>audio_buf</code>  中，同时返回解码的音频帧大小，并更新音频时钟。以下是对该函数的详细解释：</p>
<h3 id="函数原型-4"><a class="markdownIt-Anchor" href="#函数原型-4">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState* is, <span class="type">uint8_t</span>* audio_buf, <span class="type">int</span> buf_size, <span class="type">double</span>* pts_ptr)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-4"><a class="markdownIt-Anchor" href="#参数-4">#</a> 参数</h3>
<ul>
<li><code>VideoState* is</code> : 指向管理视频播放状态的结构体  <code>VideoState</code>  的指针。</li>
<li><code>uint8_t* audio_buf</code> : 指向存储解码音频数据的缓冲区。</li>
<li><code>int buf_size</code> : 缓冲区  <code>audio_buf</code>  的大小。</li>
<li><code>double* pts_ptr</code> : 指向存储音频帧时间戳的指针。</li>
</ul>
<h3 id="函数流程-4"><a class="markdownIt-Anchor" href="#函数流程-4">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len1, data_size = <span class="number">0</span>;</span><br><span class="line">AVPacket* pkt = &amp;is-&gt;audio_pkt;</span><br><span class="line"><span class="type">double</span> pts;</span><br><span class="line"><span class="type">int</span> n;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>进入循环</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>处理音频数据包</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (is-&gt;audio_pkt_size &gt; <span class="number">0</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>当音频数据包中仍有未解码数据时，继续解码。</p>
</li>
<li>
<p><strong>解码音频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);</span><br><span class="line"><span class="keyword">if</span> (len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    is-&gt;audio_pkt_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">data_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用  <code>avcodec_decode_audio4</code>  解码音频数据包。如果解码失败，设置  <code>audio_pkt_size</code>  为 0 并退出循环。</li>
<li>如果解码成功， <code>len1</code>  是消耗的字节数， <code>got_frame</code>  表示是否成功解码出一个完整的音频帧。</li>
</ul>
</li>
<li>
<p><strong>处理解码后的音频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">    data_size = <span class="number">2</span> * is-&gt;audio_frame.nb_samples * <span class="number">2</span>;</span><br><span class="line">    assert(data_size &lt;= buf_size);</span><br><span class="line">    swr_convert(is-&gt;audio_swr_ctx,</span><br><span class="line">        &amp;audio_buf,</span><br><span class="line">        MAX_AUDIO_FRAME_SIZE * <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">        (<span class="type">const</span> <span class="type">uint8_t</span> **)is-&gt;audio_frame.data,</span><br><span class="line">        is-&gt;audio_frame.nb_samples);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果成功解码出一个音频帧，计算  <code>data_size</code> 。</li>
<li>使用  <code>swr_convert</code>  函数将音频帧数据转换并存储到  <code>audio_buf</code>  中。</li>
</ul>
</li>
<li>
<p><strong>更新数据包指针</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;audio_pkt_data += len1;</span><br><span class="line">is-&gt;audio_pkt_size -= len1;</span><br><span class="line"><span class="keyword">if</span> (data_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>更新音频时钟</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pts = is-&gt;audio_clock;</span><br><span class="line">*pts_ptr = pts;</span><br><span class="line">n = <span class="number">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class="line">is-&gt;audio_clock += (<span class="type">double</span>)data_size / (<span class="type">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line"><span class="keyword">return</span> data_size;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>释放数据包</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pkt-&gt;data) &#123;</span><br><span class="line">    av_free_packet(pkt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is-&gt;quit) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>读取下一个数据包</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class="line">is-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class="line"><span class="keyword">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base) * pkt-&gt;pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4">#</a> 作用</h3>
<p><code>audio_decode_frame</code>  函数用于从  <code>VideoState</code>  的音频包队列中解码音频数据并将其存储到  <code>audio_buf</code>  中。该函数在解码过程中更新音频时钟，并返回解码后的音频帧大小。该函数确保音频数据的解码和处理，包括对音频时钟的更新，这对于音视频同步非常重要。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">audio_callback</span><span class="params">(<span class="type">void</span> *userdata, Uint8 *stream, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	VideoState* is = (VideoState*)userdata;</span><br><span class="line">	<span class="type">int</span> len1, audio_size;</span><br><span class="line">	<span class="type">double</span> pts;</span><br><span class="line"></span><br><span class="line">	SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">			audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class="line">			<span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				is-&gt;audio_buf_size = <span class="number">1024</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">				<span class="built_in">memset</span>(is-&gt;audio_buf, <span class="number">0</span>, is-&gt;audio_buf_size);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				is-&gt;audio_buf_size = audio_size;</span><br><span class="line">			&#125;</span><br><span class="line">			is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">		<span class="keyword">if</span> (len1 &gt; len) &#123;</span><br><span class="line">			len1 = len;</span><br><span class="line">		&#125;</span><br><span class="line">		SDL_MixAudio(stream, (<span class="type">uint8_t</span>*)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br><span class="line">		len -= len1;</span><br><span class="line">		stream += len1;</span><br><span class="line">		is-&gt;audio_buf_index += len1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>audio_callback</code>  函数是音频回调函数，通常在多媒体播放中使用，用于将解码后的音频数据填充到音频输出缓冲区中。在使用 SDL 库进行音频播放时，会指定这个回调函数来处理音频数据。以下是对该函数的详细解释：</p>
<h3 id="函数原型-5"><a class="markdownIt-Anchor" href="#函数原型-5">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">audio_callback</span><span class="params">(<span class="type">void</span> *userdata, Uint8 *stream, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-5"><a class="markdownIt-Anchor" href="#参数-5">#</a> 参数</h3>
<ul>
<li><code>void *userdata</code> : 指向用户数据的指针，在此上下文中，它是一个  <code>VideoState</code>  结构体的指针。</li>
<li><code>Uint8 *stream</code> : 指向 SDL 音频输出缓冲区的指针，音频数据将被写入这个缓冲区。</li>
<li><code>int len</code> : 要填充的音频数据的长度，以字节为单位。</li>
</ul>
<h3 id="函数流程-5"><a class="markdownIt-Anchor" href="#函数流程-5">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>获取  <code>VideoState</code>  结构体的指针</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VideoState* is = (VideoState*)userdata;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len1, audio_size;</span><br><span class="line"><span class="type">double</span> pts;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>清空输出缓冲区</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_memset(stream, <span class="number">0</span>, len);</span><br></pre></td></tr></table></figure>
<p>使用  <code>SDL_memset</code>  函数将输出缓冲区  <code>stream</code>  清零，确保缓冲区内没有旧的音频数据。</p>
</li>
<li>
<p><strong>循环填充音频数据</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>检查并解码新的音频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">    audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class="line">    <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        is-&gt;audio_buf_size = <span class="number">1024</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memset</span>(is-&gt;audio_buf, <span class="number">0</span>, is-&gt;audio_buf_size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        is-&gt;audio_buf_size = audio_size;</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果音频缓冲区中没有未播放的数据（ <code>audio_buf_index</code>  超过  <code>audio_buf_size</code> ），则调用  <code>audio_decode_frame</code>  函数解码新的音频帧。</li>
<li>如果解码失败，设定一个默认缓冲区大小并清零缓冲区。</li>
<li>如果解码成功，更新缓冲区大小。</li>
<li>重置  <code>audio_buf_index</code>  为 0。</li>
</ul>
</li>
<li>
<p><strong>计算需要拷贝的数据长度</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line"><span class="keyword">if</span> (len1 &gt; len) &#123;</span><br><span class="line">    len1 = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>计算当前缓冲区中未播放的数据长度  <code>len1</code> 。</li>
<li>如果  <code>len1</code>  大于剩余要填充的长度  <code>len</code> ，则只填充  <code>len</code>  的长度。</li>
</ul>
</li>
<li>
<p><strong>将音频数据拷贝到输出缓冲区</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_MixAudio(stream, (<span class="type">uint8_t</span>*)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br></pre></td></tr></table></figure>
<p>使用  <code>SDL_MixAudio</code>  函数将音频数据从  <code>audio_buf</code>  拷贝到  <code>stream</code> ，并混音。</p>
</li>
<li>
<p><strong>更新剩余长度和指针</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len -= len1;</span><br><span class="line">stream += len1;</span><br><span class="line">is-&gt;audio_buf_index += len1;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用-5"><a class="markdownIt-Anchor" href="#作用-5">#</a> 作用</h3>
<p><code>audio_callback</code>  函数在音频设备需要更多数据时被调用。它从  <code>VideoState</code>  结构体中获取音频数据，将其解码并填充到 SDL 提供的音频缓冲区中。这保证了音频流的连续性和正确性，确保音频播放平滑且无间断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Uint32 <span class="title function_">sdl_refresh_timer_cb</span><span class="params">(Uint32 interval, <span class="type">void</span>* opaque)</span> &#123;</span><br><span class="line">	SDL_Event event;</span><br><span class="line">	event.type = FF_REFRESH_EVENT;</span><br><span class="line">	event.user.data1 = opaque;</span><br><span class="line">	SDL_PushEvent(&amp;event);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个函数  <code>sdl_refresh_timer_cb</code>  是一个 SDL 定时器回调函数，用于向 SDL 事件队列中推送一个自定义事件，从而触发后续的事件处理。以下是对该函数的详细解释：</p>
<h3 id="函数原型-6"><a class="markdownIt-Anchor" href="#函数原型-6">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Uint32 <span class="title function_">sdl_refresh_timer_cb</span><span class="params">(Uint32 interval, <span class="type">void</span>* opaque)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-6"><a class="markdownIt-Anchor" href="#参数-6">#</a> 参数</h3>
<ul>
<li><code>Uint32 interval</code> : 定时器的间隔时间，单位是毫秒。</li>
<li><code>void* opaque</code> : 一个指向用户数据的指针，可以是任何类型的数据。在这个上下文中，它通常用于传递状态信息或上下文。</li>
</ul>
<h3 id="函数流程-6"><a class="markdownIt-Anchor" href="#函数流程-6">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义一个 SDL 事件</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_Event event;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **设置事件类型**：</span><br><span class="line">   ```c</span><br><span class="line">   event.type = FF_REFRESH_EVENT;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FF_REFRESH_EVENT</code>  是一个自定义的 SDL 事件类型，通常是通过  <code>#define</code>  语句定义的。</li>
<li>例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT + 1)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>
<p><strong>设置事件数据</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.user.data1 = opaque;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>event.user.data1</code>  是一个  <code>void*</code>  类型的数据指针，可以存储传入的用户数据  <code>opaque</code> 。</li>
</ul>
</li>
</ol>
<ul>
<li>这允许在事件处理函数中访问这个用户数据。</li>
</ul>
<ol start="4">
<li>
<p><strong>将事件推送到 SDL 事件队列</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_PushEvent(&amp;event);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用  <code>SDL_PushEvent</code>  函数将定义好的事件推送到 SDL 事件队列中。</li>
<li>这会触发事件处理机制，从而在事件循环中处理这个自定义事件。</li>
</ul>
</li>
<li>
<p><strong>返回值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>定时器回调函数返回 0 表示一次性定时器，即不再重复触发。如果希望定时器重复触发，可以返回  <code>interval</code>  的值。</li>
</ul>
</li>
</ol>
<h3 id="作用-6"><a class="markdownIt-Anchor" href="#作用-6">#</a> 作用</h3>
<p><code>sdl_refresh_timer_cb</code>  函数的主要作用是创建并推送一个自定义的刷新事件到 SDL 事件队列中，以触发后续的图像刷新或其他需要处理的任务。这个机制常用于视频播放或其他需要定时刷新界面的应用中。</p>
<h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景">#</a> 使用场景</h3>
<p>假设在视频播放应用中，我们希望定期刷新视频帧。我们可以设置一个 SDL 定时器，当定时器超时时，调用  <code>sdl_refresh_timer_cb</code>  推送一个刷新事件，然后在事件循环中处理这个事件，更新视频显示。这样可以确保视频播放的平滑性和同步性。</p>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例">#</a> 示例</h3>
<p>以下是一个可能的使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义自定义事件类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器</span></span><br><span class="line">SDL_AddTimer(<span class="number">40</span>, sdl_refresh_timer_cb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件循环中处理刷新事件</span></span><br><span class="line">SDL_Event event;</span><br><span class="line"><span class="keyword">while</span> (SDL_WaitEvent(&amp;event)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type == FF_REFRESH_EVENT) &#123;</span><br><span class="line">        <span class="comment">// 调用刷新函数，例如刷新视频帧</span></span><br><span class="line">        refresh_video_frame();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，每 40 毫秒触发一次  <code>sdl_refresh_timer_cb</code> ，该函数向事件队列推送  <code>FF_REFRESH_EVENT</code>  事件，从而定期刷新视频帧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">video_display</span><span class="params">(VideoState *is)</span> &#123;</span><br><span class="line"></span><br><span class="line">  SDL_Rect rect;</span><br><span class="line">  VideoPicture *vp;</span><br><span class="line">  <span class="type">float</span> aspect_ratio;</span><br><span class="line">  <span class="type">int</span> w, h, x, y;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line">  <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line"></span><br><span class="line">    SDL_UpdateYUVTexture( texture, <span class="literal">NULL</span>,</span><br><span class="line">                          vp-&gt;bmp-&gt;data[<span class="number">0</span>], vp-&gt;bmp-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                          vp-&gt;bmp-&gt;data[<span class="number">1</span>], vp-&gt;bmp-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                          vp-&gt;bmp-&gt;data[<span class="number">2</span>], vp-&gt;bmp-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    rect.x = <span class="number">0</span>;</span><br><span class="line">    rect.y = <span class="number">0</span>;</span><br><span class="line">    rect.w = is-&gt;video_ctx-&gt;width;</span><br><span class="line">    rect.h = is-&gt;video_ctx-&gt;height;</span><br><span class="line">    SDL_LockMutex(text_mutex);</span><br><span class="line">    SDL_RenderClear( renderer );</span><br><span class="line">    SDL_RenderCopy( renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">    SDL_RenderPresent( renderer );</span><br><span class="line">    SDL_UnlockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>video_display</code>  函数用于在 SDL 窗口中显示视频帧。以下是对该函数的详细解释：</p>
<h3 id="函数原型-7"><a class="markdownIt-Anchor" href="#函数原型-7">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">video_display</span><span class="params">(VideoState *is)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-7"><a class="markdownIt-Anchor" href="#参数-7">#</a> 参数</h3>
<ul>
<li><code>VideoState *is</code> : 指向视频状态的指针，包含了视频播放所需的所有信息和状态。</li>
</ul>
<h3 id="函数流程-7"><a class="markdownIt-Anchor" href="#函数流程-7">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_Rect rect;</span><br><span class="line">VideoPicture *vp;</span><br><span class="line"><span class="type">float</span> aspect_ratio;</span><br><span class="line"><span class="type">int</span> w, h, x, y;</span><br><span class="line"><span class="type">int</span> i;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>获取当前显示的图片帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br></pre></td></tr></table></figure>
<ul>
<li>从  <code>VideoState</code>  的  <code>pictq</code>  队列中获取当前要显示的视频帧。</li>
<li><code>is-&gt;pictq_rindex</code>  是当前要显示的图片帧在队列中的索引。</li>
</ul>
</li>
<li>
<p><strong>检查视频帧是否有数据</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vp-&gt;bmp</code>  是一个指向  <code>AVFrame</code>  的指针，包含了 YUV 格式的视频数据。</li>
<li>如果  <code>vp-&gt;bmp</code>  不为空，说明有视频帧需要显示。</li>
</ul>
</li>
<li>
<p><strong>更新 YUV 纹理</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_UpdateYUVTexture(texture, <span class="literal">NULL</span>,</span><br><span class="line">                     vp-&gt;bmp-&gt;data[<span class="number">0</span>], vp-&gt;bmp-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                     vp-&gt;bmp-&gt;data[<span class="number">1</span>], vp-&gt;bmp-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                     vp-&gt;bmp-&gt;data[<span class="number">2</span>], vp-&gt;bmp-&gt;linesize[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用  <code>SDL_UpdateYUVTexture</code>  函数将  <code>AVFrame</code>  中的 YUV 数据更新到 SDL 纹理  <code>texture</code>  中。</li>
</ul>
</li>
<li>
<p><strong>设置显示矩形</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect.x = <span class="number">0</span>;</span><br><span class="line">rect.y = <span class="number">0</span>;</span><br><span class="line">rect.w = is-&gt;video_ctx-&gt;width;</span><br><span class="line">rect.h = is-&gt;video_ctx-&gt;height;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置显示区域  <code>rect</code> ，使其大小与视频的宽高一致。</li>
</ul>
</li>
<li>
<p><strong>绘制视频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_LockMutex(text_mutex);</span><br><span class="line">SDL_RenderClear(renderer);</span><br><span class="line">SDL_RenderCopy(renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">SDL_RenderPresent(renderer);</span><br><span class="line">SDL_UnlockMutex(text_mutex);</span><br></pre></td></tr></table></figure>
<ul>
<li>锁定互斥锁  <code>text_mutex</code> ，以确保线程安全。</li>
<li>清除渲染器  <code>renderer</code> 。</li>
<li>使用  <code>SDL_RenderCopy</code>  函数将更新后的纹理  <code>texture</code>  复制到渲染器  <code>renderer</code> ，并按  <code>rect</code>  定义的位置和大小显示。</li>
<li>使用  <code>SDL_RenderPresent</code>  函数将渲染器内容显示到窗口中。</li>
<li>解锁互斥锁  <code>text_mutex</code> 。</li>
</ul>
</li>
</ol>
<h3 id="作用-7"><a class="markdownIt-Anchor" href="#作用-7">#</a> 作用</h3>
<p><code>video_display</code>  函数的主要作用是将解码后的视频帧显示在 SDL 窗口中。通过从  <code>VideoState</code>  的图片队列中获取当前帧，然后使用 SDL 提供的函数将 YUV 数据更新到纹理中，再通过渲染器显示到窗口上，从而实现视频播放功能。</p>
<h3 id="使用场景-2"><a class="markdownIt-Anchor" href="#使用场景-2">#</a> 使用场景</h3>
<p><code>video_display</code>  函数通常在视频播放应用中使用，它被定期调用以刷新视频显示。可以在事件循环中或定时器回调中调用这个函数，以确保视频帧按正确的时间间隔显示。</p>
<h3 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2">#</a> 示例</h3>
<p>在实际使用中， <code>video_display</code>  函数可能在一个事件处理或定时器回调中调用，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">on_video_refresh</span><span class="params">(VideoState* is)</span> &#123;</span><br><span class="line">    video_display(is);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件循环中处理自定义刷新事件</span></span><br><span class="line">SDL_Event event;</span><br><span class="line"><span class="keyword">while</span> (SDL_WaitEvent(&amp;event)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type == FF_REFRESH_EVENT) &#123;</span><br><span class="line">        on_video_refresh((VideoState*)event.user.data1);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，可以实现视频帧的定时刷新和显示，确保视频播放的平滑和同步。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">video_refresh_timer</span><span class="params">(<span class="type">void</span> *userdata)</span> &#123;</span><br><span class="line"></span><br><span class="line">  VideoState *is = (VideoState *)userdata;</span><br><span class="line">  VideoPicture *vp;</span><br><span class="line">  <span class="type">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(is-&gt;video_st) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">      schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line"></span><br><span class="line">      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="comment">/* the pts from last time */</span></span><br><span class="line">      <span class="keyword">if</span>(delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">	<span class="comment">/* if incorrect delay, use previous one */</span></span><br><span class="line">	delay = is-&gt;frame_last_delay;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* save for next time */</span></span><br><span class="line">      is-&gt;frame_last_delay = delay;</span><br><span class="line">      is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* update delay to sync to audio */</span></span><br><span class="line">      ref_clock = get_audio_clock(is);</span><br><span class="line">      diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip or repeat the frame. Take delay into account</span></span><br><span class="line"><span class="comment">	 FFPlay still doesn&#x27;t &quot;know if this is the best guess.&quot; */</span></span><br><span class="line">      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">	<span class="keyword">if</span>(diff &lt;= -sync_threshold) &#123;</span><br><span class="line">	  delay = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt;= sync_threshold) &#123;</span><br><span class="line">	  delay = <span class="number">2</span> * delay;</span><br><span class="line">	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;frame_timer += delay;</span><br><span class="line">      <span class="comment">/* computer the REAL delay */</span></span><br><span class="line">      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">      <span class="keyword">if</span>(actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">	<span class="comment">/* Really it should skip the picture instead */</span></span><br><span class="line">	actual_delay = <span class="number">0.010</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      schedule_refresh(is, (<span class="type">int</span>)(actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* show the picture! */</span></span><br><span class="line">      video_display(is);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* update queue for next picture! */</span></span><br><span class="line">      <span class="keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">	is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">      is-&gt;pictq_size--;</span><br><span class="line">      SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">      SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>video_refresh_timer</code>  函数负责定期刷新视频帧，并确保视频帧与音频同步显示。以下是对该函数的详细解释：</p>
<h3 id="函数原型-8"><a class="markdownIt-Anchor" href="#函数原型-8">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">video_refresh_timer</span><span class="params">(<span class="type">void</span> *userdata)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-8"><a class="markdownIt-Anchor" href="#参数-8">#</a> 参数</h3>
<ul>
<li><code>void *userdata</code> : 指向  <code>VideoState</code>  结构的指针，包含了视频播放所需的所有信息和状态。</li>
</ul>
<h3 id="函数流程-8"><a class="markdownIt-Anchor" href="#函数流程-8">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VideoState *is = (VideoState *)userdata;</span><br><span class="line">VideoPicture *vp;</span><br><span class="line"><span class="type">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>检查是否有视频流</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(is-&gt;video_st) &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断  <code>is</code>  中是否有视频流。</li>
</ul>
</li>
<li>
<p><strong>检查图片队列是否为空</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">  schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果图片队列为空，则调度下次刷新（1 毫秒后），并返回。</li>
</ul>
</li>
<li>
<p><strong>获取当前要显示的视频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>计算当前帧的显示延迟</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="comment">/* the pts from last time */</span></span><br><span class="line"><span class="keyword">if</span>(delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">  delay = is-&gt;frame_last_delay;</span><br><span class="line">&#125;</span><br><span class="line">is-&gt;frame_last_delay = delay;</span><br><span class="line">is-&gt;frame_last_pts = vp-&gt;pts;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>同步音频和视频</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ref_clock = get_audio_clock(is);</span><br><span class="line">diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">  <span class="keyword">if</span>(diff &lt;= -sync_threshold) &#123;</span><br><span class="line">    delay = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt;= sync_threshold) &#123;</span><br><span class="line">    delay = <span class="number">2</span> * delay;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">is-&gt;frame_timer += delay;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>计算实际延迟</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="keyword">if</span>(actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">  actual_delay = <span class="number">0.010</span>;</span><br><span class="line">&#125;</span><br><span class="line">schedule_refresh(is, (<span class="type">int</span>)(actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>显示视频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video_display(is);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>更新图片队列</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">  is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">is-&gt;pictq_size--;</span><br><span class="line">SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>处理没有视频流的情况</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用-8"><a class="markdownIt-Anchor" href="#作用-8">#</a> 作用</h3>
<p><code>video_refresh_timer</code>  函数的主要作用是定期刷新视频帧，同时确保视频帧与音频的同步。通过计算帧的显示延迟，并根据音频时钟调整帧的显示时间，从而实现音视频同步播放。</p>
<h3 id="使用场景-3"><a class="markdownIt-Anchor" href="#使用场景-3">#</a> 使用场景</h3>
<p><code>video_refresh_timer</code>  函数通常在视频播放应用中使用，它通过定时器或事件循环定期调用，以确保视频帧按正确的时间间隔显示，同时与音频保持同步。</p>
<h3 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3">#</a> 示例</h3>
<p>在实际使用中， <code>video_refresh_timer</code>  函数可能通过定时器或事件回调机制调用，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Uint32 <span class="title function_">sdl_refresh_timer_cb</span><span class="params">(Uint32 interval, <span class="type">void</span>* opaque)</span> &#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = FF_REFRESH_EVENT;</span><br><span class="line">    event.user.data1 = opaque;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件循环中处理自定义刷新事件</span></span><br><span class="line">SDL_Event event;</span><br><span class="line"><span class="keyword">while</span> (SDL_WaitEvent(&amp;event)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type == FF_REFRESH_EVENT) &#123;</span><br><span class="line">        video_refresh_timer(event.user.data1);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，可以实现视频帧的定时刷新和显示，确保视频播放的平滑和同步。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">alloc_picture</span><span class="params">(<span class="type">void</span> *userdata)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  VideoState *is = (VideoState *)userdata;</span><br><span class="line">  VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line">  <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we already have one make another, bigger/smaller</span></span><br><span class="line">    avpicture_free(vp-&gt;bmp);</span><br><span class="line">    <span class="built_in">free</span>(vp-&gt;bmp);</span><br><span class="line"></span><br><span class="line">    vp-&gt;bmp = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a place to put our YUV image on that screen</span></span><br><span class="line">  SDL_LockMutex(text_mutex);</span><br><span class="line">  vp-&gt;bmp = (AVPicture*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVPicture));</span><br><span class="line">  ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate temporary picture: %s\n&quot;</span>, av_err2str(ret));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SDL_UnlockMutex(text_mutex);</span><br><span class="line"></span><br><span class="line">  vp-&gt;width = is-&gt;video_ctx-&gt;width;</span><br><span class="line">  vp-&gt;height = is-&gt;video_ctx-&gt;height;</span><br><span class="line">  vp-&gt;allocated = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>alloc_picture</code>  函数负责分配视频帧存储空间，并处理与视频帧队列相关的内存管理。以下是对该函数的详细解释：</p>
<h3 id="函数原型-9"><a class="markdownIt-Anchor" href="#函数原型-9">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">alloc_picture</span><span class="params">(<span class="type">void</span> *userdata)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-9"><a class="markdownIt-Anchor" href="#参数-9">#</a> 参数</h3>
<ul>
<li><code>void *userdata</code> : 指向  <code>VideoState</code>  结构的指针，包含了视频播放所需的所有信息和状态。</li>
</ul>
<h3 id="函数流程-9"><a class="markdownIt-Anchor" href="#函数流程-9">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">VideoState *is = (VideoState *)userdata;</span><br><span class="line">VideoPicture *vp;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>获取当前写入队列中的视频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>检查当前视频帧是否已经分配过内存</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line">  <span class="comment">// we already have one make another, bigger/smaller</span></span><br><span class="line">  avpicture_free(vp-&gt;bmp);</span><br><span class="line">  <span class="built_in">free</span>(vp-&gt;bmp);</span><br><span class="line">  vp-&gt;bmp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>分配内存</strong>：</p>
<ul>
<li><strong>锁定互斥量以避免多线程冲突</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_LockMutex(text_mutex);</span><br></pre></td></tr></table></figure>
</li>
<li><strong>分配  <code>AVPicture</code>  结构体</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vp-&gt;bmp = (AVPicture*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVPicture));</span><br></pre></td></tr></table></figure>
</li>
<li><strong>为  <code>AVPicture</code>  结构体分配内存，用于存储 YUV 图像</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate temporary picture: %s\n&quot;</span>, av_err2str(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>解锁互斥量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_UnlockMutex(text_mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>更新  <code>VideoPicture</code>  结构体中的相关字段</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vp-&gt;width = is-&gt;video_ctx-&gt;width;</span><br><span class="line">vp-&gt;height = is-&gt;video_ctx-&gt;height;</span><br><span class="line">vp-&gt;allocated = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用-9"><a class="markdownIt-Anchor" href="#作用-9">#</a> 作用</h3>
<p><code>alloc_picture</code>  函数的主要作用是为  <code>VideoPicture</code>  分配内存，以便存储解码后的视频帧。它会根据当前视频的宽度和高度分配合适的内存，并确保多线程环境下的内存安全。</p>
<h3 id="使用场景-4"><a class="markdownIt-Anchor" href="#使用场景-4">#</a> 使用场景</h3>
<p><code>alloc_picture</code>  函数通常在视频播放的初始化阶段调用，或者在需要调整视频帧的存储空间时调用，例如视频尺寸发生变化时。</p>
<h3 id="示例-4"><a class="markdownIt-Anchor" href="#示例-4">#</a> 示例</h3>
<p>在视频解码和播放过程中，当需要为新的视频帧分配内存时，可以调用  <code>alloc_picture</code>  函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在初始化视频播放时，调用 alloc_picture 为每个 VideoPicture 分配内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VIDEO_PICTURE_QUEUE_SIZE; i++) &#123;</span><br><span class="line">    alloc_picture(video_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在视频尺寸发生变化时，重新分配内存</span></span><br><span class="line"><span class="keyword">if</span> (new_width != video_state-&gt;video_ctx-&gt;width || new_height != video_state-&gt;video_ctx-&gt;height) &#123;</span><br><span class="line">    alloc_picture(video_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，可以确保每个  <code>VideoPicture</code>  都有足够的内存来存储解码后的视频帧，确保视频播放的顺畅性和稳定性。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">queue_picture</span><span class="params">(VideoState *is, AVFrame *pFrame, <span class="type">double</span> pts)</span> &#123;</span><br><span class="line"></span><br><span class="line">  VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* wait until we have space for a new pic */</span></span><br><span class="line">  SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">  <span class="keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;</span><br><span class="line">	!is-&gt;quit) &#123;</span><br><span class="line">    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(is-&gt;quit)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// windex is set to 0 initially</span></span><br><span class="line">  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* allocate or resize the buffer! */</span></span><br><span class="line">  <span class="keyword">if</span>(!vp-&gt;bmp ||</span><br><span class="line">     vp-&gt;width != is-&gt;video_ctx-&gt;width ||</span><br><span class="line">     vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123;</span><br><span class="line"></span><br><span class="line">    vp-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">    alloc_picture(is);</span><br><span class="line">    <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have a place to put our picture on the queue */</span></span><br><span class="line">  <span class="keyword">if</span>(vp-&gt;bmp) &#123;</span><br><span class="line"></span><br><span class="line">    vp-&gt;pts = pts;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Convert the image into YUV format that SDL uses</span></span><br><span class="line">    sws_scale(is-&gt;video_sws_ctx, (<span class="type">uint8_t</span> <span class="type">const</span> * <span class="type">const</span> *)pFrame-&gt;data,</span><br><span class="line">	      pFrame-&gt;linesize, <span class="number">0</span>, is-&gt;video_ctx-&gt;height,</span><br><span class="line">	      vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* now we inform our display thread that we have a pic ready */</span></span><br><span class="line">    <span class="keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">      is-&gt;pictq_windex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    is-&gt;pictq_size++;</span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>queue_picture</code>  函数用于将解码后的视频帧添加到视频帧队列中，以便在合适的时间进行显示。以下是对该函数的详细解释：</p>
<h3 id="函数原型-10"><a class="markdownIt-Anchor" href="#函数原型-10">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">queue_picture</span><span class="params">(VideoState *is, AVFrame *pFrame, <span class="type">double</span> pts)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-10"><a class="markdownIt-Anchor" href="#参数-10">#</a> 参数</h3>
<ul>
<li><code>VideoState *is</code> : 指向  <code>VideoState</code>  结构的指针，包含视频播放所需的所有信息和状态。</li>
<li><code>AVFrame *pFrame</code> : 解码后的视频帧。</li>
<li><code>double pts</code> : 帧的展示时间戳 (Presentation Timestamp)。</li>
</ul>
<h3 id="返回值"><a class="markdownIt-Anchor" href="#返回值">#</a> 返回值</h3>
<ul>
<li><code>int</code> : 如果队列操作成功返回 0，出现错误或用户请求退出时返回 -1。</li>
</ul>
<h3 id="函数流程-10"><a class="markdownIt-Anchor" href="#函数流程-10">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>定义局部变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VideoPicture *vp;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>等待队列有空间</strong>：</p>
<ul>
<li>锁定互斥量以确保线程安全。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_LockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>如果队列已满且程序未退出，则等待条件变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp; !is-&gt;quit) &#123;</span><br><span class="line">  SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>解锁互斥量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **检查程序是否请求退出**：</span><br><span class="line">   ```c</span><br><span class="line">   if(is-&gt;quit)</span><br><span class="line">     return -1;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p><strong>获取当前写入队列中的视频帧</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. **分配或调整缓冲区**：</span><br><span class="line"></span><br><span class="line">   - 如果 `VideoPicture` 没有分配内存或尺寸不匹配，则重新分配内存。</span><br><span class="line">     ```c</span><br><span class="line">     if(!vp-&gt;bmp || vp-&gt;width != is-&gt;video_ctx-&gt;width || vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123;</span><br><span class="line">       vp-&gt;allocated = 0;</span><br><span class="line">       alloc_picture(is);</span><br><span class="line">       if(is-&gt;quit) &#123;</span><br><span class="line">         return -1;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>
<p><strong>将解码后的帧转换为 YUV 格式并存储到队列</strong>：</p>
<ul>
<li>设置帧的展示时间戳。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vp-&gt;pts = pts;</span><br></pre></td></tr></table></figure>
</li>
<li>使用  <code>sws_scale</code>  将图像转换为 SDL 使用的 YUV 格式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sws_scale(is-&gt;video_sws_ctx, (<span class="type">uint8_t</span> <span class="type">const</span> * <span class="type">const</span> *)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, is-&gt;video_ctx-&gt;height, vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. **更新写入索引并通知显示线程**：</span><br><span class="line"></span><br><span class="line">   - 更新写入索引。</span><br><span class="line">     ```c</span><br><span class="line">     if(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">       is-&gt;pictq_windex = 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>锁定互斥量并更新队列大小，通知条件变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">is-&gt;pictq_size++;</span><br><span class="line">SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">8. **返回成功状态**：</span><br><span class="line">   ```c</span><br><span class="line">   return 0;</span><br></pre></td></tr></table></figure>
<h3 id="作用-10"><a class="markdownIt-Anchor" href="#作用-10">#</a> 作用</h3>
<p><code>queue_picture</code>  函数的主要作用是将解码后的视频帧添加到显示队列中，并确保在多线程环境下操作的线程安全。它负责将帧转换为 SDL 可处理的格式，并在队列有空间时将帧插入队列，供显示线程进行展示。</p>
<h3 id="使用场景-5"><a class="markdownIt-Anchor" href="#使用场景-5">#</a> 使用场景</h3>
<p>该函数通常在视频解码后的流程中调用，用于将解码后的帧加入到待显示的队列中。例如，在解码线程中，当解码出一个新的视频帧时，可以调用  <code>queue_picture</code>  将该帧加入显示队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!is-&gt;quit) &#123;</span><br><span class="line">    AVFrame* frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (avcodec_receive_frame(is-&gt;video_ctx, frame) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">double</span> pts = av_frame_get_best_effort_timestamp(frame);</span><br><span class="line">        queue_picture(is, frame, pts);</span><br><span class="line">    &#125;</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，确保每个解码后的视频帧都能按照正确的时间顺序被显示，保证视频播放的连续性和同步性。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">synchronize_video</span><span class="params">(VideoState *is, AVFrame *src_frame, <span class="type">double</span> pts)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> frame_delay;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pts != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* if we have pts, set video clock to it */</span></span><br><span class="line">    is-&gt;video_clock = pts;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if we aren&#x27;t given a pts, set it to the clock */</span></span><br><span class="line">    pts = is-&gt;video_clock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* update the video clock */</span></span><br><span class="line">  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);</span><br><span class="line">  <span class="comment">/* if we are repeating a frame, adjust clock accordingly */</span></span><br><span class="line">  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br><span class="line">  is-&gt;video_clock += frame_delay;</span><br><span class="line">  <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>synchronize_video</code>  函数用于同步视频帧的时间戳 (PTS, Presentation Timestamp) 和视频时钟，确保视频播放的同步性。以下是对该函数的详细解释：</p>
<h3 id="函数原型-11"><a class="markdownIt-Anchor" href="#函数原型-11">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">synchronize_video</span><span class="params">(VideoState *is, AVFrame *src_frame, <span class="type">double</span> pts)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-11"><a class="markdownIt-Anchor" href="#参数-11">#</a> 参数</h3>
<ul>
<li><code>VideoState *is</code> : 指向  <code>VideoState</code>  结构的指针，包含视频播放所需的所有信息和状态。</li>
<li><code>AVFrame *src_frame</code> : 当前解码的视频帧。</li>
<li><code>double pts</code> : 视频帧的展示时间戳。如果没有有效的时间戳，则为 0。</li>
</ul>
<h3 id="返回值-2"><a class="markdownIt-Anchor" href="#返回值-2">#</a> 返回值</h3>
<ul>
<li><code>double</code> : 更新后的时间戳，用于同步视频时钟。</li>
</ul>
<h3 id="函数流程-11"><a class="markdownIt-Anchor" href="#函数流程-11">#</a> 函数流程</h3>
<ol>
<li>
<p><strong>检查时间戳是否有效</strong>：</p>
<ul>
<li>如果提供了有效的 PTS，则将视频时钟设置为该时间戳。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pts != <span class="number">0</span>) &#123;</span><br><span class="line">  is-&gt;video_clock = pts;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 如果没有提供有效的 PTS，则使用视频时钟的当前值 */</span></span><br><span class="line">  pts = is-&gt;video_clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>更新视频时钟</strong>：</p>
<ul>
<li>计算当前帧的显示延迟。 <code>frame_delay</code>  是根据帧率计算的基本时间间隔。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);</span><br></pre></td></tr></table></figure>
</li>
<li>如果帧有重复字段，调整时间延迟。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>更新视频时钟，增加帧延迟以反映下一帧的预期显示时间。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;video_clock += frame_delay;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>返回同步后的时间戳</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pts;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用-11"><a class="markdownIt-Anchor" href="#作用-11">#</a> 作用</h3>
<p><code>synchronize_video</code>  函数的主要作用是同步视频帧的时间戳和视频时钟，确保视频帧按照正确的时间顺序显示。该函数在以下情况下使用：</p>
<ul>
<li>当解码器提供了有效的 PTS 时，更新视频时钟。</li>
<li>当解码器未提供有效的 PTS 时，使用当前视频时钟的值。</li>
<li>根据帧率和重复字段调整视频时钟，以反映正确的显示时间。</li>
</ul>
<h3 id="使用场景-6"><a class="markdownIt-Anchor" href="#使用场景-6">#</a> 使用场景</h3>
<p>该函数通常在解码线程或视频显示线程中调用，用于确保每个解码后的视频帧都能按照正确的时间顺序被显示，保证视频播放的同步性和连续性。例如，在解码视频帧后，可以调用  <code>synchronize_video</code>  函数更新时间戳：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    pts = frame-&gt;pts * av_q2d(video_st-&gt;time_base);</span><br><span class="line">&#125;</span><br><span class="line">pts = synchronize_video(is, frame, pts);</span><br><span class="line">queue_picture(is, frame, pts);</span><br></pre></td></tr></table></figure>
<p>通过这种方式，可以确保每个视频帧都按照正确的时间顺序显示，避免视频播放时出现同步问题。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">decode_video_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  VideoState *is = (VideoState *)arg;</span><br><span class="line">  AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">  <span class="type">int</span> frameFinished;</span><br><span class="line">  AVFrame *pFrame;</span><br><span class="line">  <span class="type">double</span> pts;</span><br><span class="line"></span><br><span class="line">  pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// means we quit getting packets</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode video frame</span></span><br><span class="line">    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) &#123;</span><br><span class="line">      pts = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did we get a video frame?</span></span><br><span class="line">    <span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">      pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">      <span class="keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_free_packet(packet);</span><br><span class="line">  &#125;</span><br><span class="line">  av_frame_free(&amp;pFrame);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>decode_video_thread</code>  函数是用于解码视频数据的线程函数。该函数从视频包队列中获取数据包，对其进行解码，并将解码后的帧加入到显示队列中。以下是该函数的详细解释：</p>
<h3 id="函数原型-12"><a class="markdownIt-Anchor" href="#函数原型-12">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">decode_video_thread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-12"><a class="markdownIt-Anchor" href="#参数-12">#</a> 参数</h3>
<ul>
<li><code>void *arg</code> : 指向  <code>VideoState</code>  结构的指针，包含视频播放所需的所有信息和状态。</li>
</ul>
<h3 id="返回值-3"><a class="markdownIt-Anchor" href="#返回值-3">#</a> 返回值</h3>
<ul>
<li><code>int</code> : 返回 0 表示线程正常退出。</li>
</ul>
<h3 id="详细流程"><a class="markdownIt-Anchor" href="#详细流程">#</a> 详细流程</h3>
<ol>
<li>
<p><strong>初始化变量</strong>：</p>
<ul>
<li><code>VideoState *is</code> : 将  <code>arg</code>  转换为  <code>VideoState</code>  类型。</li>
<li><code>AVPacket pkt1, *packet = &amp;pkt1</code> : 定义并初始化一个  <code>AVPacket</code>  变量  <code>pkt1</code> ， <code>packet</code>  指向  <code>pkt1</code> 。</li>
<li><code>int frameFinished</code> : 标记是否解码出完整帧的标志。</li>
<li><code>AVFrame *pFrame</code> : 用于存储解码后的视频帧。</li>
<li><code>double pts</code> : 存储帧的显示时间戳。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VideoState *is = (VideoState *)arg;</span><br><span class="line">AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line"><span class="type">int</span> frameFinished;</span><br><span class="line">AVFrame *pFrame;</span><br><span class="line"><span class="type">double</span> pts;</span><br><span class="line"></span><br><span class="line">pFrame = av_frame_alloc();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>主解码循环</strong>：</p>
<ul>
<li>不断从视频包队列中获取数据包进行解码，直到接收到退出信号或包队列为空。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">  <span class="keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// means we quit getting packets</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pts = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>解码视频帧</strong>：</p>
<ul>
<li>使用  <code>avcodec_decode_video2</code>  解码视频包。</li>
<li>获取解码后的时间戳，如果没有有效的时间戳，则设置为 0。</li>
<li>将时间戳转换为秒。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) &#123;</span><br><span class="line">  pts = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>处理解码后的帧</strong>：</p>
<ul>
<li>如果解码出完整帧，则同步时间戳，并将帧加入显示队列。</li>
<li>如果加入显示队列失败，则退出循环。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(frameFinished) &#123;</span><br><span class="line">  pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">  <span class="keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">av_free_packet(packet);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>清理资源</strong>：</p>
<ul>
<li>解码循环结束后，释放分配的帧资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">av_frame_free(&amp;pFrame);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="函数用途"><a class="markdownIt-Anchor" href="#函数用途">#</a> 函数用途</h3>
<p><code>decode_video_thread</code>  函数的主要用途是持续从视频包队列中获取数据包并进行解码，将解码后的帧添加到显示队列中。这是一个独立的线程函数，确保视频数据能够被持续解码并准备好进行显示，以保证视频播放的流畅性和同步性。</p>
<h3 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码">#</a> 示例代码</h3>
<p>以下是函数在视频解码线程中的调用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VideoState *is = ...; <span class="comment">// 初始化VideoState结构</span></span><br><span class="line">SDL_Thread *video_thread = SDL_CreateThread(decode_video_thread, <span class="string">&quot;Video Decode Thread&quot;</span>, is);</span><br><span class="line"><span class="keyword">if</span> (!video_thread) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create video decode thread: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，可以创建并启动一个用于解码视频数据的线程，确保视频播放的正常进行。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stream_component_open</span><span class="params">(VideoState *is, <span class="type">int</span> stream_index)</span> &#123;</span><br><span class="line"></span><br><span class="line">  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;</span><br><span class="line">  AVCodecContext *codecCtx = <span class="literal">NULL</span>;</span><br><span class="line">  AVCodec *codec = <span class="literal">NULL</span>;</span><br><span class="line">  SDL_AudioSpec wanted_spec, spec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(stream_index &lt; <span class="number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  codecCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line">  <span class="keyword">if</span>(!codec) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unsupported codec!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set audio settings from codec info</span></span><br><span class="line">    wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class="line">    wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">    wanted_spec.channels = <span class="number">2</span>;<span class="comment">//codecCtx-&gt;channels;</span></span><br><span class="line">    wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class="line">    wanted_spec.callback = audio_callback;</span><br><span class="line">    wanted_spec.userdata = is;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;SDL_OpenAudio: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;audio_hw_buf_size = spec.size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unsupported codec!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(codecCtx-&gt;codec_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">    is-&gt;audioStream = stream_index;</span><br><span class="line">    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">    is-&gt;audio_ctx = codecCtx;</span><br><span class="line">    is-&gt;audio_buf_size = <span class="number">0</span>;</span><br><span class="line">    is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="number">0</span>, <span class="keyword">sizeof</span>(is-&gt;audio_pkt));</span><br><span class="line">    packet_queue_init(&amp;is-&gt;audioq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Out Audio Param</span></span><br><span class="line">    <span class="type">uint64_t</span> out_channel_layout=AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AAC:1024  MP3:1152</span></span><br><span class="line">    <span class="type">int</span> out_nb_samples= is-&gt;audio_ctx-&gt;frame_size;</span><br><span class="line">    <span class="comment">//AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> out_sample_rate=is-&gt;audio_ctx-&gt;sample_rate;</span><br><span class="line">    <span class="type">int</span> out_channels=av_get_channel_layout_nb_channels(out_channel_layout);</span><br><span class="line">    <span class="comment">//Out Buffer Size</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int out_buffer_size=av_samples_get_buffer_size(NULL,</span></span><br><span class="line"><span class="comment">                                                   out_channels,</span></span><br><span class="line"><span class="comment">                                                   out_nb_samples,</span></span><br><span class="line"><span class="comment">                                                   AV_SAMPLE_FMT_S16,</span></span><br><span class="line"><span class="comment">                                                   1);</span></span><br><span class="line"><span class="comment">                                                   */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//uint8_t *out_buffer=(uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE*2);</span></span><br><span class="line">    <span class="type">int64_t</span> in_channel_layout=av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_convert_ctx</span>;</span></span><br><span class="line">    audio_convert_ctx = swr_alloc();</span><br><span class="line">    swr_alloc_set_opts(audio_convert_ctx,</span><br><span class="line">                       out_channel_layout,</span><br><span class="line">                       AV_SAMPLE_FMT_S16,</span><br><span class="line">                       out_sample_rate,</span><br><span class="line">                       in_channel_layout,</span><br><span class="line">                       is-&gt;audio_ctx-&gt;sample_fmt,</span><br><span class="line">                       is-&gt;audio_ctx-&gt;sample_rate,</span><br><span class="line">                       <span class="number">0</span>,</span><br><span class="line">                       <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;swr opts: out_channel_layout:%lld, out_sample_fmt:%d, out_sample_rate:%d, in_channel_layout:%lld, in_sample_fmt:%d, in_sample_rate:%d&quot;</span>,</span><br><span class="line">            out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate, in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt, is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class="line">    swr_init(audio_convert_ctx);</span><br><span class="line"></span><br><span class="line">    is-&gt;audio_swr_ctx = audio_convert_ctx;</span><br><span class="line"></span><br><span class="line">    SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">    is-&gt;videoStream = stream_index;</span><br><span class="line">    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">    is-&gt;video_ctx = codecCtx;</span><br><span class="line"></span><br><span class="line">    is-&gt;frame_timer = (<span class="type">double</span>)av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">    is-&gt;frame_last_delay = <span class="number">40e-3</span>;</span><br><span class="line">    </span><br><span class="line">    packet_queue_init(&amp;is-&gt;videoq);</span><br><span class="line">    is-&gt;video_sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,</span><br><span class="line">				 is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P,</span><br><span class="line">				 SWS_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">				 );</span><br><span class="line">    is-&gt;video_tid = SDL_CreateThread(decode_video_thread, <span class="string">&quot;decode_video_thread&quot;</span>, is);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>stream_component_open</code>  函数用于打开并初始化音频或视频流，并为解码和播放做好准备。以下是该函数的详细解释：</p>
<h3 id="函数原型-13"><a class="markdownIt-Anchor" href="#函数原型-13">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stream_component_open</span><span class="params">(VideoState *is, <span class="type">int</span> stream_index)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-13"><a class="markdownIt-Anchor" href="#参数-13">#</a> 参数</h3>
<ul>
<li><code>VideoState *is</code> : 指向包含视频播放相关状态的结构体  <code>VideoState</code> 。</li>
<li><code>int stream_index</code> : 要打开的流的索引。</li>
</ul>
<h3 id="返回值-4"><a class="markdownIt-Anchor" href="#返回值-4">#</a> 返回值</h3>
<ul>
<li><code>int</code> : 返回 0 表示成功，返回 -1 表示失败。</li>
</ul>
<h3 id="详细流程-2"><a class="markdownIt-Anchor" href="#详细流程-2">#</a> 详细流程</h3>
<ol>
<li>
<p><strong>获取  <code>AVFormatContext</code> </strong>：</p>
<ul>
<li>从  <code>VideoState</code>  结构体中获取格式上下文  <code>pFormatCtx</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>检查流索引的有效性</strong>：</p>
<ul>
<li>检查  <code>stream_index</code>  是否有效，如果无效则返回 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stream_index &lt; <span class="number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>分配和初始化解码器上下文</strong>：</p>
<ul>
<li>分配一个新的解码器上下文  <code>codecCtx</code> 。</li>
<li>将流参数复制到解码器上下文中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *codecCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"><span class="type">int</span> ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>查找解码器</strong>：</p>
<ul>
<li>查找流对应的解码器，如果找不到则返回 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unsupported codec!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>初始化音频流</strong>：</p>
<ul>
<li>如果流是音频类型，设置音频的 SDL 音频规范并打开音频设备。</li>
<li>初始化音频缓冲区大小，音频包队列，以及音频重采样上下文。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">  wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class="line">  wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">  wanted_spec.channels = <span class="number">2</span>;</span><br><span class="line">  wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">  wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class="line">  wanted_spec.callback = audio_callback;</span><br><span class="line">  wanted_spec.userdata = is;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;SDL_OpenAudio: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;audio_hw_buf_size = spec.size;</span><br><span class="line"></span><br><span class="line">  is-&gt;audioStream = stream_index;</span><br><span class="line">  is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">  is-&gt;audio_ctx = codecCtx;</span><br><span class="line">  is-&gt;audio_buf_size = <span class="number">0</span>;</span><br><span class="line">  is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="number">0</span>, <span class="keyword">sizeof</span>(is-&gt;audio_pkt));</span><br><span class="line">  packet_queue_init(&amp;is-&gt;audioq);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> out_channel_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line">  <span class="type">int</span> out_sample_rate = is-&gt;audio_ctx-&gt;sample_rate;</span><br><span class="line">  <span class="type">int64_t</span> in_channel_layout = av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_convert_ctx</span> =</span> swr_alloc_set_opts(<span class="literal">NULL</span>,</span><br><span class="line">                     out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate,</span><br><span class="line">                     in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt,</span><br><span class="line">                     is-&gt;audio_ctx-&gt;sample_rate, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  swr_init(audio_convert_ctx);</span><br><span class="line"></span><br><span class="line">  is-&gt;audio_swr_ctx = audio_convert_ctx;</span><br><span class="line"></span><br><span class="line">  SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>初始化视频流</strong>：</p>
<ul>
<li>如果流是视频类型，初始化视频流相关的变量和上下文，并创建视频解码线程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (codecCtx-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">  is-&gt;videoStream = stream_index;</span><br><span class="line">  is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line">  is-&gt;video_ctx = codecCtx;</span><br><span class="line"></span><br><span class="line">  is-&gt;frame_timer = (<span class="type">double</span>)av_gettime() / <span class="number">1000000.0</span>;</span><br><span class="line">  is-&gt;frame_last_delay = <span class="number">40e-3</span>;</span><br><span class="line"></span><br><span class="line">  packet_queue_init(&amp;is-&gt;videoq);</span><br><span class="line">  is-&gt;video_sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">             is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,</span><br><span class="line">             is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P,</span><br><span class="line">             SWS_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  is-&gt;video_tid = SDL_CreateThread(decode_video_thread, <span class="string">&quot;decode_video_thread&quot;</span>, is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>打开解码器</strong>：</p>
<ul>
<li>打开解码器，如果失败则返回 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avcodec_open2(codecCtx, codec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unsupported codec!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="示例代码-2"><a class="markdownIt-Anchor" href="#示例代码-2">#</a> 示例代码</h3>
<p>以下是调用  <code>stream_component_open</code>  函数的示例代码，用于打开视频和音频流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VideoState *is = ...; <span class="comment">// 初始化VideoState结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stream_component_open(is, is-&gt;videoStream) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open video stream\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stream_component_open(is, is-&gt;audioStream) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open audio stream\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，可以打开并初始化视频和音频流，为后续的解码和播放做好准备。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">demux_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">  Uint32 pixformat;</span><br><span class="line"></span><br><span class="line">  VideoState *is = (VideoState *)arg;</span><br><span class="line">  AVFormatContext *pFormatCtx;</span><br><span class="line">  AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> video_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> audio_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  is-&gt;videoStream=<span class="number">-1</span>;</span><br><span class="line">  is-&gt;audioStream=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  global_video_state = is;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open video file</span></span><br><span class="line">  <span class="keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn&#x27;t open file</span></span><br><span class="line"></span><br><span class="line">  is-&gt;pFormatCtx = pFormatCtx;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Retrieve stream information</span></span><br><span class="line">  <span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn&#x27;t find stream information</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Dump information about file onto standard error</span></span><br><span class="line">  av_dump_format(pFormatCtx, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Find the first video stream</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">       video_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      video_index=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">       audio_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      audio_index=i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(audio_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, audio_index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(video_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, video_index);</span><br><span class="line">  &#125;   </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(is-&gt;videoStream &lt; <span class="number">0</span> || is-&gt;audioStream &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: could not open codecs\n&quot;</span>, is-&gt;filename);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win = SDL_CreateWindow(<span class="string">&quot;Media Player&quot;</span>,</span><br><span class="line">     		   SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">		   SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">		   is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">		   SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class="line">  </span><br><span class="line">  renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  pixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class="line">  texture = SDL_CreateTexture(renderer,</span><br><span class="line">			      pixformat, </span><br><span class="line">			      SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">			      is-&gt;video_ctx-&gt;width,</span><br><span class="line">			      is-&gt;video_ctx-&gt;height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// main decode loop</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;quit) &#123;</span><br><span class="line">      SDL_CondSignal(is-&gt;videoq.cond);</span><br><span class="line">      SDL_CondSignal(is-&gt;audioq.cond);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// seek stuff goes here</span></span><br><span class="line">    <span class="keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||</span><br><span class="line">       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class="line">      SDL_Delay(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">	SDL_Delay(<span class="number">100</span>); <span class="comment">/* no error; wait for user input */</span></span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Is this a packet from the video stream?</span></span><br><span class="line">    <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* all done - wait for it */</span></span><br><span class="line">  <span class="keyword">while</span>(!is-&gt;quit) &#123;</span><br><span class="line">    SDL_Delay(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = FF_QUIT_EVENT;</span><br><span class="line">    event.user.data1 = is;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>demux_thread</code>  函数是负责解复用和解码视频文件的主线程。它打开文件，查找音频和视频流，并将数据包发送到相应的解码队列。以下是对该函数的详细解释：</p>
<h3 id="函数原型-14"><a class="markdownIt-Anchor" href="#函数原型-14">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">demux_thread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-14"><a class="markdownIt-Anchor" href="#参数-14">#</a> 参数</h3>
<ul>
<li><code>void *arg</code> : 一个指向  <code>VideoState</code>  结构的指针，包含视频播放相关的状态信息。</li>
</ul>
<h3 id="返回值-5"><a class="markdownIt-Anchor" href="#返回值-5">#</a> 返回值</h3>
<ul>
<li><code>int</code> : 返回 0 表示成功，返回 -1 表示失败。</li>
</ul>
<h3 id="详细流程-3"><a class="markdownIt-Anchor" href="#详细流程-3">#</a> 详细流程</h3>
<ol>
<li>
<p><strong>初始化变量</strong>：</p>
<ul>
<li>定义变量  <code>pixformat</code> 、 <code>VideoState</code> 、 <code>AVFormatContext</code>  和  <code>AVPacket</code>  等。</li>
<li>初始化视频和音频流索引  <code>video_index</code>  和  <code>audio_index</code>  为 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uint32 pixformat;</span><br><span class="line">VideoState *is = (VideoState *)arg;</span><br><span class="line">AVFormatContext *pFormatCtx;</span><br><span class="line">AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line"><span class="type">int</span> video_index = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> audio_index = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>设置初始流索引和全局视频状态</strong>：</p>
<ul>
<li>初始化  <code>VideoState</code>  结构体中的视频和音频流索引为 -1。</li>
<li>设置全局视频状态变量  <code>global_video_state</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;videoStream = <span class="number">-1</span>;</span><br><span class="line">is-&gt;audioStream = <span class="number">-1</span>;</span><br><span class="line">global_video_state = is;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>打开视频文件</strong>：</p>
<ul>
<li>尝试打开视频文件，如果失败则返回 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn&#x27;t open file</span></span><br><span class="line">is-&gt;pFormatCtx = pFormatCtx;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>获取流信息</strong>：</p>
<ul>
<li>获取视频文件的流信息，如果失败则返回 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn&#x27;t find stream information</span></span><br><span class="line">av_dump_format(pFormatCtx, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>查找音频和视频流</strong>：</p>
<ul>
<li>遍历文件中的所有流，找到第一个视频流和音频流的索引。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; video_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    video_index = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; audio_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    audio_index = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>打开音频和视频流</strong>：</p>
<ul>
<li>使用  <code>stream_component_open</code>  函数打开找到的音频和视频流。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (audio_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  stream_component_open(is, audio_index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (video_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  stream_component_open(is, video_index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is-&gt;videoStream &lt; <span class="number">0</span> || is-&gt;audioStream &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: could not open codecs\n&quot;</span>, is-&gt;filename);</span><br><span class="line">  <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建 SDL 窗口和渲染器</strong>：</p>
<ul>
<li>创建一个 SDL 窗口和渲染器，用于显示视频。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">win = SDL_CreateWindow(<span class="string">&quot;Media Player&quot;</span>,</span><br><span class="line">          SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">          SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">          is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class="line">          SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class="line">renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">pixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class="line">texture = SDL_CreateTexture(renderer,</span><br><span class="line">              pixformat,</span><br><span class="line">              SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">              is-&gt;video_ctx-&gt;width,</span><br><span class="line">              is-&gt;video_ctx-&gt;height);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>解复用主循环</strong>：</p>
<ul>
<li>主循环从文件中读取数据包，并将它们放入相应的队列中。</li>
<li>如果达到最大队列大小，则等待一段时间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;quit) &#123;</span><br><span class="line">    SDL_CondSignal(is-&gt;videoq.cond);</span><br><span class="line">    SDL_CondSignal(is-&gt;audioq.cond);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE || is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class="line">    SDL_Delay(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">      SDL_Delay(<span class="number">100</span>); <span class="comment">/* no error; wait for user input */</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">    packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">    packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    av_free_packet(packet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>等待退出</strong>：</p>
<ul>
<li>在退出之前等待，确保所有线程都正确退出。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!is-&gt;quit) &#123;</span><br><span class="line">  SDL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>错误处理和清理</strong>：</p>
<ul>
<li>在出错的情况下，发送  <code>FF_QUIT_EVENT</code>  事件，确保正确清理资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fail:</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  SDL_Event event;</span><br><span class="line">  event.type = FF_QUIT_EVENT;</span><br><span class="line">  event.user.data1 = is;</span><br><span class="line">  SDL_PushEvent(&amp;event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h3>
<p><code>demux_thread</code>  函数是媒体播放器的核心，它处理文件的打开、解复用、解码和显示。通过结合 SDL 和 FFmpeg 库，该函数能够从视频文件中提取音频和视频流，并将它们分别送到音频和视频解码器进行处理，最终在屏幕上显示视频，并通过音频设备播放音频。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>             ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  SDL_Event       event;</span><br><span class="line"></span><br><span class="line">  VideoState      *is;</span><br><span class="line"></span><br><span class="line">  is = av_mallocz(<span class="keyword">sizeof</span>(VideoState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: test &lt;file&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Register all formats and codecs</span></span><br><span class="line">  av_register_all();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  text_mutex = SDL_CreateMutex();</span><br><span class="line"></span><br><span class="line">  av_strlcpy(is-&gt;filename, argv[<span class="number">1</span>], <span class="keyword">sizeof</span>(is-&gt;filename));</span><br><span class="line"></span><br><span class="line">  is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">  is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class="line"></span><br><span class="line">  schedule_refresh(is, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  is-&gt;parse_tid = SDL_CreateThread(demux_thread, <span class="string">&quot;demux_thread&quot;</span>, is);</span><br><span class="line">  <span class="keyword">if</span>(!is-&gt;parse_tid) &#123;</span><br><span class="line">    av_free(is);</span><br><span class="line">    <span class="keyword">goto</span> __FAIL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line"></span><br><span class="line">    SDL_WaitEvent(&amp;event);</span><br><span class="line">    <span class="keyword">switch</span>(event.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">    <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">      is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//SDL_Quit();</span></span><br><span class="line">      <span class="comment">//return 0;</span></span><br><span class="line">      <span class="keyword">goto</span> __QUIT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FF_REFRESH_EVENT:</span><br><span class="line">      video_refresh_timer(event.user.data1);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">__QUIT:</span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__FAIL:</span><br><span class="line"></span><br><span class="line">  SDL_Quit();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  if(audiofd)&#123;</span></span><br><span class="line"><span class="comment">    fclose(audiofd);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  if(audiofd1)&#123;</span></span><br><span class="line"><span class="comment">    fclose(audiofd1);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>main</code>  函数是媒体播放器程序的入口点。它初始化库和框架，设置必要的结构和线程，并进入事件处理循环。以下是对  <code>main</code>  函数的详细解释：</p>
<h3 id="函数原型-15"><a class="markdownIt-Anchor" href="#函数原型-15">#</a> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-15"><a class="markdownIt-Anchor" href="#参数-15">#</a> 参数</h3>
<ul>
<li><code>int argc</code> : 命令行参数的个数。</li>
<li><code>char *argv[]</code> : 命令行参数的数组。</li>
</ul>
<h3 id="返回值-6"><a class="markdownIt-Anchor" href="#返回值-6">#</a> 返回值</h3>
<ul>
<li><code>int</code> : 返回 0 表示成功，返回其他值表示失败。</li>
</ul>
<h3 id="详细流程-4"><a class="markdownIt-Anchor" href="#详细流程-4">#</a> 详细流程</h3>
<ol>
<li>
<p><strong>定义变量</strong>：</p>
<ul>
<li>定义返回值  <code>ret</code> ，SDL 事件  <code>event</code> ，和视频状态结构  <code>VideoState</code>  的指针  <code>is</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">SDL_Event event;</span><br><span class="line">VideoState *is;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>分配  <code>VideoState</code>  结构</strong>：</p>
<ul>
<li>使用  <code>av_mallocz</code>  分配并初始化  <code>VideoState</code>  结构。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is = av_mallocz(<span class="keyword">sizeof</span>(VideoState));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>检查命令行参数</strong>：</p>
<ul>
<li>确保至少有一个命令行参数（即文件名）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: test &lt;file&gt;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>注册所有格式和编解码器</strong>：</p>
<ul>
<li>调用  <code>av_register_all</code>  注册所有可用的文件格式和编解码器。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_register_all();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>初始化 SDL</strong>：</p>
<ul>
<li>使用  <code>SDL_Init</code>  初始化 SDL 视频、音频和定时器子系统。如果初始化失败，输出错误信息并退出。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建互斥锁</strong>：</p>
<ul>
<li>创建一个用于文本的互斥锁  <code>text_mutex</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text_mutex = SDL_CreateMutex();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>复制文件名</strong>：</p>
<ul>
<li>使用  <code>av_strlcpy</code>  复制命令行参数中的文件名到  <code>VideoState</code>  结构中的  <code>filename</code>  字段。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_strlcpy(is-&gt;filename, argv[<span class="number">1</span>], <span class="keyword">sizeof</span>(is-&gt;filename));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>初始化队列互斥锁和条件变量</strong>：</p>
<ul>
<li>创建用于帧队列的互斥锁  <code>pictq_mutex</code>  和条件变量  <code>pictq_cond</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">is-&gt;pictq_cond = SDL_CreateCond();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>计划首次刷新</strong>：</p>
<ul>
<li>调用  <code>schedule_refresh</code>  函数计划首次刷新事件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_refresh(is, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建解复用线程</strong>：</p>
<ul>
<li>创建解复用线程  <code>parse_tid</code>  并传递  <code>VideoState</code>  结构指针作为参数。如果线程创建失败，释放  <code>VideoState</code>  结构并跳转到错误处理代码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;parse_tid = SDL_CreateThread(demux_thread, <span class="string">&quot;demux_thread&quot;</span>, is);</span><br><span class="line"><span class="keyword">if</span> (!is-&gt;parse_tid) &#123;</span><br><span class="line">  av_free(is);</span><br><span class="line">  <span class="keyword">goto</span> __FAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>事件处理循环</strong>：</p>
<ul>
<li>使用  <code>SDL_WaitEvent</code>  等待事件并处理不同类型的事件：
<ul>
<li><code>FF_QUIT_EVENT</code>  和  <code>SDL_QUIT</code> ：设置  <code>quit</code>  标志，跳转到退出处理代码。</li>
<li><code>FF_REFRESH_EVENT</code> ：调用  <code>video_refresh_timer</code>  函数处理刷新事件。</li>
<li>其他事件：忽略。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  SDL_WaitEvent(&amp;event);</span><br><span class="line">  <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">  <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">    is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> __QUIT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> FF_REFRESH_EVENT:</span><br><span class="line">    video_refresh_timer(event.user.data1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>退出处理</strong>：</p>
<ul>
<li>在  <code>__QUIT</code>  标签下，设置返回值  <code>ret</code>  为 0。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__QUIT:</span><br><span class="line">ret = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>错误处理和资源清理</strong>：</p>
<ul>
<li>在  <code>__FAIL</code>  标签下，调用  <code>SDL_Quit</code>  退出 SDL。如果有其他资源需要清理，可以在这里进行（此示例代码中被注释掉的部分）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__FAIL:</span><br><span class="line">SDL_Quit();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2">#</a> 总结</h3>
<p><code>main</code>  函数负责初始化所有必要的组件和框架，创建解复用线程，并进入事件处理循环，响应各种 SDL 事件。通过这些步骤，它启动了媒体播放器的核心功能，包括解码、同步和显示视频，以及播放音频。</p>
</blockquote>
<p><img loading="lazy" data-src="/Users/huangqiuzhao/blog/source/_posts/%E9%9F%B3%E8%A7%86%E9%A2%91/player.jpg" alt="player"></p>
<hr>
<h2 id="pcm"><a class="markdownIt-Anchor" href="#pcm">#</a> PCM</h2>
<p>将音频数字化的常见技术方案是脉冲编码调制（PCM，Pulse Code Modulation），主要过程是：采样 量化 编码。</p>
<p><img loading="lazy" data-src="/Users/huangqiuzhao/blog/source/_posts/%E9%9F%B3%E8%A7%86%E9%A2%91/image-20240928223612862.png" alt="image-20240928223612862"></p>
<p>模拟信号的波形是无限光滑的，可以看成由无数个点组成，由于存储空间是相对有限的，数字编码过程中，必须要对波形的点进行采样。采样（Sampling）：每隔一段时间采集一次模拟信号的样本，是一个在时间上将模拟信号离散化（把连续信号转换成离散信号）的过程。</p>
<p>每秒采集的样本数量，称为采样率（采样频率，采样速率，Sampling Rate）。比如，采样率 44.1kHz 表示 1 秒钟采集 44100 个样本。</p>
<p>根据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86">采样定理</a>（奈奎斯特–香农采样定理，Nyquist-Shannon sampling theorem）得知：只有当采样率高于声音信号最高频率的 2 倍时，才能把采集的声音信号唯一地还原成原来的声音。人耳能够感觉到的最高声音频率为 20000Hz，因此为了满足人耳的听觉要求，需要至少每秒进行 40000 次采样（40kHz 采样率）。这就是为什么常见的 CD 的采样率为 44.1kHz。电话、无线对讲机、无线麦克风等的采样率是 8kHZ。</p>
<p>量化（Quantization）：将每一个采样点的样本值数字化。</p>
<p>位深度（采样精度，采样大小，Bit Depth）：使用多少个二进制位来存储一个采样点的样本值。位深度越高，表示的振幅越精确。常见的 CD 采用 16bit 的位深度，能表示 65536（216）个不同的值。DVD 使用 24bit 的位深度，大多数电话设备使用 8bit 的位深度。</p>
<p><img loading="lazy" data-src="/Users/huangqiuzhao/blog/source/_posts/%E9%9F%B3%E8%A7%86%E9%A2%91/image-20240928223927838.png" alt="image-20240928223927838"></p>
<p>编码：将采样和量化后的数字数据转成二进制码流。</p>
<p>单声道产生一组声波数据，双声道（立体声）产生两组声波数据。</p>
<p>采样率 44.1kHZ、位深度 16bit 的 1 分钟立体声 PCM 数据有多大？</p>
<ul>
<li>采样率 * 位深度 * 声道数 * 时间</li>
<li><em>44100 * 16 * 2 * 60 / 8 ≈ 10.34MB</em></li>
</ul>
<p>1 分钟 10.34MB，这对于大部分用户来说是不能接受的。要想在不改变音频时长的前提下，降低音频数据的大小，只有 2 种方法：降低采样指标、压缩。降低采样指标是不可取的，会导致音频质量下降，用户体验变差，因此专家们研发了各种压缩方案。</p>
<p>比特率（Bit Rate），指单位时间内传输或处理的比特数量，单位是：比特每秒（bit/s 或 bps），还有：千比特每秒（Kbit/s 或 Kbps）、兆比特每秒（Mbit/s 或 Mbps）、吉比特每秒（Gbit/s 或 Gbps）、太比特每秒（Tbit/s 或 Tbps）。</p>
<p>采样率 44.1kHZ、位深度 16bit 的立体声 PCM 数据的比特率是多少？</p>
<ul>
<li>采样率 * 位深度 * 声道数</li>
<li><em>44100 * 16 * 2 = 1411.2Kbps</em></li>
</ul>
<p>通常，采样率、位深度越高，数字化音频的质量就越好。从比特率的计算公式可以看得出来：比特率越高，数字化音频的质量就越好。</p>
<p>信噪比（Signal-to-noise ratio，SNR，S/N，讯噪比），指信号与噪声的比例，用于比较所需信号的强度与背景噪声的强度，以分贝（dB）为单位。</p>
<h2 id="音频的编码与解码"><a class="markdownIt-Anchor" href="#音频的编码与解码">#</a> 音频的编码与解码</h2>
<p>PCM 数据可以理解为是：未经压缩的原始音频数据，体积比较大，为了更便于存储和传输，一般都会使用某种音频编码对它进行编码压缩，然后再存成某种音频文件格式。</p>
<p>压缩分为无损压缩和有损压缩。</p>
<ul>
<li>无损压缩
<ul>
<li>解压后可以完全还原出原始数据</li>
<li>压缩比小，体积大</li>
</ul>
</li>
<li>有损压缩
<ul>
<li>解压后不能完全还原出原始数据，会丢失一部分信息</li>
<li>压缩比大，体积小</li>
<li>压缩比越大，丢失的信息就越多，还原后的信号失真就会越大</li>
<li>一般是通过舍弃原始数据中对人类听觉不重要的部分，达成压缩成较小文件的目的</li>
</ul>
</li>
<li>压缩比 = 未压缩大小 / 压缩后大小</li>
</ul>
<p>当需要播放音频时，得先解码（解压缩）出 PCM 数据，然后再进行播放。</p>
</div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2024-09-28 23:01:55" itemprop="dateModified" datetime="2024-09-28T23:01:55+08:00">2024-09-28</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.png" alt="hqz 微信支付"/><p>微信支付</p></div><div><img loading="lazy" data-src="/assets/alipay.png" alt="hqz 支付宝"/><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>hqz<i class="ic i-at"><em>@</em></i>刀刀博客</li><li class="link"><strong>本文链接：</strong><a href="https://chnhqz.github.io/2024/05/05/%E9%9F%B3%E8%A7%86%E9%A2%91/" title="音视频">https://chnhqz.github.io/2024/05/05/音视频/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/05/05/mysql/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciryrr3rj20zk0m8nhk.jpg" title="mysql"><span class="type">上一篇</span><h3>mysql</h3></a></div><div class="item right"><a href="/2024/05/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciryrr3rj20zk0m8nhk.jpg" title="论文阅读"><span class="type">下一篇</span><h3>论文阅读</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86mp4%E8%BD%AC%E5%8C%96%E4%B8%BAflv%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text"> 将 MP4 转化为 FLV 格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ffmpeg%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text"> FFmpeg 文件与目录操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%8F%E5%92%96%E7%A7%80"><span class="toc-number">3.</span> <span class="toc-text"> 实现一个简单的小咖秀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libavcodecavcodech"><span class="toc-number">4.</span> <span class="toc-text"> libavcodec&#x2F;avcodec.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Emp4%E6%88%AA%E5%8F%96%E4%B8%80%E6%AE%B5%E8%A7%86%E9%A2%91"><span class="toc-number">5.</span> <span class="toc-text"> 从 MP4 截取一段视频</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sdl%E4%BA%8B%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text"> SDL 事件基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yuv%E6%92%AD%E6%94%BE%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text"> YUV 播放器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sdl%E9%9F%B3%E9%A2%91api"><span class="toc-number">8.</span> <span class="toc-text"> SDL 音频 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pcm-%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text"> PCM 音频播放器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text"> 简单视频播放器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%AD%98%E6%94%BE%E9%9F%B3%E9%A2%91%E5%8C%85-%E6%92%AD%E6%94%BE%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text"> 使用队列存放音频包 - 播放器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">12.</span> <span class="toc-text"> 多线程与锁（音视频的同步）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%AD%E6%94%BE%E5%99%A8%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">13.</span> <span class="toc-text"> 播放器线程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5"><span class="toc-number">14.</span> <span class="toc-text"> 音视频同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#player"><span class="toc-number">15.</span> <span class="toc-text"> player</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-2"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-2"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-3"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-3"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-3"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-3"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-4"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-4"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-4"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-4"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-5"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-5"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-5"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-5"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-6"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-6"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-6"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-6"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text"> 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text"> 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-7"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-7"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-7"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-7"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number"></span> <span class="toc-text"> 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number"></span> <span class="toc-text"> 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-8"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-8"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-8"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-8"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number"></span> <span class="toc-text"> 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number"></span> <span class="toc-text"> 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-9"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-9"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-9"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-9"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number"></span> <span class="toc-text"> 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number"></span> <span class="toc-text"> 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-10"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-10"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number"></span> <span class="toc-text"> 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-10"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-10"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number"></span> <span class="toc-text"> 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-11"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-11"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number"></span> <span class="toc-text"> 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-11"><span class="toc-number"></span> <span class="toc-text"> 函数流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-11"><span class="toc-number"></span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number"></span> <span class="toc-text"> 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-12"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-12"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number"></span> <span class="toc-text"> 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text"> 详细流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E9%80%94"><span class="toc-number"></span> <span class="toc-text"> 函数用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text"> 示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-13"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-13"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="toc-number"></span> <span class="toc-text"> 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B-2"><span class="toc-number"></span> <span class="toc-text"> 详细流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-number"></span> <span class="toc-text"> 示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-14"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-14"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-5"><span class="toc-number"></span> <span class="toc-text"> 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B-3"><span class="toc-number"></span> <span class="toc-text"> 详细流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-15"><span class="toc-number"></span> <span class="toc-text"> 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-15"><span class="toc-number"></span> <span class="toc-text"> 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-6"><span class="toc-number"></span> <span class="toc-text"> 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B-4"><span class="toc-number"></span> <span class="toc-text"> 详细流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number"></span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pcm"><span class="toc-number"></span> <span class="toc-text"> PCM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text"> 音频的编码与解码</span></a></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="hqz" src="/assets/avatar.jpg"/><p class="name" itemprop="name">hqz</p><div class="description" itemprop="description">欢迎来到刀刀的笔记空间(^_^)</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">14</span><span class="name">文章</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/yourname" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/05/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/05/05/mysql/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/05/mysql/">mysql</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/06/%E5%8A%9B%E6%89%A3/">力扣</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/06/08/papper/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-1/">论文阅读</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/10/05/%E9%A3%9F%E8%B4%AB%E9%81%93/">食贫道</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/06/07/test/hello-world/">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/05/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/06/07/test/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/10/03/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/">音频处理</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2></div></div><div class="status"><div class="copyright">&copy; 2022 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">hqz @ testName</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">365k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">5:32</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
    path: `2024/05/05/音视频/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.25" type="module" fetchpriority="high" defer></script></body></html>