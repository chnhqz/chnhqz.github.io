---
title: 力扣
date: 2024-05-06 10:20:46
tags:
---

## 1.哈希

#### 1.两数之和

如果直接暴力很简单，但是时间复杂度为 $O(n)$ 。这里其实时间的复杂度主要来自于内层循环的复杂度，外层循环，的 $O(n)$ 时间复杂度是不可避免的，对于 $nums[i]$ 来说，我们在数组中找到一个数等于 $target - nums[i]$ 。只是循环的话，还是 $O(n)$ 的时间复杂度，我们可以使用哈希的方法，直接用 $O(1)$ 的时间复杂度找到 $target - nums[i]$ 。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp;
        for (int i = 0; i < nums.size(); i++) {
            // 找一个键值为 target - nums[i] 的索引
            auto it  = mp.find(target - nums[i]);
            // 如果找到了键值为 target - nums[i] 的索引，那么返回答案
            if (it != mp.end()) {
                return {it->second, i};
            }
            mp[nums[i]] = i;
        }
        return {};
    }
};
```

#### 49.字母异位词分组

我们可以选择将排序后的字符串作为键，无序的字符串作为键值 `unordered_map<string, vector<string>> mp;` 这样遍历一边字符串，就可以筛选出所有的答案。

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        for (string& str : strs) {
            string key = str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        }
        vector<vector<string>> res;
        for (auto it = mp.begin(); it != mp.end(); it++) {
            res.emplace_back(it->second);
        }
        return res;
        
    }
};
```



#### 128.最长连续序列

首先我们考虑枚举数组中的每个数 $x$ 。考虑不断尝试 $x+1,x+2,x+3,...$ 是否存在。对于匹配的过程，直接的方法是 $O(n)$ 遍历数组去看是否存在这个数，但是我们可以使用更高效的方法，用一个哈希表存储数组中的数，这样查看一个数是否存在能优化至 $O(1)$ 的时间复杂度。

但是仅仅这样，我们的算法时间复杂度最坏情况还是会达到 $O(n^2)$ （即外层需要枚举 $n$ 个数，内层也需要暴力匹配 $n$ 次）。这样无法满足题目时间复杂度 $O(n)$ 的要求。但是我们仔细分析这个枚举的过程，我们会发现其实我们进行了很多不必要的枚举，如果已知有一个 $x, x+1, x+2, ..., x+y$ 的连续序列，而我们在下一个数字 $x+ 2$ 的时候仍然一个一个的枚举，这样得到的结果是一定不会优于以 $x$ 为起点的的答案的。所以我们需要在外层判断 `x - 1` 是否在数组中存在，如果存在，那么他就是已经判断过的，不需要在判断，直接跳过即可。

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (auto num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (auto num : num_set) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }
        return longestStreak;
    }
};
```

## 2.双指针

#### 283.移动零

双指针，`left` 和 `right` 当`left` 为0时，`right`找到`left`后边第一个不为零的数字进行交换。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if (nums.size() == 1) return;
        for (int left = 0, right = 1; left < right && right < nums.size(); ) {
            if (nums[left] == 0) {
                while (right < nums.size() && nums[right] == 0) {
                    right ++;
                }
                if (right == nums.size()) return;
                nums[left] = nums[right];
                nums[right] = 0;
            }
            left ++;
            right ++;
        }
    }
};
```

#### 11.盛最多水的容器

这道题目，观察数据的规模，如果采用暴力的双层`for`循环进行枚举，那么时间复杂度一定超标。这里我们观察，是解决两条线之间的面积最大的问题，那么自然而然想到可以使用双指针来解决，我们接下来注意如何解决指针的移动，首先在`height[0]` 和 `height[8]`之间指针如何移动呢？此时指针 `height[0] < height[8]` 那就是说我们此时找到比 `height[0]`大的值即可。可以照样理解，我们此时在数组中寻找只要比 `height[8]`小的值，那么面积一定比此时面积小，所以我们选择移动两个数值之间较小的数字，这样才有可能出现比现在大的面积。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int res = -1;
        while (left < right) {
            res = max(res, min(height[left], height[right]) * (right - left));
            if (height[left] > height[right]) right --;
            else left ++;
        }
        return res;
    }
};
```

#### 15.三数之和

利用双指针进行时间复杂度的压缩，首先我们对数组进行排序，这样可以方便后续进行左右指针的移动。排序后，我们要对数组中一样的数字进行去重，`if (i - 1 >= 0 && nums[i] == nums[i - 1]) continue` 这句代码就是进行去重的代码。之后我们定义左指针指向`nums[i]` 的下一个数字，右指针指向最后一个数字。定义 `target` 为目标数字，这样我们就可以用二分查找的方法进行时间复杂度的压缩，我们将三数之和问题转化为两个数字的和等于 `-nums[i]` 。我们计算这个和`sum`。如果这个和 `sum > 0` `right--` 否则 `left++` 。但是这里有个问题，就是会有一样的数字造成答案数组重复。所以我们要进行一样的数字跳过的操作。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < nums.size(); i++) {
            if (i - 1 >= 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1, right = nums.size() - 1;
            int target = nums[i];
            while (left < right) {
                int sum = target + nums[left] + nums[right];
                if (sum > 0) right--;
                else if (sum < 0) left++;
                else {
                    res.push_back({target, nums[left], nums[right]});
                    for (left ++; left < right && nums[left] == nums[left - 1]; left++);
                    for (right--; left < right && nums[right] == nums[right + 1]; right--);
                }
            }
        }
        return res;    
    }
};
```

#### 42.接雨水

![截屏2024-05-06 10.21.59](截屏2024-05-06 10.21.59.png)

这里我们将每一块区域都视为一个底边长度为`1` 的木桶，这是木桶的容水量为 `min(左边最高的木板，右边最高的木板)- height[i]` 那么如何求对于一个位置的左边最高木板和右边最高木板呢？这里我们用到前后缀的方法。

```c++
// 0 1 1 2 2 2 2 3 3 3 3 3
// 3 3 3 3 3 3 3 3 2 2 2 1
// 0 0 1 0 1 2 1 0 0 1 0 0
```

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        vector<int> pre_max(height.size(), 0);
        vector<int> suf_max(height.size(), 0);
        pre_max[0] = height[0];
        suf_max[height.size() - 1] = height[height.size() - 1];
        for (int i = 1; i < height.size(); i++) {
            pre_max[i] = max(pre_max[i - 1], height[i]);
        }
        for (int i = height.size() - 2; i >= 0; i--) {
            suf_max[i] = max(suf_max[i + 1], height[i]);
        }
        int res = 0;
        for (int i = 0; i < height.size(); i++) {
            res += min(pre_max[i], suf_max[i]) - height[i];
        }

        return res;
    }
};
```

**相向双指针的做法**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0, left = 0, right = height.size() - 1, pre_max = 0, suf_max = 0;
        while (left <= right) {
            pre_max = max(pre_max, height[left]);
            suf_max = max(suf_max, height[right]);
            if (pre_max < suf_max) {
                // 左边木桶的容量就知道了
                res += pre_max - height[left];
                left ++;
            } else {
                res += suf_max - height[right];
                right --;
            }
        }
        return res;
    }
};
```



## 3.滑动窗口

#### 3.无重复字符的最长字串

滑动窗口，利用集合维护一个没有重复字符的字符串，不断枚举右指针指向的字符，并在集合中判断它在所维护的字符串中是否出现过，如果出现过，就不断移动所维护的字符串的左边界，使得所维护的字符串中没有与此时右指针指向的字符串重复的字符。然后插入右指针指向的字符，更新答案。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> st;
        int res = 0;
        for (int right = 0, left = 0; right < s.size(); right++) {
            // 不断滑动右指针，直到当前右指针指向的字符没有重复
            while (st.count(s[right])) {
                // 当前右指针指向的字符在st中有重复的，所以不断滑动左指针，并擦去st中的左指针字符
                st.erase(s[left++]);
            }
            // 当滑动完成，此时右指针指向的字符在st中没有重复的，插入右指针的字符 更新答案
            st.insert(s[right]);
            res = max(res, right - left + 1);
        }

        return res;
    }
};
```

#### 438.找到字符串中所有字母异位词

首先我想到的是暴力解法，利用每次在`s`中截取一段长度等于`p`的子字符串。然后比较两个字符串是否是异位字符串。这种方法比较直接，实现起来也没有难度。我用的是字典来比较字符串是否是异位字符串，但是时间复杂度很高。不出意料的超时了。

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map <char, int> mp_1;
        for (int i = 0; i < p.size(); i++) {
            mp_1[p[i]] ++;
        }
        vector <int> res;
        unordered_map <char, int> mp_2;
        for (int left = 0, right = p.size() - 1; right < s.size();left++, right++) {
            mp_2.clear();
            int flag = 1;
            for (int i = left; i <= right; i++) {
                mp_2[s[i]]++;
            }
            for (auto mp_1_ : mp_1) {
                if (mp_2[mp_1_.first] != mp_1_.second) {
                    flag = 0;
                    break;
                }
            }
            if (flag) {
                res.push_back(left);
            }
        }
        return res;
    }
};
```

接着想，这个解法中可以优化的点在哪里？首先分析时间复杂度，一个最外层的循环，内部是有两个循环，一个循环记录当前的子字符串的字典集合，另外一个循环进行比较两个字符串。最坏的情况就是 $O(n^2)$。

此时其实有一个可以优化的点，就是不需要每次重复循环计算`mp_2`，我们只需要减去上次的左端点，在加上这次的右端点即可。

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector <int> res;
        if (s.size() < p.size()) return res;
        unordered_map <char, int> mp_1;
        unordered_map <char, int> mp_2;
        for (int i = 0; i < p.size(); i++) {
            mp_1[p[i]] ++;
            mp_2[s[i]] ++;
        }

        
        
        for (int left = 0, right = p.size() - 1; right < s.size();left++, right++) {
            
            int flag = 1;
            if (left != 0) {
                mp_2[s[left - 1]] --;
                mp_2[s[right]] ++;
            }
            for (auto mp_1_ : mp_1) {
                if (mp_2[mp_1_.first] != mp_1_.second) {
                    flag = 0;
                    break;
                }
            }
            if (flag) {
                res.push_back(left);
            }
        }
        return res;
    }
};
```

经过这次优化，就通过了。

## 子串

#### 560.和为k的子数组

首先想到暴力解决的方法，我们遍历整个数组，依次计算从 `i` 到`j` 之间的和，然后与 `k ` 进行大小的比较。

```c++
class Solution {
public:
    int cla_nums_i_j(vector<int>& nums, int begin, int end) {
        int res = 0;
        for (int i = begin; i <= end; i++) {
            res += nums[i];
        }
        return res;
    }

    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int res = 0;
        vector<vector<int>>dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i <= j) {
                    dp[i][j] = cla_nums_i_j(nums, i, j); 
                    if (dp[i][j] == k) {  
                        res ++;
                    }
                }
            }
        }
        return res;
    }
};
```

很明显，这样的时间复杂度至少为 $O(n^2)$ （没有计算`cla_nums_i_j`的时间复杂度）。所以这样是一定会超时的，我们需要进行优化。首先我们有必要逐个计算`dp[i][j]` 吗？我们能否只计算其他的值，然后用这些值把所有的值推算出来？例如`dp[i][j] = dp[0][j] - dp[0][i]`。

```c++
class Solution {
public:
    int cla_nums_i_j(vector<int>& nums, int begin, int end) {
        int res = 0;
        for (int i = begin; i <= end; i++) {
            res += nums[i];
        }
        return res;
    }

    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int res = 0;
        vector<int> dp(n, 0);
        for (int i = 0; i < n; i++) {
            dp[i] = cla_nums_i_j(nums, 0, i);
            if (dp[i] == k) {
                res ++;
            }
        }
        for (int i = 1; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (dp[j] - dp[i - 1] == k) {
                    res ++;
                }
            }
        }
        return res;
    }
};
```

这次进行了简单的优化，但是仍然使用了双层循环来进行`i~j` 之间的元素和的判断。这次通过了`87/93` 个样例。仍然是时间复杂度过高。还有优化的空间，我在计算`dp[i]`时每次都调用了`cla_nums_i_j` 这里每次都有重复计算。

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int res = 0;
        int tmp = 0;
        vector<int> dp(n, 0);
        for (int i = 0; i < n; i++) {
            tmp += nums[i];
            dp[i] = tmp;
            if (dp[i] == k) {
                res ++;
            }
        }
        for (int i = 1; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (dp[j] - dp[i - 1] == k) {
                    res ++;
                }
            }
        }
        return res;
    }
};
```

这次通过了，但是时间复杂度仍然很高\*_*!。

## 动态规划

 ![image-20240624100453657](/Users/huangqiuzhao/blog/source/_posts/力扣/image-20240624100453657.png)



**完全背包理论**

有 $N$ 件物品和一个最多能背重量为 $W$ 的背包。第 $i$ 件物品的重量是 $weight[i]$ ，得到的价值是 $value[i]$ 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

**01背包遍历顺序的核心思路**

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
 	for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
 	}
}
```

内层的循环，从大到小遍历，为了保证每个物品仅被添加一次。

**完全背包核心思路**

```c++
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
 	for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

#### 518.零钱兑换II

`vector<int>dp(amount + 1, 0);` `dp[i]` 表示当前 `amount` 为 `i` ，有 `dp[i]` 种方法可以凑成 `i` 。由于每种硬币可以使用无限次。所以这是一个完全背包题目。先进行物品的遍历，之后进行背包容量的遍历。

**递推公式**

> `dp[j]` （考虑`coins[i]`的组合总和）就是所有的 `dp[j - coins[i]]` 相加
>
> 例如在考虑第一层循环时 `dp[5] = dp[0] + dp[1] + dp[2] + d[3] + dp[4]` 

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int>dp(amount + 1, 0); // dp[j]表示当前amount为j，有dp[j]种方法可以凑成j。
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
};
```

这里外层循环只能是物品，因为如果外层是背包容量的话，我们计算的是排列数。

#### 377.组合总合IV

这道题目跟前一个题目（518.零钱兑换II）不一样的点在于，这个题目的顺序不同的序列被视为不同的组合。这道题目我们将背包容量放到外层循环。

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<unsigned> dp(target + 1, 0);
        dp[0] = 1;

        for (int j = 0; j <= target; j++) {
            for (int i = 0; i < nums.size(); i++) {
                if (j - nums[i] >= 0) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }

        return dp[target];
    }
};
```

这道题目还有一种 `DFS` 的解法

```c++
class Solution {
public:

    void DFS(vector<int>&nums, int sum, int target, int end, int *res) {
        if (sum >= target) {
            if (sum == target) {
                (*res)++;
                cout << *res << endl;
            }

            return;
        }

        for (int i = 0; i < end; i++) {
            sum += nums[i];
            DFS(nums, sum, target, end, res);
            sum -= nums[i];
            cout << nums[i] << "|"<< sum <<"|"<<*res << endl;
        }
    }

    int combinationSum4(vector<int>& nums, int target) {
        int sum = 0;
        int res = 0;
        DFS(nums, sum, target, nums.size(), &res);
        return res;
    }
};
```

#### 139.单词拆分

`dp[i]` 代表字符串`i` 前边的字符串能够被拼接出来。只有当 `dp[j]` 为真，且 在字符串列表内能够找到 `s[j, i - j]` 的字符时 `dp[i]` 才为真。

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        auto wordDictSet = unordered_set <string> ();
        for (auto word : wordDict) wordDictSet.insert(word);

        auto dp = vector<bool>(s.size() + 1);
        dp[0] = true;

        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.find(s.substr(j ,i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
```

#### 72.编辑距离

给出两个单词`word1`和`word2`，返回将 `word1` 转换为 `word2` 所使用的最小操作次数。这里单词之间的转换有三种方式

1. 删除
2. 插入
3. 替换

`dp[i][j]`代表 `word1[0 ~ i]` 转换为 `word[0 ~ j]` 所用的最少操作数

| 0     | r - 1 | o - 2 | s - 3 |
| ----- | ----- | ----- | ----- |
| h - 1 | 1     | 2     | 3     |
| o - 2 | 2     | 1     | 2     |
| r - 3 | 2     | 2     | 2     |
| s - 4 | 3     | 3     | 2     |
| e - 5 | 4     | 4     | **3** |

根据这个图可以明显看出，当 `word1[i] == word2[j]` 时，`dp[i][j] = dp[i - 1][j - 1]` 这也就是说我们可以确定一个状态转换
$$
dp[i][j] = dp[i - 1][j - 1] \qquad word1[i] == word2[j]
$$
接下来我们需要判断当 `word1[i] != word2[j]` 时的情况，我们很容易写出
$$
dp[i][j] = \min (dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 \qquad word1[i] != word2[j]
$$
但是，这其中代表什么意思？`dp[i - 1][j]` 从表格中可以看出，是 `h -> ros` 的次数，而它的下一步变换 `ho -> ros` 。如果 `ho - > ros` 的状态可以从 `h - > ros` 转化，那么也就是说不需要使用 `o` 。也就是删除了 `o` 。所以这个 `dp[i][j] = dp[i - 1][j]` 代表删除。同理 `hor -> ros = hor -> ro` 代表插入`r` 。`hor -> ros = ho -> ro` 代表替换。

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len_word1 = word1.size(), len_word2 = word2.size();
        if (len_word1 == 0) return len_word2;
        // dp[i][j] 代表 word1[0 ~ i] 转换为 word[0 ~ j] 所用的最少操作数
        vector<vector<int>>dp(len_word1 + 1, vector<int>(len_word2 + 1, 0));
        // cout << dp.size() << " " << dp[0].size() << endl;

        for (int i = 1; i <= len_word1; i++) {
            dp[i][0] = i;
            for (int j = 1; j <= len_word2; j++) {
                dp[0][j] = j;
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    cout << "i:" << i << "j:" << j << endl;
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }

        return dp[len_word1][len_word2];
    }
};
```





### 区间DP

![截屏2024-06-26 15.46.24](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26 15.46.24.png)

#### 516.最长回文子序列

**思路一：**

求 `s` 和反转后的 `s` 的 `LCS` 

#### 1143.LCS

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int text1Len = text1.size(), text2Len = text2.size();
        int dp[text1Len + 1][text2Len + 1];

        for (int i = 0; i <= text1Len; i++)
            for (int j = 0; j <= text2Len; j++) dp[i][j] = 0;

        for (int i = 0; i < text1Len; i++) {
            for (int j = 0; j < text2Len; j++) {
                if (text1[i] == text2[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
                else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }

        return dp[text1Len][text2Len];
    }
};
```

```c++
class Solution {
public:
    int longestCommonSubsequence(string& text1, string& text2) {
        int len_text1 = text1.size(), len_text2 = text2.size();
        // 定义 dp[i][j] 代表 text1[0, i - 1] 和 text2[0, j - 1] 之间的最长公共子序列长度
        vector<vector<int>> dp(len_text1 + 1, vector<int>(len_text2 + 1, 0));

        for (int i = 0; i < len_text1; i++) {
            for (int j = 0; j < len_text2; j++) {
                if (text1[i] == text2[j]) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                } else {
                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
                }
            }
        }
        return dp[len_text1][len_text2];

    }

    int longestPalindromeSubseq(string s) {
        string s1 = s;
        reverse(s1.begin(),s1.end());
        return longestCommonSubsequence(s, s1);


    }
};
```





**思路二：**

【选或不选】从两侧向内缩小问题规模

![截屏2024-06-26 15.49.28](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26 15.49.28.png)

（类似LCS）定义 `dfs(i,j)` 表示从 `s[i]` 到 `s[j]` 的最长回文子序列的长度

<img src="/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26 15.51.46.png" alt="截屏2024-06-26 15.51.46" style="zoom:50%;" />

递归边界 ：
$$
dfs(i,i) = 1 \\
dfs(i + 1, i) = 0
$$
递归入口：$dfs(0, n - 1)$

```c++
class Solution {
public:

    int dfs(int begin, int end, string& s) {
        if (begin == end) {
            return 1;
        }
        if (begin > end) {
            return 0;
        }
        if (s[begin] == s[end]) {
            return dfs(begin + 1, end - 1, s) + 2;
        } 
        return max(dfs(begin + 1, end, s), dfs(begin, end - 1, s));
        
    }

    int longestPalindromeSubseq(string s) {
        return dfs(0, s.size() - 1, s);
    }
};
```

循环的写法：

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dp[i][j] 代表从 i 到 j 之间的最大回文子序列长度
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;

        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][s.size() - 1];
    }
};
```











```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int len = s.size();
        int dp[len + 1][len + 1];   // dp[i][j] 为 i 到 j 之间最长回文子序列的长度
        // 递推公式 ：if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2
        // 
        for (int i = 0; i <= len; i++) 
            for (int j = 0; j <= len; j++) {
                if (i == j) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = 0;
                }
            }

        for (int i = len - 1; i >= 0; i--) {
            for (int j = i + 1; j < len; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][len - 1];
    }
};
```

#### 020.LCR 回文子串

也是同样的方法，`dp[i][j]` 表示 `[i,j]` 之间的字符串是不是回文字符串。如果是，或者`j - i == 1`就是指两个只相差一个字符，那么 此时回文子串的数量就加一。

```c++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        int res = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j] && (j - i == 1 || dp[i + 1][j - 1] == 1)) {
                    dp[i][j] = 1;
                    res ++;
                }
            }
        }
        
        return res + s.size();
    }
};
```







## 每日一题

#### 189.轮转数组

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        unordered_map<int, int> pair;

        for (int i = 0; i < nums.size(); i++) {
            int second = nums[i];
            int first = (i + k) % nums.size();
            // pair.insert({first, second});
            pair[first] = second;
        }

        cout << pair.size() << endl;

        for (auto pair_ : pair) {
            nums[pair_.first] = pair_.second;
        }
    }
};
```













#### 56.合并区间

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](const vector<int> &a, const vector<int> &b) {return a[0] < b[0]; });
        vector<vector<int>> res;
        vector<int> res_tmp;
        int cnt;
        for (int i = 0; i < intervals.size(); i++) {
            res_tmp.push_back(intervals[i][0]);
            cout << "intervals[i][0]:" << intervals[i][0] << endl;
            int end = intervals[i][1];
            cnt = i + 1;
            for (cnt; cnt < intervals.size(); cnt ++) {
                if (end >= intervals[cnt][0]) {
                    if (end <= intervals[cnt][1]) {
                        end = intervals[cnt][1];
                    }
                } else {
                    break;
                }
            }
            res_tmp.push_back(end);
            i = cnt - 1;
            res.push_back(res_tmp);
            res_tmp.clear();
        }
        return res;
    }
};
```



#### 2024年5月24日-1673.找出最具竞争力的子序列

给你一个整数数组 `nums` 和一个正整数 `k` ，返回长度为 `k` 且最具 **竞争力** 的 `nums` 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 `a` 和子序列 `b` 第一个不相同的位置上，如果 `a` 中的数字小于 `b` 中对应的数字，那么我们称子序列 `a` 比子序列 `b`（相同长度下）更具 **竞争力** 。 例如，`[1,3,4]` 比 `[1,3,5]` 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， `4` 小于 `5` 。

 

**示例 1：**

```
输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
```

**示例 2：**

```
输入：nums = [2,4,3,3,5,4,9,6], k = 4
输出：[2,3,3,4]
```

能够想到使用单调栈来进行单调递增数组的维护。比如`nums = [3, 5, 2, 6]` 可以计算出此时对于这个数组的单调递增数组序列为`[2, 6]` 。同理此时 `nums = [2, 4, 3, 3, 5, 4, 9, 6]` 可以计算出单调递增数组序列为`[2, 3, 3, 4, 6]` 。然后截取前 `k`个数字。由此可以知道，单调栈其实是符合这道题目的思想的。但是题目中有要求返回的数组的长度必须是 `k`。这就造成这种解法的局限性，比如`nums = [2, 4, 3, 3, 5, 4, 9, 6, 1]` 这种情况就无法解出正确答案，我们需要在每次维护单调栈的时候加入判断条件，就是栈顶元素出栈的时候，此时栈内元素数量加上数组`nums` 剩余元素的数量是否大于`k`。如果比`k`小，那么此时就不能出栈。

我们在实现的时候可以直接用`vector`进行栈操作的模拟。

```c++
class Solution {
public:
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        if (nums.size() == k) return nums;
        
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            int x = nums[i];
            while (!res.empty() && x < res.back() && res.size() + nums.size() - i > k) {
                res.pop_back();
            }
            if (res.size() < k) {
                res.push_back(x);
            }
        }
        return res;
    }
};
```







### 1.动态规划

##### 回文串判定

```c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        vector<vector<int>> dp(n, vector<int>(n));
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= n; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < n; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= n) {
                    break;
                }

                if (s[i] != s[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
}
```

```c
char * longestPalindrome(char * s){
    int maxLen = 1, start = 0;
    int len = strlen(s);
    int dp[1005][1005];                             //用来记录字串是否是回文串
    for (int i = 0; i < 1005; i++)
        dp[i][i] = 1;
    if (len < 2) return s;
    else{
        for (int L = 2; L <= len; L++) {            //枚举字串长度
            for (int i = 0; i < len; i++){          //枚举左边界
                int j = L + i - 1;                  //生成右边界
                if (j >= len) break;                //如果右边界越界则循环退出
                if (s[i] != s[j]) {
                    dp[i][j] = 0;                   //此时s[i][j]字串不是回文串
                } else {
                    if (j - i < 3) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && (j - i + 1) > maxLen) {
                    start = i;
                    maxLen = j - i + 1;
                }
            }
        }
        s[maxLen + start] = '\0';
        return &s[start];
    } 
}
```

##### 2707.字符串中的额外字符

![截屏2024-01-09 20.36.45](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-09 20.36.45.png)

```c++
class Solution {
public:
    int minExtraChar(string s, vector<string>& dictionary) {
        // 动态规划 dp[i] 为 s[0:i] 中剩余字符最小
        // 正常情况下：dp[i + 1] = dp[i] + 1
        // 当出现子串：dp[i + 1] = min(dp[i + 1], dp[j])(遍历 0 - i 之间的子串)
        unordered_set<string> dict(dictionary.begin(), dictionary.end());
        int n = s.size();
        vector<int> dp(n + 1);
        for (int i = 0; i < n; ++i) {
            dp[i + 1] = dp[i] + 1;
            for (int j = 0; j <= i; ++j) {
                if (dict.count(s.substr(j, i - j + 1))) {
                    dp[i + 1] = min(dp[i + 1], dp[j]);
                }
            }
        }
        return dp[n];

    }
};
```

##### 1143.最长公共子串

![截屏2024-02-18 22.37.52](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-02-18 22.37.52.png)

定义：`dp[i][j]:=s1...si和t1...tj` 对应的LCS的长度。由此，`s1...si+1和t1...tj+1` 对应的公共子列可能是：

- 当 `si+1 = tj+1` 时， 在 `s1...si 和 t1...tj` 的公共子列末尾追加上 `si+1`
- `s1...si+1 和 t1...tj ` 的公共子序列
- `s1...si 和 t1...tj+1 ` 的公共子序列

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int text1Len = text1.size(), text2Len = text2.size();
        int dp[text1Len + 1][text2Len + 1];

        for (int i = 0; i <= text1Len; i++)
            for (int j = 0; j <= text2Len; j++) dp[i][j] = 0;

        for (int i = 0; i < text1Len; i++) {
            for (int j = 0; j < text2Len; j++) {
                if (text1[i] == text2[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
                else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }

        return dp[text1Len][text2Len];
    }
};
```

#### 139.单词拆分

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        auto wordDictSet = unordered_set <string> ();
        for (auto word : wordDict) wordDictSet.insert(word);

        auto dp = vector<bool>(s.size() + 1);
        dp[0] = true;

        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.find(s.substr(j ,i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
```











### 2.相向双指针

#### 11.盛最多水的容器

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-19 23.00.57.png" alt="截屏2023-12-19 23.00.57" style="zoom:50%;" />

使用相向双指针，`left` 和`right`。回到这个题目，你会发现，对于最后一根线，在中间任何比他矮的线替换他都无法使得当前的面积大于现在的面积。也就是说，我们要想获得可能（因为更换后还是可能小于当前面积的）大于当前面积的情况，我们只能选择较小的`left` 和 `right` 来进行替换。举个🌰，对于`height[0]` 和 `height[8]` 来说，当前的面积是`7`。要想获得大于当前面积的选择，我们只能选择`height[0]`和`height[8]` 之间较小的值进行替换才有可能获得大于当前的面积。也就是说，我们此时选择`left++` ，得到 `height[1]` ，此时的面积是`49`。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int res = 0;

        while (left < right) {
            res = max(res, min(height[left], height[right]) * (right - left));
            if (height[left] < height[right]) left++;
            else right--;
        }
        return res;

    }
};
```

复杂度分析：

时间复杂度：O(n) 

空间复杂度：O(1)



### 3.同向双指针

#### 100137.统计最大元素出现至少K次的子数组

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 14.15.07.png" alt="截屏2023-12-10 14.15.07" style="zoom:50%;" />

**同向双指针+滑动窗口** 

在子数组子串问题中，经常会用到双指针这一技巧 。举个例子：给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其和 `>=target`的长度最小的 **连续子数组** `nums` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` .

例如209题目。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLen = nums.size() + 1;

        int left = 0;
        int right = 0;
        int sum = 0;
        for (; right < nums.size(); right++)
        {
            sum += nums[right];
            while ((sum - nums[left]) >= target)
            {
                sum -= nums[left];
                left ++;
            }
            if (sum >= target) minLen = min(minLen, right - left + 1);
        }
        return minLen <= nums.size() ? minLen : 0;
    }
};
```

 再比如**713.乘积小于K的子数组** 给定一个整数数组 `nums` 和一个整数 `k` ，返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目。万变不离其宗，元素都是正数，方法和上一题一样，对于 `[10, 5, 2, 6]` 比如枚举到 `2` 的时候，就把 `2` 接到上一次计算的结果后面。那如果元素的乘积 `>=k` 就把左端点右移，缩小子数组的长度，直到乘积小于 `k` 为止。那么问题的关键，也是与上题不同的点，**子数组的数目要怎么算** 这里，我们枚举到 `2` ，需要算的就是以 `2` 为右端点的满足要求的子数组的个数。`[5, 2]`算是一个， `[2]` 单独算一个。用代码来计算，就需要推导出来一个公式，假设此时左端点为 `l`，右端点为`r` 。那么我们现在需要计算的就是以 `r` 为右端点的子数组的个数。注意右端点是固定的，如果从 `l` 到 `r` 的这一段的乘积是小于 `k` 的。那么从 `l+1` 到 `r` 的这一段也是小于 `k` 的。一直到 `[r, r]` 这些子数组都是满足要求的。那么子数组的个数其实就是从 `l` 到 `r` 的元素个数。那么就是 `r-l+1` 

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) return 0;
        int left = 0;
        int right = 0;
        int sum = 1;
        int maxNums = 0;

        for (; right < nums.size(); right++)
        {
            sum *= nums[right];
            while (sum  >= k)
            {
                sum /= nums[left];
                left ++;  
            }
            maxNums += right - left + 1;
        }

        return maxNums;
    }
};
```

接着还有 **3.无重复字符的最长子串** 给定一个字符串 `s` ,找出其中不含重复字符的 **最长子串** 的长度。由于如果出现的重复字符的唯一情况就是刚刚加入的字符与之前的字符发生重复，所以我们只需要使用哈希的方法，统计一下刚加入的字符是否出现重复即可。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0;
        int right = 0;
        int maxLen = 0;
        unordered_map<char, int> mp;
        for (right; right < s.size(); right++)
        {
            mp[s[right]] ++;
            while (mp[s[right]] >= 2)
            {
                mp[s[left]] --;
                left ++;
            }
            maxLen = max(maxLen, right - left + 1);
        }
        return maxLen;
    }
};
```

回到这个题目，首先找到数组中的最大数，设 $mx=max(nums)$ 右端点 $right$ 从左到右遍历 $nums$ 。遍历到元素$x=nums[right]$  如果 $x=mx$ ，就把计数器 $cntMx$ 加一。如果此时 $cntMx = k$ 则不断右移左指针 $left$ ，直到窗内的 $mx$ 的出现次数 **小于** $k$ 为止。此时，对于右端点为 $right$ 且左端点小于 $left$ 的子数组，$mx$ 的出现次数都至少为 $k$ ，把答案增加 $left$ 。

```c++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        int left = 0;
        int right = 0;
        int maxVal = 0;
        for (int i = 0; i < nums.size(); i++) maxVal = max(maxVal, nums[i]);
        int maxValCnt = 0;
        long long sum = 0;

        for (right; right < nums.size(); right++)
        {
            if (nums[right] == maxVal) maxValCnt ++;
            while (maxValCnt == k)
            {
                if (nums[left] == maxVal) maxValCnt --;
                left ++;
            }
            sum += left;
        }

        return sum;
    }
};
```

### 4.二分查找法  红蓝染色法

#### 34.在排序数组中查找元素的第一个元素和最后一个位置

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.05.14.png" alt="截屏2023-12-20 22.05.14" style="zoom:50%;" />

暴力做法，从左到右依次遍历，但是暴力做法没有利用到数组是有序的这一性质。但是我们要如何利用到数组是有序的这一性质呢？我们可以利用两个指针`L`和`R`。我们把这两个指针初始化`L=0, R=n-1`，即分别指向数组的最左边元素和最右边元素。表示我们现在需要知道这个闭区间内的每个数和8的大小关系。即现在闭区间内的颜色都是不确定的。比如目前`M`这个位置，它比8小，由于数组是有序的，那么它左边的数一定比8小。如果它大于等于8，它右边的数也是大于等于8的。现在是`M`的取值问题，如果`M`取在中间，那么我们立刻就知道数组中一半的数与8的大小关系。

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.12.15.png" alt="截屏2023-12-20 22.12.15" style="zoom:50%;" />

我们用红色表示小于8的数，用蓝色表示大于8的数。

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.20.02.png" alt="截屏2023-12-20 22.20.02" style="zoom:50%;" />

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.21.44.png" alt="截屏2023-12-20 22.21.44" style="zoom:50%;" />

注意⚠️这里`L`更新为`M+1`，如果`L`更新为`M`。那么考虑只有一个元素的情况，这时候就是死循环。

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.24.25.png" alt="截屏2023-12-20 22.24.25" style="zoom:50%;" />

```c++
class Solution {
    // lower_bound 返回最小的满足 nums[i] >= target 的 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

    // 闭区间写法
    int lower_bound(vector<int> &nums, int target) {
        int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1; // 范围缩小到 [mid+1, right]
            else
                right = mid - 1; // 范围缩小到 [left, mid-1]
        }
        return left; // 或者 right+1
    }

    // 左闭右开区间写法
    int lower_bound2(vector<int> &nums, int target) {
        int left = 0, right = nums.size(); // 左闭右开区间 [left, right)
        while (left < right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1; // 范围缩小到 [mid+1, right)
            else
                right = mid; // 范围缩小到 [left, mid)
        }
        return left; // 或者 right
    }

    // 开区间写法
    int lower_bound3(vector<int> &nums, int target) {
        int left = -1, right = nums.size(); // 开区间 (left, right)
        while (left + 1 < right) { // 区间不为空
            // 循环不变量：
            // nums[left] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid; // 范围缩小到 (mid, right)
            else
                right = mid; // 范围缩小到 (left, mid)
        }
        return right; // 或者 left+1
    }

public:
    vector<int> searchRange(vector<int> &nums, int target) {
        int start = lower_bound(nums, target); // 使用其中一种写法即可
        if (start == nums.size() || nums[start] != target)
            return {-1, -1};
        // 如果 start 存在，那么 end 必定存在
        int end = lower_bound(nums, target + 1) - 1;
        return {start, end};
    }
};

```

#### 162.寻找峰值

![截屏2024-01-01 20.48.21](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01 20.48.21.png)

对于这道题目，主要的点在于要求时间复杂度必须在 $O(\log n)$。这就要求我们不能够考虑暴力解答的方法。而对于一个数组，从中查找数字时，一般反应是用到二分查找的方法。但是二分查找只适用于有序数组中。这里其实我们也是可以用二分的，跟之前的二分查找方法是一样。

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0, right = nums.size() - 2;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid - 1;
            } 
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 153.寻找旋转排序数组中的最小值

![截屏2024-01-01 22.18.01](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01 22.18.01.png)

找到小于左右的值。

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 2;
        int minNum = nums[nums.size() - 1];
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > minNum) {
                left = mid + 1;
            } 
            if (nums[mid] < minNum) {
                minNum = nums[mid];
                right = mid - 1;
            }
        }
        return minNum;
    }
};
```

#### 33.搜索旋转排序数组

![截屏2024-01-01 22.33.46](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01 22.33.46.png)

两次二分的方法。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 2;
        int minNum = nums[nums.size() - 1];
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > minNum) {
                left = mid + 1;
            } 
            if (nums[mid] < minNum) {
                minNum = nums[mid];
                right = mid - 1;
            }
        }
        if (target == minNum) return left;
        if (target > nums[nums.size() - 1]) {
            right = left;
            left = 0;
        }
        if (target <= nums[nums.size() - 1]) {
            right = nums.size() - 1;
        }
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } 
            if (nums[mid] > target) {
                right = mid - 1;
            }
            if (nums[mid] == target) {
                return mid;
            }
        }
        return -1;

    }
};
```

一次二分法：我们分3种情况讨论，什么时候，`nums[mid]`在`target`及其右侧，那么都染成蓝色。

1. 如果`nums[mid]`比最后一个数大，说明`nums[mid]`在左边这段，如果此时`target`也大于最后一个数。那么`target`跟`nums[mid]`在同一段。并且如果这个时候`nums[mid]`大于等于`target`。（说明`nums[mid]`在`target`及其右侧）那么`mid`及其右侧就染成蓝色。
2. 就是`nums[mid]`小于等于最后一个数，那么在右边这段。如果此时`target`还是大于最后一个数，那么`target`在左边这段，（直接就说明）`mid`及其右侧也染成蓝色。
3. 情况二不成立，`target`在第二段，`nums[mid]`大于等于`target`，那么也是蓝色。
4. 其余情况都是红色。

```c++
class Solution {
public:
    bool is_blue(vector<int>& nums, int i, int target) {
        int end = nums[nums.size() - 1];
        if (nums[i] > end) {
            return target > end && nums[i] >= target;
        } else {
            return target > end || nums[i] >= target;
        }
    }

    int search(vector<int>& nums, int target) {
        int left = -1, right = nums.size();
        while (left + 1 < right) {
            int mid = (right + left) / 2;
            if (is_blue(nums, mid, target)) {
                right = mid;
            } else {
                left = mid;
            }
        }

        if (right == nums.size() || nums[right] != target) return -1;
        return right;

    }
};
```













### 5.单调栈

单调栈分为单调递增栈和单调递减栈。对于一组数，从左到右依次入栈，如果栈为空或入栈元素小于栈顶元素，则入栈，否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。这是单调递增栈，单调递减栈相反。

```c++
stack<int> st;
//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解
for (遍历这个数组)
{
	if (栈空 || 栈顶元素大于等于当前比较元素)
	{
		入栈;
	}
	else
	{
		while (栈不为空 && 栈顶元素小于当前元素)
		{
			栈顶元素出栈;
			更新结果;
		}
		当前数据入栈;
	}
}

```

#### 1944.队列中可以看到的人数

![截屏2024-01-05 14.21.34](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-05 14.21.34.png)

倒过来看问题，这个问题从左向右看问题会很复杂，但是从右向左看就很好维护一个单调递减的单调栈。

```c++
class Solution {
public:
    vector<int> canSeePersonsCount(vector<int>& heights) {
        int heightsLen = heights.size();
        stack<int> s;
        vector<int> res(heightsLen, 0);
        if (heightsLen == 1) return res;

        for (int i = heightsLen - 1; i >= 0; i--) {
            while (!s.empty() && s.top() < heights[i]) {
                res[i]++;
                s.pop();
            }
            if (!s.empty()) {
                res[i] ++;
            }
            s.push(heights[i]);
        }
        return res;
    }
};
```





#### 2866.美丽塔

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-21 13.13.15.png" alt="截屏2023-12-21 13.13.15" style="zoom:50%;" />



根据题意可以知道，假设数组长度为 $n$ ，对于  **山状数组**  $heights$ 定义如下：

- 假设 $heights[i]$ 为数组中的最大值，则 $i$ 左边的值均小于等于 $heigjts[i]$ ，$i$ 右边的值均小于等于 $heights[i]$ 。
- $i$ 的左侧，从 $0$ 开始到 $i$ 为 **非递减** 关系，即 $j\in [1,i]$ 时，均满足 $heights[j-1] \leq heights[j]$ 
- $i$ 的右侧，从 $i$ 开始到 $n-1$ 为 **非递增** 关系，即 $j\in[i,n-2]$ 时，均满足 $heights[j+1] \leq heights[j]$

题目给出了 **山状数组** 中每个元素的上限，即 $heights[i]\leq maxHeights[i]$，题目要求返回山状数组所有元素之和的最大值。

- 对于 $j\in[0, i - 1]$ 时，此时 $\max(heights[j])=\min(heights[j+1], maxHeights[j])$ 
- 对于 $j\in [i + 1, n - 1]$ 时，此时 $\max(heights[j])=\min(heights[j-1],maxHeights[j])$ 
- 假设此时山状数组的山顶为 $heights[i]$ ，此时整个山状数组的所有元素的最大值即可确定，此时数组元素和的最大值也可确定
- 对于数组中的每个元素尽可能取最大值使得整个数组元素之和最大

根据以上分析，我们依次枚举以 $maxHeights[i]$ 为山顶的山状数组元素之和即可求出最大的高度和。最直接的办法是两层循环，但是此时需要的时间复杂度为 $O(n^2)$ ，会超时。

此时需要优化，对于每个索引 $i$ 可以将数组分为两部分处理，即保证数组的左侧构成非递减，右侧构成非递增。为了使得数组元素尽可能大，此时 $heights[i]$ 应取值为 $maxHeigths[i]$，设区间 $[0,i]$ 构成的非递减数组元素和的最大值为 $prefix[i]$ ，区间 $[i,n-1]$ 构成的非递增数组元素和最大值为 $suffix[i]$ ，此时构成的山状数组的元素之和为 $prefix[i]+suffix[i]-maxHeights[i]$ 。

如何使得数组成为递增或递减，此时我们想到 `单调栈` ，它可以保证栈中数据的单调性，利用单调栈将连续子数组变为非递减或非递增。

- 对于左侧的非递减：将 $maxHeights$ 依次入栈，对于第 $i$ 个元素来说，不断从栈顶弹出元素，直到栈顶元素小于等于 $maxHeights[i]$ 。假设此时栈顶元素为 $maxHeights[j]$ ，则区间 $[j+1,i-1]$ 中的元素最多只能取到 $maxHeights[i]$ ，则 $prefix[i]=prefix[j]+(i-j)\times maxHeights[i]$ 
- 对于右侧的非递减：将 $maxHeights$ 依次入栈，对于第 $i$ 个元素来说，不断从栈顶弹出元素，直到栈顶元素 直到栈顶元素小于等于 $maxHeights[i]$ 。假设此时栈顶元素为 $maxHeights[j]$ ，则区间 $[i+1,j-1]$ 中的元素最多只能取到 $maxHeights[i]$ ，则 $suffix[i]=suffix[j]+(j-i)\times maxHeights[i]$ 

我们按照上述规则枚举每个位置 $i$ ，并计算出以 $i$ 为山顶的数组之和，此时山状数组的最大值即为 $\max(prefix[i]+suffix[i]-maxHeights[i])$ 

```c++
class Solution {
public:
    long long maximumSumOfHeights(vector<int>& maxHeights) {
        int n = maxHeights.size();
        long long res = 0;
        vector<long long> prefix(n), suffix(n);
        stack<int> stack1, stack2;

        for (int i = 0; i < n; i++) {
            while (!stack1.empty() && maxHeights[i] < maxHeights[stack1.top()]) {
                stack1.pop();
            }
            if (stack1.empty()) {
                prefix[i] = (long long) (i + 1) * maxHeights[i];
            } else {
                prefix[i] = prefix[stack1.top()] + (long long) (i - stack1.top()) * maxHeights[i];
            }
            stack1.emplace(i);
        }

        for (int i = n - 1; i >= 0; i--) {
            while (!stack2.empty() && maxHeights[i] < maxHeights[stack2.top()]) {
                stack2.pop();
            }
            if (stack2.empty()) {
                suffix[i] = (long long) (n - i) * maxHeights[i];
            } else {
                suffix[i] = suffix[stack2.top()] + (long long) (stack2.top() - i) * maxHeights[i];
            }
            stack2.emplace(i);
            res = max(res, prefix[i] + suffix[i] - maxHeights[i]);
        }
        return res;
    }
};
```

### 枚举

#### 二进制枚举

```c++
#include<stdio.h>
#include<string>
#include<istream>
#include<iostream>
#include<vector>


int main()
{
    // std::vector<int> res;

    // for (int i = 0; i < 4; i++) res.push_back(i);
    for(int i = 0; i < (1 << 4); i++) //从0～2^n-1个状态
    {
        for(int j = 0; j < 4; j++) //遍历二进制的每一位
        {
            if(i & (1 << j))//判断二进制第j位是否存在
            {
                printf("%d ",j);//如果存在输出第j个元素
            }
        }
        printf("\n");
    }
    return 0;

}
/*
在这种情况下，输出的值为
0 => 1000
1 => 0100
0 1 => 1100
2 => 0010
0 2 => 1010
1 2 => 0110
0 1 2 => 1110
3 => 1=0001
0 3 => 1001
1 3 => 0101
0 1 3 => 1101
2 3 => 0011
0 2 3 => 1011
1 2 3 => 0111
0 1 2 3 => 1111
*/




```

#### [2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/)

```c++
#include<stdio.h>
#include<string>
#include<istream>
#include<iostream>
#include<vector>
#include<bitset>
#include<map>

using namespace std;

class Solution {
public:
    int maximumRows(vector<vector<int>>& matrix, int numSelect) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> mask(m, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++){
                mask[i] += matrix[i][j] << (n - j - 1); // 计算每一行的十进制值 0, 5, 3, 1
            }
        }

        cout << "mask:" << endl;

        for (int i = 0; i < mask.size(); i++) cout << mask[i] << " ";
        cout << endl;

        int res = 0;
        int cur = 0;
        int limit = (1 << n); // 进行二进制枚举，共有 2^n 种情况，就是1 左移 3 位的值
        cout  << "limit: " << limit << endl;
        while ((++cur) < limit) {
            cout << "cur: " << cur << " cur的二进制：" << bitset<3>(cur) << " __builtin_popcount(cur): " << __builtin_popcount(cur) << endl;
            if (__builtin_popcount(cur) != numSelect) {
                continue;
            }
            int t = 0;
            for (int j = 0; j < m; j++) {
                if ((mask[j] & cur) == mask[j]) { // 与运算，如果两位都为1结果才是1，
                    ++t;
                }
            }
            res = max(res, t);
        }
        return res;
    }
};



int main()
{
    Solution s;
    vector<vector<int>> matrix{{0, 0, 0}, {1, 0, 1}, {0, 1, 1}, {0, 0, 1}};
    int res = s.maximumRows(matrix, 2);
    std::cout << res << std::endl;
    return 0;

}

```







#### 100169.[移除栅栏得到的正方形田地的最大面积](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/)

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-24 12.28.03.png" alt="截屏2023-12-24 12.28.03" style="zoom:50%;" />

相当于给顶一些横线竖线，找出这些横线竖线之间可能构造出来的最大正方形。正方形两条边边长一样，因此找到的横线的横坐标之差需要等于找到的竖线的纵坐标之差。由于横线竖线数量相对不多，我们可以直接枚举所有情况，看其中是否有公共元素，找出最大的公共元素算平方即可。这只需要通过哈希表记录判断即可。

```c++
class Solution {
public:
    const int MOD = 1e9 + 7;
    int maximizeSquareArea(int m, int n, vector<int>& hFences, vector<int>& vFences) {
        hFences.push_back(1);
        hFences.push_back(m);
        vFences.push_back(1);
        vFences.push_back(n);
        sort(hFences.begin(), hFences.end());
        sort(vFences.begin(), vFences.end());
        int hFencesLen = hFences.size(), vFencesLen = vFences.size();
        int res = -1;
        unordered_map<int, int> mp;

        for (int i = 0; i < hFencesLen; i++) {
            for (int j = 0; j < i; j++) {
                mp[abs(hFences[i] - hFences[j])]++;
            }
        }

        for (int i = 0; i < vFencesLen; i++) {
            for (int j = 0; j < i; j++) {
                if (mp[abs(vFences[i] - vFences[j])]) {
                    int a = abs(vFences[i] - vFences[j]);
                    res = max(res, a);
                }
            }
        }

        return res == -1 ? -1 : ((long)res * (long)res) % MOD;
    }
};
```

#### 找出出现至少三次的最长特殊子字符串 I

![截屏2023-12-31 12.09.55](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-31 12.09.55.png)

长度为 $x$ 的特殊字符串里包含几个长度为 $y$ 的子串？答案是 $(x - y + 1)$ 个。

设原串中，最长的特殊子串长度为 $m$ ，那么长度为 $(m - 2)$ 的子串在该串中至少出现 $m - (m - 2) + 1 = 3$ 次，因此答案至少是 $(m-2)$，至多是 $m$ 。

因此直接从 $m$ 到 $(m - 2)$ 枚举答案，并计算这个长度的特殊子串有几个即可。



```c++
class Solution {
public:
    int maximumLength(string s) {
        int sLen = s.size();
        vector<int> vec[26];
        int len = 1;
        char last = s[0];
        for (int i = 1; i < sLen; i++) {
            if (s[i] != last) {
                vec[last - 'a'].push_back(len);
                last = s[i];
                len = 0;
            }
            len++;
        }
        vec[last - 'a'].push_back(len);

        int mx = 0;
        for (int i = 0; i < 26; i++) {
            for (auto v : vec[i]) {
                mx = max(mx, v);
            }
        }

        for (int ans = mx; ans >= mx - 2 && ans ; ans--) {
            for (int i = 0; i < 26; i++) {
                int cnt = 0;
                for (auto v : vec[i]) {
                    if (v >= ans) cnt += (v - ans) + 1;
                    if (cnt >= 3) return ans;
                }
            }
        }

        return -1;
    }
};
```





### 建图-floyd

#### [100156. 转换字符串的最小成本 I](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/)

建图，从 $original[i]$ 向 $changed[i]$ 连边，边权为 $cost[i]$ 。然后用Floyd算法求图中任意两点最短路，得到 $dis$ 矩阵，最后累加所有的 $dis[original[i]][changed[i]]$ ，即为答案，如果答案为无穷啊，返回-1.

```c++
class Solution {
public:
    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {
        int n = original.size();
        vector<vector<int>> g(26, vector<int>(26, 10000001));

        for (int i = 0; i < 26; i++) g[i][i] = 0;

        for (int i = 0; i < n; i++) {
            int o = original[i] - 'a';
            int c = changed[i] - 'a';
            g[o][c] = min(g[o][c], cost[i]);
        }

        // Floyd
        for (int k = 0; k < 26; k++) {
            for (int x = 0; x < 26; x++) {
                for (int y = 0; y < 26; y++) {
                    g[x][y] = min(g[x][y], g[x][k] + g[k][y]);
                }
            }
        }

        int m = source.size();
        long long ans = 0;
        for (int j = 0; j < m; j++) {
            int cur = g[source[j] - 'a'][target[j] - 'a'];
            if (cur >= 10000001) return -1;
            ans += cur;
        }
        return ans;
    }
};
```

#### [2735. 收集巧克力](https://leetcode.cn/problems/collecting-chocolates/)

**巧妙枚举**

- 枚举操作次数，从操作`0`次枚举到操作`n-1`次
- 如果不操作，第 $i$ 个巧克力必须花费 $nums[i]$ 收集，总花费为所有 $nums[i]$ 之和。如果只操作一次，第 $i$ 个巧克力可以在操作前购买，取最小值，即 $\min(nums[i], num[(i + 1) \mod n])$ .如果操作两次，购买第 $i$ 个巧克力的花费为 $\min(nums[i], nums[(i + 1) \mod n], nums[(i + 2) \mod n])$。例如示例1，我们可以操作两次，这样每块巧克力都只需要1的花费，总成本为 $2x+1+1+1=13$。
- 如果暴力枚举操作次数，再枚举每个巧克力，再计算购买这个巧克力的最小花费，总的时间复杂度是 $O(n^3)$。一个初步的优化是，用 $O(n^2)$ 的时间预处理所有子数组的最小值，保存到一个二维数组中。这样做需要 $O(n^2)$ 的时间和空间。但其实不需要与处理：
  1. 用一个长为 $n$ 的数组 $s$ 统计不同操作次数下的总成本。
  2. 写一个二重循环，枚举子数组的左端点 $i$ 和右端点 $j$。
  3. 在枚举右端点的同时，维护从 $nums[i]$ 到 $nums[j]$ 的最小值 $mn$ 。
  4. 把 $mn$ 加到 $s[j - i]$ 中，这是因为长为 $j - i + 1$ 的子数组恰好对应着操作 $j-i$ 次时要计算的子数组。
  5. 最后输出 $\min(s)$ 。

```c++
class Solution {
public:
    long long minCost(vector<int>& nums, int x) {
        int n = nums.size();
        vector<long long> s(n);  // s[k] 统计操作 k 次的总成本
        for (int i = 0; i < n; i++) {
            s[i] = (long long) i * x;
        }
        for (int i = 0; i < n; i++) {
            int mn = nums[i];
            for (int j = i; j < n + i; j++) { // 子数组右端点（把数组视为环形的） 
                mn = min(mn, nums[j % n]);  // 维护从 nums[i] 到 nums[j] 的最小值
                s[j - i] += mn;  // 累加操作 j - i 次的花费
            }
        }
        return *min_element(s.begin(), s.end());
    }
};
```

#### 链表

##### 206反转链表

![截屏2024-01-02 22.42.44](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02 22.42.44.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
    
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;

    }
};
```

##### 92.反转链表

![截屏2024-01-02 22.58.03](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02 22.58.03.png)

从上题可以知道，反转结束后，从原来的链表上看： $pre$ 指向反转这一段的末尾，$cur$ 指向反转这一段后续的下一个节点。

![截屏2024-01-02 23.26.25](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02 23.26.25.png)



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* p0 = dummy;

        for (int i = 0; i < left - 1; i++) p0 = p0->next;

        ListNode* pre = nullptr;
        ListNode* cur = p0->next;

        for (int i = 0; i < right - left + 1; i++) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        p0->next->next = cur;
        p0->next = pre;

        return dummy->next;
    }
};
```

##### 25.K个一组反转链表

![截屏2024-01-02 23.50.11](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02 23.50.11.png)



![截屏2024-01-02 23.46.44](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02 23.46.44.png)

跟上边的题目类似，不过这里主要是注意，$p0$的变化，在一次反转之后，我们把 $next$ 改为 $p0\to next$ ，即1位置，其实这也是经过反转后的下一个 $p0$的起始位置。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int ListNodeLen = 0;
        ListNode* cur = new ListNode(-1);
        cur = head;
        while (cur) {
            cur = cur->next;
            ListNodeLen ++;
        }

        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* p0 = dummy;

        while (ListNodeLen >= k) {
            ListNodeLen -= k;
            ListNode* pre = nullptr;
            cur = p0->next;
            ListNode* next = new ListNode(-1);
            for (int i = 0; i < k; i++) {
                next = cur->next;
                cur->next = pre;
                pre = cur;
                cur = next;
            }
            next = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = next;
        }
        return dummy->next;
    }
};
```

##### 2487.从链表中移除节点

![截屏2024-01-03 17.15.59](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 17.15.59.png)

反过来遍历，每次保存遍历中的最大值。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNodes(ListNode* head) {
        // 将链表反转
        ListNode* pre = nullptr;
        ListNode* cur = head;
    
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        vector<ListNode*> vec;
        int max = 0;

        while (pre) {
            if (pre->val >= max) {
                vec.push_back(pre);
                max = pre->val;
            }
            pre = pre->next;
        }

        ListNode* res = new ListNode(-1);
        res = vec[vec.size() - 1];

        for (int i = vec.size() - 1; i > 0; i--) {
            vec[i]->next = vec[i - 1];
        }
        vec[0]->next = nullptr;
        return res;
    }
};
```

##### 876.链表的中间结点

![截屏2024-01-03 22.22.21](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 22.22.21.png)

使用快慢指针，我们可以用两个指针，一个叫做慢指针，一个叫做快指针。每次循环，慢指针走一步，快指针走两步。我们可以通过数学归纳法，证明长度为奇数的时候，如果快指针在最后一个节点，那么慢指针一定在中间结点。对于偶数长度也是一样的。 如果快指针指向空，那么慢指针一定在中间结点上。

![截屏2024-01-03 22.28.44](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 22.28.44.png)

综合这两种情况，当快指针指向空，或者他的下一个节点指向空，这个时候就退出循环，

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* node1 = head;
        ListNode* node2 = head;
        while (node1 && node1->next) {
            node1 = node1->next;
            node1 = node1->next;
            node2 = node2->next;
        }
        return node2;
    }
};
```

##### 141.环形链表

![截屏2024-01-03 22.35.14](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 22.35.14.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* node1 = head;
        ListNode* node2 = head;
        while (node1 && node1->next) {
            node1 = node1->next;
            node1 = node1->next;
            node2 = node2->next;
            if (node1 == node2) {
                return true;
            }
        }
        return false;
    }
};
```

##### 142.环形列表2

![截屏2024-01-03 22.40.21](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 22.40.21.png)

![截屏2024-01-03 22.40.50](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 22.40.50.png)

 快指针移动距离是慢指针的两倍，
$$
2(a+b)=a+b+k(b+c)\\
2a+2b=a+b+b+c+(k-1)(b+c)\\
a-c=(k-1)(b+c)
$$
![截屏2024-01-03 22.43.28](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 22.43.28.png)

 

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* node1 = head;
        ListNode* node2 = head;
        while (node1 && node1->next) {
            node1 = node1->next;
            node1 = node1->next;
            node2 = node2->next;
            if (node1 == node2) {
                while (node2 != head) {
                    node2 = node2->next;
                    head = head->next;
                }
                return node2;
            }
        }
        return NULL;
    }
};
```

##### 重排链表

![截屏2024-01-03 22.59.08](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03 22.59.08.png)

找到中间结点，然后将中间结点之后的结点全部反转，之后再进行两个链表的交错排列即可。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }

        // 将链表反转
        ListNode* pre = nullptr;
        ListNode* cur = slow;
    
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        // head2 为当前反转链表的头节点。
        ListNode* head1 = head;
        ListNode* head2 = pre;

        while (head2 != slow && head2->next) {
            ListNode* next1 = head1->next;
            ListNode* next2 = head2->next;
            head1->next = head2;
            head2->next = next1;
            head1 = next1;
            head2 = next2;
        }

    }
};
```

##### 2807.在链表中插入最大公约数

![截屏2024-01-06 20.21.08](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-06 20.21.08.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    int gcd(int m, int n) {
        while (n != 0) {
            int temp = m % n;
            m = n;
            n = temp;
        }
        return m;
    }
    ListNode* insertGreatestCommonDivisors(ListNode* head) {
        ListNode* pre = new ListNode(-1);
        ListNode* next = new ListNode(-1);

        pre = head;
        while (pre && pre->next) {
            next = pre->next;
            int tmp = gcd(pre->val, next->val);
            ListNode* cur = new ListNode(-1);
            cur->val = tmp;
            cur->next = pre->next;
            pre->next = cur;
            pre = cur->next;
        }
        return head;
    }
};
```

##### 237.删除链表重复节点

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;

    }
};
```

##### 19.删除链表的倒数第N个节点

首先，在之前的反转链表的题目，有些题目用到了哨兵节点这个技巧，那么什么时候需要哨兵节点，什么时候不需要哨兵节点？对于删除节点来说，一般来说需要删除头节点的话，需要哨兵节点。

对于这个题目来说，我们可以先让一个指针走完整个链表，求出链表长度，再结合n求出倒数第N个节点在链表哪个位置。

我们也可以初始化左右指针，当右指针走到第n个位置的时候，我们让左指针开始移动，这样左右指针中间相差n个位置。当右指针走到底的时候，左指针就是答案。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1);
        ListNode* left = new ListNode(-1);
        ListNode* right = new ListNode(-1);
        dummy->next = head;
        left = dummy;
        right = dummy;
        int cnt = 0;
        
        while (right && right->next) {
            if (cnt >= n) {
                left = left->next;
            }
            right = right->next;
            cnt++;
        }

        left->next = left->next->next;

        return dummy->next;
    }
};
```

##### 83.删除排序链表中的重复元素

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        ListNode* next = new ListNode(-1);
        dummy = head;
        if (!head || !head->next ) return dummy;
        next = head->next;

        while (head->next) {
            if (head->val == head->next->val) {
                head->next = head->next->next;  
            } else {
                head = head->next;
            }
            
        }
        return dummy;
    }
};
```

##### 82.删除排序链表中的重复元素2

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* cur = dummy;

        while (cur->next && cur->next->next) {
            int val = cur->next->val;
            if (cur->next->next->val == val) {
                while (cur->next && cur->next->val == val) {
                    cur->next = cur->next->next;
                }
            } else {
                cur = cur->next;
            }
        }

        return dummy->next;
    }
};
```



### 二叉树与递归

如何计算二叉树的深度，不要一开始就陷入细节，而是思考整棵树与其左右子树的关系。整棵树的深度=max（左子树的最大深度，右子树的最大深度）+1.。这样思考后，你会发现，原问题：计算整棵树的最大深度，子问题：计算左/右子树的最大深度。子问题与原问题是相似的。类比循环，执行的代码也应该是相同的，但子问题需要把计算结果返给上一级问题，这更适合用递归实现。由于子问题的规模比原问题小，不断递归下去，总会有个尽头，即递归的边界条件（base case）。直接返回它的答案（归）。

#### 104.二叉树的最大深度

![截屏2024-01-19 15.22.07](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19 15.22.07.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int deep(TreeNode* root) {
        if (!root) return 0;
        int l_d = deep(root->left);
        int l_r = deep(root->right);
        return max(l_d, l_r) + 1;
    }

    int maxDepth(TreeNode* root) {
        return deep(root);
    }
};
```

#### 100.相同的树

![截屏2024-01-19 16.13.09](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19 16.13.09.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p || !q) {
            return p == q;
        }
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

#### 101.对称二叉树

![截屏2024-01-19 16.18.30](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19 16.18.30.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p || !q) {
            return p == q;
        }
        return p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left);
    }
    bool isSymmetric(TreeNode* root) {
        return isSameTree(root->left, root->right);
    }
};
```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int deep(TreeNode* root) {
        if (!root) return 0;
        int l = deep(root->left);
        if (l == -1) return -1;
        int r = deep(root->right);
        if (r == -1 || abs(r - l) > 1) return -1;
        return max(l, r) + 1;
    }

    bool isBalanced(TreeNode* root) {
        return deep(root) == -1 ? false : true;
    }
};
```

#### 199.二叉树的右视图

![截屏2024-01-19 16.39.27](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19 16.39.27.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    void f(TreeNode* node, int depth) {
        if (!node) return;
        if (depth == ans.size()) {
            ans.push_back(node->val);
        }
        
        f(node->right, depth + 1);
        f(node->left, depth + 1);
    }


    vector<int> rightSideView(TreeNode* root) {
        f(root, 0);
        return ans;
    }
};
```























### 周赛

#### 380-2024-1-14

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-14 18.46.28.png" alt="截屏2024-01-14 18.46.28" style="zoom:50%;" />

```c++
class Solution {
public:
    int maxFrequencyElements(vector<int>& nums) {
        int numsLen = nums.size();
        vector<int> cnt(105, 0);
        int max_nums = -1;
        int res = 0;
        for (int i = 0; i < numsLen; i++) {
            cnt[nums[i]] ++;
            if (cnt[nums[i]] > max_nums) {
                max_nums = cnt[nums[i]];
                res = max_nums;
            }
            else if (cnt[nums[i]] == max_nums) {
                res += max_nums;
            }
        }
        return res;
    }
};
```



![截屏2024-01-14 18.47.10](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-14 18.47.10.png)

一开始想的是直接暴力，结果就是超时。WAWA！

两种解法：

1. 二分+数位DP
2. 二分+枚举数位

要用到二分，就要考虑是否有单调性，对于这道题目，我们观察到`num` 越大 其价值和越大，这就是题目包含的单调性。

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-14 18.58.33.png" alt="截屏2024-01-14 18.58.33" style="zoom:50%;" />

我们需要找到一个小于等于`k` 的最大的一个包含num的ans。这样就变成了，给定 `num` 统计 `1~num` 的价值和，判断价值和是否 `<=k` 。二分相当于多花费 `log` 的时间，额外增加一个条件。

**数位DP模版**

```c++
class Solution {
public:
    long long findMaximumNumber(long long k, int x) {
        auto check = [&](long long num) {
            int m = 64 - __builtin_clzll(num);  //确定一个整数的二进制表示中有多少位
            vector<vector<long long>> memo(m, vector<long long>(m + 1, -1));
            function<long long(int, int, bool)>dfs = [&](int i, int cnt1, bool is_limit) -> long long {
                if (i < 0) return cnt1;
                if (!is_limit && memo[i][cnt1] >= 0) return memo[i][cnt1];
                int up = is_limit ? num >> i & 1 : 1;
                long long res = 0;
                for (int d = 0; d <= up; d++) {
                    res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0), is_limit && d == up);
                }
                if (!is_limit) memo[i][cnt1] = res;
                return res;
            };
            return dfs(m - 1, 0, true) <= k;
        };

        // 
        long long left = 0, right = (k + 1) << x;
        while (left + 1 < right) {
            long long mid = left + (right - left) / 2;
            (check(mid) ? left : right) = mid;
        }
        return left;
    }
};
```



### 杂乱题目

#### 	2023年5月

##### 填充每个节点的下一个右侧节点指针

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-12 21.28.37.png" alt="截屏2023-05-12 21.28.37" style="zoom:50%;" />

对于二叉树问题，首先要想到几种遍历方法：

1. 前序遍历

2. 中序遍历

3. 后序遍历

4. 深度优先搜索DFS

5. 宽度优先搜索BFS

   这道题目要求的是把每一行都串联起来，那么BFS按层遍历就很合适。

   ```c++
   /*
   // Definition for a Node.
   class Node {
   public:
       int val;
       Node* left;
       Node* right;
       Node* next;
   
       Node() : val(0), left(NULL), right(NULL), next(NULL) {}
   
       Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
   
       Node(int _val, Node* _left, Node* _right, Node* _next)
           : val(_val), left(_left), right(_right), next(_next) {}
   };
   */
   // 这是一个BFS模版
   class Solution {
   public:
       void levelOrder(TreeNode* root)
       {
         if(root == nullptr) return;
         queue<TreeNode*> q;
         q.push(root);																				// 把节点添加到队列尾部
         while(!q.empty())
         {
           TreeNode* node = q.front();												// 出队列
           q.pop();
           if (node->left != nullptr)
             	q.push(node->left);
           if (node->right != nullptr)
             	q.push(node->right);
         }
       }
   };
   // 具体解题代码
   class Solution {
   public:
       Node* connect(Node* root) {
           if (root == nullptr) return root;
           queue<Node*> q;
           q.push(root);
           while(!q.empty())
           {
               int len_level = q.size();                   // 代表每一层节点的数量
               Node* pre = nullptr;                        // 前一个节点
               for (int i = 0; i != len_level; i++)
               {
                   Node* node = q.front();
                   q.pop();
                   if (pre != nullptr)
                       pre->next = node;
                   pre = node;
                   if (node->left)
                       q.push(node->left);
                   if (node->right)
                       q.push(node->right);
               }
           }
           return root;
       }
   };
   
   ```

##### 二叉搜索树中第K小的元素

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-13 21.48.17.png" alt="截屏2023-05-13 21.48.17" style="zoom:50%;" />

可以吧整个树都遍历一遍，然后吧结果存储到vector中，在进行排序找到第K小的元素。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        vector<int> vec;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            TreeNode* node = q.front();
            q.pop();
            vec.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        sort(vec.begin(), vec.end());
        return vec[k-1];
    }
};
```

------------------2023年5月13日-----------

##### 岛屿数量

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-13 21.56.03.png" alt="截屏2023-05-13 21.56.03" style="zoom:50%;" />

题目思路：DFS解决，

这题让求的是岛屿的数量，二维数组中值是1的都是岛屿，如果多个1是连着的，那么他们只能算一个岛屿。最简单的一种方式是遍历数组中的每一个数值，如果是1就说明是岛屿，然后把它置为0或者其他的字符都可以，然后再遍历他的上下左右4个位置。如果是1，就说明这两个岛屿是连着的，只能算是一个岛屿。我们还要把它置为0，然后以它为中心遍历它的上下左右4个位置。如果是0，就说明不是岛屿，就不在往它的上下左右4个位置遍历了。

```c++
class Solution {
public:
    // 把当前格子以及他邻近为1的格子都置为1
    void dfs(vector<vector<char>>& grid, int i, int j)
    {
        if (i < 0|| i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')
            return;
        // 把当前格子置为0，然后遍历他的上下左右4个方向
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }
    int numIslands(vector<vector<char>>& grid) {
        if (grid.size() == 0) return 0;
        int lands_cnt = 0;
        for (int i = 0; i != grid.size(); i++)
        {
            for (int j = 0; j != grid[0].size(); j++)
            {
                if (grid[i][j] == '1')
                {
                    lands_cnt ++;
                    dfs(grid, i, j);
                }
            }
        }
        return lands_cnt;
    }
};
```

但是显然，这种方法效率很差，单从两个嵌套的for循环来说，这里就已经是
$$
O(n^2)
$$
2023年5月16日22:22

------

##### 电话号码的字母组合

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-21 21.14.39.png" alt="截屏2023-05-21 21.14.39" style="zoom:50%;" />

可以使用BFS来进行搜索，将整个过程视为n叉树。

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-22 22.23.41.png" alt="截屏2023-05-22 22.23.41" style="zoom:50%;" />



```c++
#include <curl/curl.h>
#include <string>
#include <iostream>
#include <vector>
#include <queue>






int main() {
    std::string digits = "23";
    std::vector<std::string> res;
    if (digits.size() == 0)
    {
        for (int i = 0; i != res.size(); i++)
            std::cout << res[i] << " ";
        std::cout << std::endl;
    }

    std::vector<std::vector<char>> tab = {{'a', 'b', 'c'}, {'d', 'e', 'f'}, {'g', 'h', 'i'},
                                {'j', 'k', 'l'}, {'m', 'n', 'o'}, {'p', 'q', 'r', 's'},
                                {'t', 'u', 'v'}, {'w', 'x', 'y', 'z'}
                                };
    for (int i = 0; i != tab.size(); i ++)
    {
        for (int j = 0; j != tab[0].size(); j ++)
        {
            std::cout << tab[i][j] <<" ";
        }
        std::cout << std::endl;
    }

    std::queue<std::string> que;
    que.push("");
    while(que.front().size() != digits.size())
    {
        std::string remove = que.front();
        que.pop();
        std::vector<char> chars = tab[digits[remove.size()] - '2'];
        for (int i = 0; i < chars.size(); i++)
        {
            que.push(remove + chars[i]);
        }
    }
    while (!que.empty())
    {
        std::string str = que.front();
        std::cout << str << std::endl;
        res.push_back(str);
        que.pop();
    }




    std::cout << digits << std::endl;
    return 0;
}

```

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-22 23.12.09.png" alt="截屏2023-05-22 23.12.09" style="zoom:50%;" />

##### 有效括号生成

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-26 22.46.13.png" alt="截屏2023-05-26 22.46.13" style="zoom:50%;" />

通过观察我们可以发现，生成的任何括号组合中都有两个规律：

1. 括号组合中左括号的数量等于右括号的数量
2. 括号组合中任何位置左括号的数量都是大于等于右括号的数量

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-26 22.47.16.png" alt="截屏2023-05-26 22.47.16" style="zoom:50%;" />

```c++
class Solution {
public:
    void dfs(vector<string> &res, int left, int right, string cur_str)
    {
        if (left == 0 && right == 0) // 左右括号都不剩余了，说明找到了有效的括号
        {
            res.push_back(cur_str);
            return;
        }
        // 左括号只有剩余的时候才可以选，如果左括号的数量已经选完了，是不能再选左括号
        // 如果选完了左括号我们还是可以选择右括号的
        if (left < 0) return;
        // 如果右括号剩余数量小于左括号的剩余数量，说明之前选择的无效
        if (right < left) return;
        dfs(res, left - 1, right, cur_str + '(');
        dfs(res, left, right - 1, cur_str + ')');

    }

    vector<string> generateParenthesis(int n) {
        vector<string> res;
        dfs(res, n, n, "");
        return res;
    }
};
```

##### 全排列<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-27 21.40.35.png" alt="截屏2023-05-27 21.40.35" style="zoom:50%;" />

首先根据数学定义：全排列的总个数为 $n!$个。根据之前的思路，可以从搜索的方法入手。

<img src="/Users/huangqiuzhao/Downloads/IMG_6219E6E27471-1.jpeg" alt="IMG_6219E6E27471-1" style="zoom:50%;" />

```c++
// 回溯模版
void backtrack(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtrack(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
class Solution {

private:
    vector<vector<int>> result;
public:

    void backTrack(vector<int> &nums, int first, int len)
    {
        if (first == len)
        {
            result.emplace_back(nums);
            return;
        }
        for (int i = first; i < len; i++)
        {
            swap(nums[i], nums[first]);
            backTrack(nums, first + 1, len);
            swap(nums[i], nums[first]);
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        backTrack(nums, 0, nums.size());
        return result;
    }
};


```

##### 单词搜索

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-31 21.29.08.png" alt="截屏2023-05-31 21.29.08" style="zoom:50%;" />

首先反应就是之前遇到过的岛屿问题，进行DFS搜索，

```c++
class Solution {
public:
    bool dfs(vector<vector<char>>& board, string word, int i, int j, int index)
    {
        // 边界判断，如果越界直接返回false, index表示的是查找到字符串word的第几个字符
        // 如果这个字符不等于board[i][j], 说明这个坐标路径是走不通的, 直接返回false
        if (i >= board.size() || i < 0 || j >= board[0].size() || j < 0 || board[i][j] != word[index])
            return false;
        // 如果word的每个字符都查找完了，直接返回truetrue
        if (index == word.size() - 1)
            return true;
        // 把当前的坐标值保存下来，为了在最后复原
        char tmp = board[i][j];
        // 然后修改当前坐标的值
        board[i][j] = '.';
        // 走递归, 沿着当前坐标的上下左右4各方向查找
        bool res = dfs(board, word, i + 1, j, index + 1) || dfs(board, word, i - 1, j, index + 1) || dfs(board, word, i, j + 1, index + 1) || dfs(board, word, i, j - 1, index + 1);
        // 递归之后再把当前的坐标复原
        board[i][j] = tmp;
        return res;
    } 

    bool exist(vector<vector<char>>& board, string word) {
        for (int i = 0; i < board.size(); i++)
        {
            for (int j = 0; j < board[0].size(); j ++)
            {
                if (dfs(board, word, i, j, 0))
                    return true;
            }
        }
        return false;
    }
};
```

#### 2023年6月

##### 1、颜色分类

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-06-05 21.14.20.png" alt="截屏2023-06-05 21.14.20" style="zoom:50%;" />

感觉可以使用冒泡排序啊，原地进行排序。

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        for(int i = 0; i != nums.size(); i++)
        {
            for (int j = i + 1; j != nums.size(); j++)
            {
                int tmp = nums[i];
                if (nums[i] >= nums[j])
                {
                    nums[i] = nums[j];
                    nums[j] = tmp;
                }
            }
        }
    }
};
```

嘿嘿，果然一个冒泡排序就可以解决。但是效率太差了。这里还有一个三指针的做法，

```c++
class Solution {
public:
    void swap(vector<int>& nums, int right, int left)
    {
        int tmp = nums[right];
        nums[right] = nums[left];
        nums[left] = tmp;
    }
    void sortColors(vector<int>& nums) {
        // 0的右边界
        int right = 0;
        // 2的左边界
        int left = nums.size() - 1;
        // 指向当前数字
        int index = 0;
        while(index <= left)
        {
            if (nums[index] == 0)
            {
                swap(nums, right++, index++);
            }
            else if (nums[index] == 2)
            {
                swap(nums, left--, index);
            }
            else if (nums[index] == 1)
            {
                index ++;
            }
        }
    }
};
```

------

2023年6月5日21:28

#### 2023-7-10（WEEK1）

😮‍💨最近这一个月太堕落了，一个月都没有做力扣题目QAQ！要好好补一下。

  **认识复杂度和简单排序算法**

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

```c++
/选择排序

public static void selectionSort(vector<int>& arr)
{
  if (arr == NULL || arr.size() < 2)
    return;
  for (int i = 0; i < arr.size(); i++)
  {
    int minIndex = i;
    for (int j = i + 1; j < arr.size(); j++)
    {
      minIndex = arr[j] < arr[minIndex] ? j : minIndex;
    }
    swap(arr, i, minIndex);
  }
}

public static void swap(vector<int>& arr, int i, int j)
{
  int tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}

```

```c++
// 冒泡排序
void  swap(std::vector<int> & arr; int i; int j)
{
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[i] ^ arr[j];
arr[i] = arr[i] ^ arr[j];
}


void bubbleSort(std::vector<int> & arr)
{
    if (arr.size() < 2)
        return;
    for (int e = arr.size() - 1; e > 0; e --)
    {
        for (int i = 0; i < e; i++)
        {
            if (arr[i] > arr[i + 1])
                swap(arr, i, i + 1);
        }
    }
}
```

#### 2023-10-8

周赛错题记录：

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 12.09.20.png" alt="截屏2023-10-08 12.09.20" style="zoom:50%;" />

考虑两个数 $a$和 $b$的二进制表示，讨论二进制第 $i$位在 $a$和 $b$中是否为1的情况：

- 若a和b的第i位都是0，那么`a AND b` 和`a OR b`的第i位也都是0.
- 若a和b的第i位恰有一个1，那么`a AND b` 的第i位是0，`a OR b`的第i位是1.
- 若 *a* 和 *b* 的第 i*i* 位都是 1，那么 `a AND b` 和 `a OR b` 的第 i 位也都是 1。

令`f(a)`表示`a`的二进制表示中有几个1，不难发现`f(a) + f(b) = f(a AND b) + f(a OR b)`。只不过所有的1首先都被 `a OR b`抢了，剩下的1才会留给 `a AND b`。也就是说，每个二进制位中，1的总数不变。只不过我们可以通过任意次操作，把1都集中在某个数里。为了选择$k$个元素使得平方和最大，我们首先 要让$k$个元素尽可能大。在 $k$个元素的总和相同的情况下，我们还要让最大值尽可能大（证明可以考虑 $y=x^2+(c-x)^2$的函数图像）
我们把 1 都集中在某个数里，完美符合这两条性质。

因此做法就是统计每个二进制位里有多少个1，然后用这些1拼出尽可能大的数。

> ### 按位与[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)（&）
>
> 参加运算的两个数据，按**二进制位**进行“与”运算。
> 运算规则：0&0=0; 0&1=0; 1&0=0; 1&1=1;
> 即：**两位同时为“1”，结果才为“1”，否则为0**
>
> ### 按位或运算符（|）
>
> 参加运算的两个对象，按二进制位进行“或”运算。
> 运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；
> 即 ：**参加运算的两个对象只要有一个为1，其值为1**。
>
> ### 异或运算符（^）
>
> 参加运算的两个数据，按二进制位进行“异或”运算。
> 运算规则：0^0=0； 0^1=1； 1^0=1； 1^1=0；
> 即：**参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。**
>
> ### 按位取反运算符（~）
>
> 按位取反运算符（~）是指将整数的各个二进制位都取反，即1变为0，0变为1。
>
> ### 按位左移运算符（<<）
>
> 左移运算符是用来将一个数的各二进制位左移若干位，移动的位数由右操作数指定（右操作数必须是非负值），其右边空出的位用0填补，高位左移溢出则舍弃该高位。
>
> 在高位没有1的情况下，左移1位相当于该数乘以2，左移2位相当于该数乘以2*2＝4,15＜＜2=60，即乘了４。
> 但此结论只适用于该数左移时被溢出舍弃的高位中不包含1的情况。
>
> ### 按位右移运算符（>>）
>
> 右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负值），移到右端的低位被舍弃，对于无符号数，高位补0。对于有符号数，某些机器将对左边空出的部分用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。

```c++
class Solution {
public:
    
    int maxSum(vector<int>& nums, int k) {
        const int MAXP = 30;
        // cnt[i]表示第i个二进制位有几个1
        int cnt[35] = {0};
        for (auto x : nums)
        {
            for (int i = 0; i <= MAXP; i++)
            {
                cnt[i] += x >> i & 1;
                // x 右移 i 位 第i位与1进行与运算。判断该位是否是1.
            }
        }
        
        long long ans = 0;
        const int MOD = 1e9 + 7;
        // 拼出尽可能大的k个数
        while(k--)
        {
            int now = 0;
            for (int i = MAXP; i >= 0; i--)
            {
                if (cnt[i])
                    // 表示 第i位为1 把第i位拼进now中。
                {
                    now |= 1 << i;
                    cnt[i]--;
                } 
            }
            ans = (ans + 1LL * now * now) % MOD;
        }
        return ans;
        
        
    }
};
```



<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 12.41.46.png" alt="截屏2023-10-08 12.41.46" style="zoom:50%;" />

什么时候返回-1？

注意到，反转两个字符：

- 如果都是0或者1，那么反转后1的个数会加2或者减2；
- 如果一个是0另一个是1，那么反转后1的个数不变。
- 所以，无论是那种操作，都不会改变字符串中的1的个数的奇偶性。

故，只要两个字符串中的1的个数的奇偶性不同，就直接返回-1.

然后，先考虑DP，在考虑贪心。毕竟DP就是对暴力搜索的优化。

考虑 $s_1$和 $s_2$的最后一对字符（也可以考虑第一对字符）：

如果相同，那么无需修改。

如果不同：

选择第一种操作，相当于后面可以免费反转一个字符。

选择第二种操作，那么下个字符要把0看作1，把1看作0.

所以除了知道当前下标i，还需要知道免费反转次数j，以及上一个字符是否选择了第二种操作preRew.

定义$dfs（i,j,preRew)$，参数含义如下，返回值是在这种状态下的最小操作代价之和。

分类讨论：

如果`(s1[i] == s2[i]) == (not pre_rev) `表示s1[i]和s2[i]是相等的，无需操作，返回 $dfs(i - 1, j, false)$。

否则：

选择第一种操作： $dfs(i - 1, j + 1, false) + x$。

选择第二种操作：$dfs(i - 1, j, true) + 1$

如果 $j > 0$免费反转一次： $dfs(i - 1, j - 1, false)$。

这三种情况取最小值。

递归边界，当 $i < 0$时：

如果 $j > 0$或者 $preRew$为真，那么不合法，返回 无穷大

否则返回0.

```c++
class Solution {
public:

    int minOperations(string s1, string s2, int x) {
        int n = s1.size();
        // 算出我们要处理的字符串
        vector<int> vec;
        for (int i = 0; i < n; i++) vec.push_back(s1[i] == s2[i] ? 0 : 1);

        const int INF = 1e9;
        int f[n + 1][2][2];
        for (int i = 0; i <= n; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) f[i][j][k] = INF;
        // 初值
        f[0][0][0] = 0;

        // dp
        for (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) {
            int nxt = vec[i] ^ j;
            if (nxt) {
                f[i + 1][1][k] = min(f[i + 1][1][k], f[i][j][k] + 1);
                if (k == 0) f[i + 1][0][1] = min(f[i + 1][0][1], f[i][j][k] + x);
                else f[i + 1][0][0] = min(f[i + 1][0][0], f[i][j][k]);
            } else {
                f[i + 1][0][k] = min(f[i + 1][0][k], f[i][j][k]);
            }
        }

        return f[n][0][0] < INF ? f[n][0][0] : -1;


    }
};
```

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 20.54.56.png" alt="截屏2023-10-08 20.54.56" style="zoom:50%;" />

```c++
class Solution {
public:
    int minSetSize(vector<int>& arr) {
        map<int,int> mp;
        for (int i = 0; i < arr.size(); i++)
        {
            mp[arr[i]] ++;
        }
        vector<int>res;
        for (auto& x: mp) 
        {
            res.push_back(x.second);
        }
        sort(res.begin(), res.end());
        int cnt = 0, sum = 0;
        for (int i = res.size() - 1; i >= 0; i--)
        {
            sum += res[i];
            cnt ++;
            if (sum >= arr.size() / 2)
            {
                break;
            }
        }
        return cnt;

    }
};
```

#### 907.子数组的最小值之和

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-11-27 20.16.44.png" alt="截屏2023-11-27 20.16.44" style="zoom:50%;" />

一般来说，计算每个子数组的最小值之和，先是枚举每个子数组，在求出每个子数组的最小值，最后累加最小值。但是枚举每个子数组需要 $O(n^2)$的时间，而顺序扫描子数组并计算子数组的最小值，又需要 $O(n)$的时间，也就是说，对于正向思维来说，算法的时间复杂度为 $O(n^3)$，这对于 $1 <= n < 3 * 10^4$的数据规模来说，是不可接受的，

一种优化方向是 逆向思维。

正向思维是枚举所有子数组，计算每个子数组的最小值，那么逆向思维是枚举数组中每个元素 $arr[i]$作为最小值，然后统计以 $arr[i]$为最小值的子数组个数。

首先，枚举数组中每个元素 $arr[i]$作为最小值，这个很简单，只需要 $O(n)$时间，接下来，如何统计以 $arr[i]$为最小值的子数组个数，这是解决问题的关键。

枚举元素 $arr[i]$，计算以 $arr[i]$为最小值的子数组个数，我们希望这个子问题能够在 $O(1)$的时间内解决，或者至少在 $O（log n）$时间内解决，因为如果是 $O(n)$的话，算法整体时间复杂度为 $O(n^2)$，这也是不行的。

那么，问题就变成，如何在 $O(1)$时间内统计以 $arr[i]$为最小值的子数组个数，`在线计算` 显然不可能，唯一可行的是，`离线` 对数组进行预处理，而我们离线预处理信息，能够帮助我们在 `O(1)` 时间内统计以 `arr[i]` 为最小值的子数组个数。

计算 `以 arr[i] 结尾且 arr[i] 为最小值的子数组个数`，我们只需要找到 `arr[i]` 左侧第一个比 `arr[i]` 大的数；计算 `以 arr[i] 开始且 arr[i] 为最小值的子数组个数`，我们只需要找到 `arr[i]` 右侧第一个比 `arr[i]` 大的数。从而把问题转化为求解两个 [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/) 的子问题。这时候，使用 `单调栈` 就非常显然了，因为求解 `下一个更大元素问题` 是 `单调栈` 的 `模板题` ~

上面我们定义了两个子问题：1. 计算 `以 arr[i] 结尾且 arr[i] 为最小值的子数组个数`；2. 计算 `以 arr[i] 开始且 arr[i] 为最小值的子数组个数`。稍加思考后，我们就会发现，这两个子问题的定义是有问题的，因为这样会出现 `重复的子数组`。如果说一开始的 `逆向思维` 是解决本题的 `第一个难点`，那么，`如何重新定义上述两个子问题，使得不会统计重复的子数组`，则是解决本题的 `第二个难点`，这个官解已经说了，大家看官解的时候，需要特别留意这一点 ~

考虑所有满足以数组`arr`中的某个元素 `arr[i]`为最右且最小的元素的子序列个数 `C[i]`那么题目要求求连续子数组的最小值之和即为 $\sum^{(n-1)}_{i = 0} arr_i \times C_i$，其中数组 `arr`的长度为`n`。我们必须假设当前元素为最右边且最小的元素，这样才可以构造出互不相交的子序列。

经过以上思考，我们只需要找到每个元素 `arr[i]`以该元素为最右且最小的子序列的数目 `left[i]`，以及以该元素为最左且最小的子序列的数目 `right[i]`，则以 `arr[i]`为最小元素的子序列的数目合计为 `left[i]*right[i]`。为了防止重复计算，我们可以设置 `arr[i]`左边的元素都必须满足小于等于`arr[i]`，`arr[i]`右边的元素必须满足严格小于`arr[i]`。当然这就变成求最小的下标 $j<=i$,且连续子序列中的元素 `arr[j], arr[j+1], ..., arr[i]`都满足大于等于 `arr[i]`，以及最大的下标 $k>i$满足连续子序列 `arr[i+1],...,arr[k]`都满足严格大于 `arr[i]`上述即转化为经典的单调栈问题，即求数组中当前元素 $x$左边第一个小于 $x$的元素以及右边第一个小于等于 $x$的元素。

具体做法：

- 求左边第一个小于`arr[i]`的元素：从左向右遍历数组，并维护一个单调递增的栈，遍历当前元素`arr[i]`，如果遇到当前栈顶的元素大于等于`arr[i]`则将其弹出，直到栈顶元素小于`arr[i]`，栈顶元素即为左边第一个小于`arr[i]`的元素`arr[j]`，此时`left[i]=i-j`.
- 求右边第一个大于等于 arr[i] 的元素：从右向左遍历数组，维护一个单调递增的栈，遍历当前元素 arr[i]，如果遇到当前栈顶的元素大于 arr[i] 则将其弹出，直到栈顶的元素小于等于 arr[i]，栈顶的元素即为右边第一个小于等于 arr[i] 的元素 arr[k]\，此时 right[i]=k−i。
- 连续子数组 arr[j],arr[j+1],⋯ ,arr[k]的最小元素即为 arr[i]，以 arr[i] 为最小元素的连续子序列的数量为 (i−j)×(k−i)(i - j)。

- 

```c++
class Solution {
public:

    int sumSubarrayMins(vector<int>& arr) {
        int n = arr.size();
        vector<int> monoStack;
        vector<int> left(n), right(n);

        for (int i = 0; i < n; i++)
        {
            while (!monoStack.empty() && arr[i] <= arr[monoStack.back()]) monoStack.pop_back();

            left[i] = i - (monoStack.empty() ? -1 : monoStack.back());
            monoStack.emplace_back(i);
        }
        monoStack.clear();

        for (int i = n - 1; i >= 0; i--)
        {
            while (!monoStack.empty() && arr[i] < arr[monoStack.back()]) monoStack.pop_back();

            right[i] = (monoStack.empty() ? n : monoStack.back()) - i;
            monoStack.emplace_back(i);
        }

        long long ans = 0;
        long long mod = 1e9 + 7;
        for (int i = 0; i < n; i++)
            ans = (ans + (long long)left[i] * right[i] * arr[i]) % mod;
        return ans;
    }
};
```



#### 2336.无限集中的最小数字

![截屏2023-11-29 10.54.01](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-11-29 10.54.01.png)

利用哈希的方法。

```c++
class SmallestInfiniteSet {
public:
    SmallestInfiniteSet() {
        for (int i = 0; i < 1005; i++) hash[i] = 1;
    }
    
    int popSmallest() {
        cnt = 1;
        while (cnt < 1000 && !hash[cnt])
        {
            cnt ++;
        }
        hash[cnt] = 0;
        return cnt;
    }
    
    void addBack(int num) {
        hash[num % 1005] = 1; 
    }

private:
    int hash[1005];
    int cnt = 1;
};

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj = new SmallestInfiniteSet();
 * int param_1 = obj->popSmallest();
 * obj->addBack(num);
 */
```

#### 2310.个位数为K的整数之和

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-11-29 13.41.51.png" alt="截屏2023-11-29 13.41.51" style="zoom:50%;" />

枚举+利用同余性质优化至 $O(1)$时间复杂度

首先分析一下答案至少之多是多少，答案范围比较小，我们可以尝试枚举答案 $n$。把个位数单独拆开看，每个数可以表示为$10$的倍数加上 $k$的形式。由于这 $n$个数都以 $k$结尾，那么 $num-nk$必须是 $10$ 的倍数。从小到大枚举 $n$ ，找到第一个满足 $num-nk$ 是 $ 10$ 倍数的 $n$ 。由于 $n$ 不会超过 $num$ ，我们至多枚举到 $num$ 时停止。注意特判 $num=0$ 的情况，此时返回 $0$ 。

进一步，由于
$$
n \cdot k \equiv (n \mod 10) \cdot k (\mod 10) 
$$


枚举到 $n = 11$ 时， $(num - nk)mod 10 $ 的结果会和 $n=1$ 时相同，对于更大的 $n$ 也会和 $n mod 10$ 相同。因此，至多枚举到 $n=10$ 就行了。

```c++
class Solution {
public:
    int minimumNumbers(int num, int k) {
        if (num == 0) return 0;
        for (int n = 1; n <= 10 && num - k * n >= 0; ++n) if ((num - k * n) % 10 == 0) return n;
        return -1;
    }
};
```

#### 1094.拼车

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 13.41.48.png" alt="截屏2023-12-02 13.41.48" style="zoom:50%;" />

首先第一想法是记录每个站点的人数，简单的哈希算法。

```c++
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        int sumPassengers = 0;
        int sum[1005];

        for (int i = 0; i < 1005; i++) sum[i] = 0;

        for (int i = 0; i < 1005; i++)
        {
            for (int j = 0; j < trips.size(); j++)
            {
                if (i < trips[j][2] && i >= trips[j][1]) sum[i] += trips[j][0];
            }
        }

        for (int i = 0; i < 1005; i++) if (sum[i] > capacity) return false;

        return true;
    }
};
```

后续看到别人的方法，还有差分的方法，

**图解差分 入门 （“前缀和” 到 “差分” 丝滑过度）**

**差分**

从朴素的想法开始：创建一个数组 `cnt` ，用于存储从某个站点出发时，车上的乘客数量。例如 $cnt[x]=c$ 含义为在站点 $x$ 出发时（在该站点的下车和上车均完成），车上乘客数为 $c$ 个。对于每个 $trips[i]=(x,a,b)$ ，我们需要对 $[a,b)$ 范围内的 $cnt[j]$ 进行加 $c$ 操作。处理完 `trips` 后，检查所有站点的乘客人数，根据是否满足 `capacity` 限制返回答案。因此，这是一个关于 `区间修改，单点查询` 的经典问题，可使用差分求解。

所谓**差分** ，是指 **原数组中每个元素与前一元素之差所形成的数组** ，与之相对应的是“前缀和” 。我们知道，对原数组进行诸位累加（前缀计算操作），所得到的数组为前缀和数组。差分数组，则是对其执行前缀计算后，能够得到原数组的那个数组。 

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 14.16.30.png" alt="截屏2023-12-02 14.16.30" style="zoom:50%;" />

前缀和数组的主要作用，是利用 `容斥原理` 快速求解某段之和。例如要查询原数组 `nums` 中下标范围 `[l,r]` 的和，可通过 `sum[r]-sum[l-1]` 快速求解。

差分数组的主要作用，是帮助快速修改某段区间。

由于差分数组执行 `前缀计算` 后得到的是原数组，因此在差分数组上修改某个值，会对原数组某段后缀产生相同的影响。

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 14.20.56.png" alt="截屏2023-12-02 14.20.56" style="zoom:50%;" />

因此，**当我们想要对原数组的 `[l,r]` 进行整体修改时，只需要对差分数组的 `l` 和 `r+1` 位置执行相应操作即可。**

举个例子，假设想对原数组 `nums` 的 `[l,r]` 进行整体“加一”操作，那么可转换为对差分数组 `c[l]` 的加一操作（等价对原数组的 `[l,n-1]` 进行加一），以及对差分数组 `c[r+1]` 的减一操作（等价于对原数组的 `[r+1,n-1]` 进行减一， 最终只有 `[l,r]` 有加一效果）。

至此，我们完成了对差分的基本学习：**将原数组的区间修改等价为差分数组的特定位置修改**。

回到本题，起始先用 `nums` 来作为差分数组，对于 $trips[i]=(c,a,b)$ ，有 $c$ 个乘客在 $a$ 点上车，在 $b$ 点下车，因此对 `[a,b)` 进行整体加 $c$ 操作，对应差分数组操作 `nums[a] += c; nums[b] -= c`。

处理完 $trips$ 后，对差分数组 `nums` 进行前缀计算 （可直接复用 `nums`，进行原地计算），便可得到各个站点的乘客数量，与 `capacity` 比较答案。 

```c++
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        vector<int> nums(1010, 0);

        for (const auto& t :trips)
        {
            int c = t[0], a = t[1], b = t[2];
            nums[a + 1] += c;
            nums[b + 1] -= c;
        }

        for (int i = 1; i <= 1000; i++)
        {
            nums[i] += nums[i - 1];
            if (nums[i] > capacity) return false;
        }

        return true;
    }
};
```



#### 1423.可获得的最大点数

![截屏2023-12-03 12.32.08](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-03 12.32.08.png)

**滑动窗口**

从两边选卡片，选 `k` 张，卡片总数量为 `n` 张，即有 `n-k` 张不被选择。所有卡片总和 `sum` 固定，要使选择的 `k` 张的总和最大，反过来就是要让不被选择的 `n-k` 张总和最小。原问题等价为 ：**从`cardPoints` 中找长度为 `n-k` 的连续段，使其总和最小**。

具体来说，用变量 `sum` 代指 `cardPoints` 总和， `cur`代表长度固定为 `n-k`的当前窗口总和， `minv` 代表所有长度为 `n-k`  的窗口总和最小的值。

起始先将滑动窗口压满，取得第一个滑动窗口的目标值 `cur` （同时更新为 `minv`） ，随后往后继续处理 `cardPoints` ，每往前滑动一位，需要删除一个和添加一个元素，并不断更新 `minv` ，最终 `sum-minv`即是答案。 

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {

        int sum = 0, cur = 0;
        for (int i = 0; i < cardPoints.size(); i++) sum += cardPoints[i];
        for (int i = 0; i < cardPoints.size() - k; i++) cur += cardPoints[i];

        int minv = cur;

        for (int i = cardPoints.size() - k; i < cardPoints.size(); i++)
        {
            cur = cur + cardPoints[i] - cardPoints[i - cardPoints.size() + k];
            minv = min(minv, cur); 
        }

        return sum - minv;

    }
};
```

#### 100153.需要添加的硬币的最小数量

![截屏2023-12-03 13.22.21](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-03 13.22.21.png)

**用归纳法思考**

为了方便描述，把0也算作可以得到的数。假设现在得到了 $[1,s-1]$ 内的所有整数，如果此时新发现了一个整数 $x$ ,那么把 $x$ 加到已得到的数字中，就得到了 $[x,s + x-1]$ 内的所有整数。

分类讨论：

1. 如果 $x\leq s$ ，那么合并这两个区间，我们可以得到 $[0,s+x-1]$ 内的所有整数。
2. 如果 $x>s$ ，这意味着我们无法得到 $s$ ，那么就一定要把 $s$ 加到数组中，这样就可以得到 $[s,2s-1]$ 内的所有整数，再与 $[0,s-1]$ 合并，可以得到 $[0,2s-1]$ 内的所有整数。

把 $coins$ 排序，从小到大考虑 $x=coins[i]$ 。按照上述分类讨论来看是否要添加数字。

```c++
class Solution {
public:
    int minimumAddedCoins(vector<int>& coins, int target) {
        sort(coins.begin(), coins.end());
        int ans = 0, s = 1, i = 0;
        while (s <= target)
        {
            if (i < coins.size() && coins[i] <= s)
            {
                s += coins[i];
                i ++;
            }
            else
            {
                s *= 2;
                ans ++;
            }
        }
        return ans;
    }
};
```



#### 100145.统计完全子字符串

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-03 13.37.33.png" alt="截屏2023-12-03 13.37.33" style="zoom:50%;" />

**相邻字母相差至多为2** 这个约束把 `word` 划分成了多个子串 `s` 每个子串分别处理。可以用**分组循环**找到每个子串 `s`。

> 分组循环
>
> 指的是将整个数组或者字符串分成很多片段，这些片段的判断处理逻辑是一样的。分组循环需要使用同向双指针，但是与滑动窗口不同的是，滑动窗口是收集左右区间内连续数组或者字符串，当不满足收集要求时移动右指针，而当满足后移动左指针，此时左指针移动到原来左指针的下一位，而分组循环是左指针移动到右指针下一位。
>
> ```c++
> // 模版 l,r 分别表示左右指针
> 
> int l = 0, r = 0;
> while (r < n)
> {
> 	// 每一次求新区间则重新赋值l
> 	l = r；
>  // r 表示最长连续区间最后一个
>  while (r < n - 1 && s[r] == s[r + 1])
>  {
>    	r ++;
>  }
> 	// 求完区间后收集结果
> 	res = max(r - l + 1, res);
> 	// 并移动r到下一个
> 	r ++;
> }
> ```
>
> 

对于每个子串，由于每个字符恰好出现 `k` 次，我们可以枚举有 `m` 种字符，这样问题就变成了：

长度固定为  `m·k` 的滑动窗口，判断每种字符是否都出现了恰好 `k`次。



#### 1038.从二叉搜索树到更大和树

![截屏2023-12-04 20.34.57](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04 20.34.57.png)

打卡题

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 遍历
    void bst(TreeNode* root)
    {
        if (!root) return;
        bst(root->right);
        cnt += root->val;
        root->val = cnt;
        bst(root->left);
    } 
    TreeNode* bstToGst(TreeNode* root) {
        bst(root);
        return root;
    }
private:
    int cnt = 0;
};
```

#### 1685.有序数组中差绝对值之和

![截屏2023-12-04 20.37.32](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04 20.37.32.png)

利用前缀和解决，首先计算出前缀和，然后遍历`nums`，以当前元素`nums[i]` 为分界点， `i`前边的元素一定是比 `nums[i]`小，`i`后边的元素一定比 `nums[i]`大。这时，我们把这个问题放在二维空间看。

![截屏2023-12-04 20.46.32](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04 20.46.32.png)

比如在 `i=1`的位置在`nums[1]`左边的比 `nums[1]` 小，此时`sum(|nums[i]-nums[j]|)` 为左边的橙色面积。可以写为 `left=nums[i] * i - f[i]` 。同理，右边部分为 右边橙色面积 ，可以写为 `f[n]-f[i] - (n - i) * nums[i]` 。这样，就可以把`result[i]` 的求解过程等价为 `nums[i]` 左右两边的面积。

```c++
class Solution {
public:
    vector<int> getSumAbsoluteDifferences(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        long long f[n + 1];
        f[0] = 0;
        for (int i = 0; i < n; i++) f[i + 1] = f[i] + nums[i];

        for (int i = 0; i < n; i++)
        {
            int target = nums[i];
            long long left = target * i - f[i];
            long long right = f[n] - f[i] - (n - i) * target;
            res[i] = left + right;
        }
        return res;
    }
};
```

#### 2477.到达首都的最少油耗

![截屏2023-12-05 10.27.40](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-05 10.27.40.png)**贪心+深度优先搜索 ** 

题目等价于给出了一棵以节点$0$ 为根结点的树，并且初始树上的每一个节点上都有一个人，现在所有人都需要通过 `车子` 向节点 $0$ 移动。

对于某一节点 $x$ ，$x\neq 0$ ，其父节点为 $y$ 。因为以节点 $x$ 为根结点的子树上的人都需要通过边 $x\to y$ 向节点 $0$ 移动，所以为了使这条边上的 `车子` 利用率最高，我们贪心的让 $x$ 的全部子节点上的人到了节点 $x$ 后再一起坐车向上移动，我们不妨设以节点 $x$ 为根节点的子树大小为 $cnt_x$ 那么我们至少需要 `车子`的数量为 $\lceil \frac{cnt_x}{seats} \rceil$ ，其中 $seatx$ 为一辆车的给定座位数。

那么，我们可以通过从根节点 $0$ 往下进行 `深度优先搜索` ，每一条边上 `车子🚗`的数目即为该条边上汽油的开销，统计全部边上汽油的开销即为最终答案。

```c++
class Solution {
public:
    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        int n = roads.size();
        vector<vector<int>> g(n + 1);
        for (auto &e : roads)
        {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }

        long long res = 0;
        function<int(int, int)> dfs = [&](int cur, int fa) -> int 
        {
            int peopleSum = 1;
            for (auto ne : g[cur])
            {
                if (ne != fa) // 判断是否是同一棵子树
                {
                    int peopleCnt = dfs(ne, cur);
                    peopleSum += peopleCnt;
                    res += (peopleCnt + seats - 1) / seats;
                }
            }
            return peopleSum;
        };
        dfs(0, -1);
        return res;
    }
};
```

之前卡住的原因主要在，不知道怎么确定一条支路走到头。这里了很明显 

```c++
/*
dfs(0, -1)
dfs(1, 0)
dfs(3, 1)
dfs(2, 3)
dfs(3, 3)
*
*/
```

#### 2257.统计网格图中没有被保卫的格子数

![截屏2023-12-06 09.59.40](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-06 09.59.40.png)

**广度优先搜索+存储每个格子的状态**

为了方便操作，我们可以用二维数组 `grid` 来表示网格图的状态。其中，警卫对应的状态值为$-1$ ，墙对应的状态值为 $-2$ ，未被保卫的格子对应的状态值为 $0$ ，被保卫的格子对应的状态值为正整数。二维数组的初始值均为 $0$ ，随后我们遍历 `guards` 和 `walls` 数组对应更新网格图。

在恢复了网格图后，我们可以使用广度优先搜索维护每个格子的状态。由于视线是向特定方向的，因此在广度优先搜索的过程中，除了要维护格子的横纵坐标，还要维护当前的视线方向。我们用 $(i,j,k)$ 来表示广度优先搜索的状态，其中 $(i,j)$ 代表当前点的横纵坐标， $k$ 为 $[0,3]$ 闭区间内整数，分别代表右、上、左、下的视线方向。同样的，为了防止每个非警卫或者墙的点被重复或遗漏，我们用 $4$ 个二进制位组成的正整数来表示该格子的状态，其中从低到高的第 $k$ 位为 $1$ 代表有指向第 $k$ 个方向的视线经过该点，反之则代表没有。

我们用队列 $q$ 来进行广度优先搜索。首先，对于每个警卫点 $(i,j)$ ，由于警卫可以看到四个方向，因此我们需要将 $k$ 为 $[0,3]$ 闭区间内对应的四种状态 $(i,j,k)$ 全部加进队列。

当遍历到 $(x,y,k)$ 时，我们首先计算沿着该视线方向的下一个坐标 $(n_x,n_y)$ ，如果该坐标不合法或为墙或警卫，则我们直接跳过该坐标；对于余下的情况，我们需要检查该坐标对应状态 $grid[i][j]$ 中从低到高的第 $k$ 位的数值。此时有两种情况：

- 第 $k$ 位为$1$ ，则说明该坐标及视线方向对应的状态 $(n_x,n_y,k)$ 已被遍历过，我们直接跳过即可；
- 第 $k$ 位为 $0$ ，则说明该坐标及视线方向对应的状态 $n_x,n_y,k$ 未被遍历过，我们需要将该位置为 $1$ ，并将该状态加入队列 $q$ 的尾部。

最终，当广度优先搜索完成时，一个格子未被保卫当且仅当 $grid$ 中的对应状态值为 $0$ 。我们只需要遍历 $grid$ ，维护数值为 $0$ 的格子数量，并返回即可。

```c++
class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<int>> grid(m, vector<int> (n));  // 网格状态数组
        queue<tuple<int, int, int>> q;   // 广度优先搜索队列
        // 每个方向的单位向量
        vector<int> dx = {1, 0, -1, 0};
        vector<int> dy = {0, 1, 0, -1};
        for (const auto& guard : guards)
        {
            grid[guard[0]][guard[1]] = -1;
            for (int k = 0; k < 4; k++)
            {
                // 将四个方向视线对应的状态均添加进搜索队列中
                q.emplace(guard[0], guard[1], k);
                // 比如，(0, 0) 这时候加入的就是 (0, 0, 0), (0, 0, 1), (0, 0 ,2), (0, 0, 3)
            }
        }

        for (const auto& wall : walls) grid[wall[0]][wall[1]] = -2;

        while (!q.empty())
        {
            auto [x, y, k] = q.front();
            q.pop();
            int nx = x + dx[k];
            int ny = y + dy[k];
            // 太优雅了， k = 0 时， 代表 (nx, ny) -> (nx + 1, ny + 0) 这时候对应向下的视线
            //  k = 1 时，(nx, ny) -> (nx + 0, ny + 1) 右
            // k = 2, (nx, ny) -> (nx - 1, ny + 0) 上
            // k = 3, (nx, ny) -> (nx + 0, ny - 1) 左
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] >= 0)
            {
                // 沿着视线方向的下一个坐标合法，且不为警卫或墙
                if ((grid[nx][ny] & (1 << k)) == 0)
                {
                    // 对应状态未遍历过
                    grid[nx][ny] |= (1 << k);
                    q.emplace(nx, ny, k);
                }
            }
        }
        int res = 0;
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++) if (grid[i][j] == 0) res ++;

        return res;
    }
};
```

#### 2646.最小化旅行的价格总和

![截屏2023-12-06 10.44.48](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-06 10.44.48.png)

**暴力DFS每条路径**

对每个 `trips[i]` 都 DFS 一次这棵树，在 DFS 的过程中，把 `start` 到 `end` 的路径上的每个点 $x$ 的经过次数 $cnt[x]$ 都加一。

既然知道了每个点会被经过多少次，把 `price[i]` 更新为 `price[i]·cnt[i]` ，问题就转换为计算减半后的 `price[i]` 之和的最小值。注意 `cnt[i]=0` 时 `price[0]` 会被更新为 $0$ ，我们无需考虑没有经过的节点。

对于转换后的问题，我们随便选一个节点出发 DFS 。在 DFS 的过程中，对于节点 $x$ 及其儿子 $y$ ，分类讨论：

- 如果 `price[x]` 不变，那么 `price[y]` 可以减半，也可以不变，取这两种情况的最小值；
- 如果`price[x]` 减半，那么 `price[y]`只能不变。

因此子树 $x$ 需要返回两个值

- `price[x]` 不变时的子树 $x$ 的最小价值总和；
- `price[x]` 减半时的子树 $x$ 的最小价值总和；

答案就是根结点不变/减半的最小值。

以 `start` 为树根 DFS ，找到 `end` 时， `end` 及其祖先节点就恰好组成了从 `start` 到 `end` 的路径。

#### 64.最小路径和

![截屏2023-12-07 19.45.13](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-07 19.45.13.png)

此题是典型的动态规划题目。

1. 状态定义
   设 $dp$ 为大小 $m\times n$ 矩阵，其中 $dp[i][j]$ 的值代表直到走到 $(i, j)$ 的最小路径和
2. 转移方程
   题目要求，只能向右或向下走，换句话说，当前单元格 $(i,j)$ 只能从左边的单元格 $(i-1,j)$ 或者上边的单元格 $(i, j -1)$ 走到，因此只需要考虑矩阵的左边界和上边界。

走到当前单元格 $(i,j)$ 的最小路径和 = “从左方单元格 $(i-1,j)$ 与从上方单元格 $(i,j-1)$ 走来的 **两个最小路径和中较小的** ”+当前单元格值 $grid[i][j]$ 。具体分为以下 $4$ 种情况：

1. 当左边和上边都不是矩阵边界时：即当 $i\neq 0,j\neq 0$ 时， $dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j]$ 
2. 当只有左边是矩阵边界时：只能从上边来，即当 $i=0,j\neq 0$ 时，$dp[i][j] = dp[i][j-1] + grid[i][j]$ 
3. 当只有上边是矩阵边界时：只能从左边来，即当 $i\neq0 j = 0$ 时， $dp[i][j]=dp[i-1][j] + grid[i][j]$ 
4. 当左边和上边都是矩阵边界时：即当 $i=0,j=0$ 时，$dp[i][j]=grid[i][j]$

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (i == 0 && j == 0) grid[i][j] = grid[i][j];
                if (i != 0 && j != 0) grid[i][j] = min(grid[i-1][j], grid[i][j - 1]) + grid[i][j];
                if (i == 0 && j != 0) grid[i][j] = grid[i][j - 1] + grid[i][j];
                if (i != 0 && j == 0) grid[i][j] = grid[i - 1][j] + grid[i][j];
            }
        }
        return grid[n - 1][m - 1];

    }
};
```

#### 1466.重新规划路线

![截屏2023-12-07 20.06.21](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-07 20.06.21.png)

题目给定一张由 `n` 个点（使用 `0` 到 `n-1` 编号），`n-1` 条边构成的有向图，如果忽略变得方向，就变成了一棵树。我们需要改变某些边的方向使得每个点都可以访问到 `0` 号点。

如果忽略边的方向，将每条有向边以及其反向边加入到图中，那么从任意一点出发都能到达 `0` 号点。路径上可能会经过反向边，我们需要变更与之对应的原边的方向。需要变更的次数即为答案。

以每个点为起点进行搜索的代价会很大，因此我们考虑从 `0` 出发去遍历其他点（可以使用深度优先搜索或者广度优先搜索，本题解使用深度优先搜索），原来我们需要统计反向边的数量，现在需要统计原方向边的数量。

具体而言，我们使用` 1`标记原方向的边，使用 `0` 标记反向边。然后从 `0` 号点开始遍历，访问到某个新的点时，所经过的边被 `1` 标记，就令答案加 `1`。最终统计得到的答案就是我们需要变更方向的最小路线数。

```c++
class Solution {
public:
    int dfs(int x, int parent, vector<vector<pair<int, int>>>& e)
    {
        // 这里 parent 作用是保存了上一个节点
        int res = 0;
        for (auto &edge : e[x])
        {
            // 这里意思是，如果当前节点的下一个节点是上一个节点，那么说明到头了
            // 直接跳转下一个节点
            // 比如到2了，2的下一个节点到3且3是2的前一个节点，那么直接跳转到 (0, 4, 0) 此时 parent = x = 3继续dfs
            if (edge.first == parent) continue;
            
            res += edge.second + dfs(edge.first, x, e);
        }
        return res;
    }


    int minReorder(int n, vector<vector<int>>& connections) {
        vector<vector<pair<int, int>>> e(n);

        for (auto edge : connections)
        {
            e[edge[0]].push_back(make_pair(edge[1], 1));
            e[edge[1]].push_back(make_pair(edge[0], 0));
        }
        return dfs(0, -1, e);
    }
};
```

#### 2048.下一个更大的数值平衡数

![截屏2023-12-09 12.46.46](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09 12.46.46.png)

我首先想到的是，直接对每个数字进行暴力判断。

```c++
class Solution {
public:
    bool judgeBeautiful(int n)
    {
        map<int, int> mp;
        int n_ = n;
        while (n_)
        {
            int tmp = n_ % 10;
            mp[tmp] = 0;
            n_ /= 10;
        }
        while (n)
        {
            int tmp = n % 10;
            mp[tmp] ++;
            n /= 10;
        }
        for (auto& mp_ : mp) if (mp_.first != mp_.second) return false;
        return true;
    }

    int nextBeautifulNumber(int n) {
        if (n == 0) return 1;
        int res;
        while (n <= 666666)
        {
            n ++;
            if (judgeBeautiful(n))
            {
                res = n;
                break;
            }
            
        }
        return n <= 666666 ? res : 1224444;
    }
};
```

#### 62.不同路径

![截屏2023-12-09 13.23.57](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09 13.23.57.png)

```c++
class Solution {
public:

    int uniquePaths(int m, int n) {
        int dp[m][n];
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i != 0 && j != 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                if (i == 0 && j != 0) dp[i][j] = dp[i][j - 1];
                if (i != 0 && j == 0) dp[i][j] = dp[i - 1][j];
                if (i == 0 && j == 0) dp[i][j] = 1;
            }
        }
        return dp[m - 1][n - 1];
    }
};

```

#### 63.不同路径

![截屏2023-12-09 14.09.07](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09 14.09.07.png)

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        int dp[m][n];

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (obstacleGrid[i][j] == 1) dp[i][j] = 0;
                else
                {
                    if (i != 0 && j != 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    if (i == 0 && j != 0) dp[i][j] = dp[i][j - 1];
                    if (i != 0 && j == 0) dp[i][j] = dp[i - 1][j];
                    if (i == 0 && j == 0) dp[i][j] = 1;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

#### 120.三角形最小路径和

![截屏2023-12-09 14.48.17](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09 14.48.17.png)

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if (triangle.size() == 1) return triangle[0][0];
        int m = triangle.size(), n = triangle[m - 1].size();
        int dp[m][n];
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < triangle[i].size(); j++)
            {
                if (j == 0 && i != 0) dp[i][j] = dp[i - 1][j] + triangle[i][j];
                if (j == triangle[i].size() - 1 && i != 0) dp[i][j] = dp[i - 1][j - 1] + triangle[i][j];
                if (i == 0 && j == 0) dp[i][j] = triangle[0][0];
                if (j != 0 && j != triangle[i].size() - 1) dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j];
            }
        }
        int minVal = 1e5;
        for (int i = 0; i < n; i++) if (minVal > dp[m - 1][i]) minVal = dp[m - 1][i];
        return minVal;
    }
};
```

#### 931.下降路径最小和

```c++
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        
        int n = matrix.size();
        if (n == 1) return matrix[0][0];

        int dp[n][n];
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == 0) dp[i][j] = matrix[i][j];
                if (i != 0 && j == 0) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];
                if (i != 0 && j == (n - 1)) dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + matrix[i][j];
                if (i != 0 && j != 0 && j != (n - 1)) 
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]}) + matrix[i][j];
            }
        }
        int minVal = 1e5;
        for (int i = 0; i < n; i++) if (minVal > dp[n - 1][i]) minVal = dp[n - 1][i];
        return minVal;
    }
};
```



#### 100147.最多K个重复元素的最长子数组

![截屏2023-12-10 10.30.05](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-10 10.30.05.png)

```c++
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k) {
        int res = 0;
        unordered_map<int, int> cnt;
        int j = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            cnt[nums[i]] ++;
            while (cnt[nums[i]] > k)
            {
                cnt[nums[j++]]--;
            }
            res = max(res, i - j + 1);
        }
        return res;
    }
};
```

#### 221.最大正方形

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 13.40.25.png" alt="截屏2023-12-10 13.40.25" style="zoom:50%;" />

我们用 `dp[i][j`] 表示 以 `[i][j]` 为右下角，且只包含 `1` 的正方形的边长最大值。如果我们能计算出所有 `dp[i][j]` 的值，那么其中的最大值即为矩阵中只包含 `1` 的正方形的边长最大值，其平方即为最大正方形的面积。

那么如何计算 `dp` 中的每个元素值？对于每个位置 `[i][j]` ，检查在矩阵中该位置的值“

- 如果该位置的值是 `0` ，则 `dp[i][j]=0` 因为当前位置不可能在由 `1` 组成的正方形中。

- 如果该位置的值是 `1` ，则 `dp[i][j]` 的值由其上方、左方和左上方的三个相邻位置的 `dp` 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加`1` 状态转移方程：
  $$
  dp(i,j)=min(d(i-1,j),dp(i-1,j-1),dp(i,j-1)) + 1
  $$
  此外，还需要考虑边界条件。如果 `i` 和 `j` 中至少有一个为 `0` 则以位置为右下角的最大正方形的边长就只能是 `1` ，因此 `dp[i][j]=1` 

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) return 0;
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<int>> dp(rows, vector<int>(columns));
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                if (matrix[i][j] == '1')
                {
                    if (i == 0 || j == 0) dp[i][j] = 1;
                    else dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }

        return maxSide * maxSide;
    }
};
```

#### 100137.统计最大元素出现至少K次的子数组

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 14.15.07.png" alt="截屏2023-12-10 14.15.07" style="zoom:50%;" />

**同向双指针+滑动窗口** 

在子数组子串问题中，经常会用到双指针这一技巧 。举个例子：给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其和 `>=target`的长度最小的 **连续子数组** `nums` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` .

例如209题目。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLen = nums.size() + 1;

        int left = 0;
        int right = 0;
        int sum = 0;
        for (; right < nums.size(); right++)
        {
            sum += nums[right];
            while ((sum - nums[left]) >= target)
            {
                sum -= nums[left];
                left ++;
            }
            if (sum >= target) minLen = min(minLen, right - left + 1);
        }
        return minLen <= nums.size() ? minLen : 0;
    }
};
```

 再比如**713.乘积小于K的子数组** 给定一个整数数组 `nums` 和一个整数 `k` ，返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目。万变不离其宗，元素都是正数，方法和上一题一样，对于 `[10, 5, 2, 6]` 比如枚举到 `2` 的时候，就把 `2` 接到上一次计算的结果后面。那如果元素的乘积 `>=k` 就把左端点右移，缩小子数组的长度，直到乘积小于 `k` 为止。那么问题的关键，也是与上题不同的点，**子数组的数目要怎么算** 这里，我们枚举到 `2` ，需要算的就是以 `2` 为右端点的满足要求的子数组的个数。`[5, 2]`算是一个， `[2]` 单独算一个。用代码来计算，就需要推导出来一个公式，假设此时左端点为 `l`，右端点为`r` 。那么我们现在需要计算的就是以 `r` 为右端点的子数组的个数。注意右端点是固定的，如果从 `l` 到 `r` 的这一段的乘积是小于 `k` 的。那么从 `l+1` 到 `r` 的这一段也是小于 `k` 的。一直到 `[r, r]` 这些子数组都是满足要求的。那么子数组的个数其实就是从 `l` 到 `r` 的元素个数。那么就是 `r-l+1` 

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) return 0;
        int left = 0;
        int right = 0;
        int sum = 1;
        int maxNums = 0;

        for (; right < nums.size(); right++)
        {
            sum *= nums[right];
            while (sum  >= k)
            {
                sum /= nums[left];
                left ++;  
            }
            maxNums += right - left + 1;
        }

        return maxNums;
    }
};
```

接着还有 **3.无重复字符的最长子串** 给定一个字符串 `s` ,找出其中不含重复字符的 **最长子串** 的长度。由于如果出现的重复字符的唯一情况就是刚刚加入的字符与之前的字符发生重复，所以我们只需要使用哈希的方法，统计一下刚加入的字符是否出现重复即可。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0;
        int right = 0;
        int maxLen = 0;
        unordered_map<char, int> mp;
        for (right; right < s.size(); right++)
        {
            mp[s[right]] ++;
            while (mp[s[right]] >= 2)
            {
                mp[s[left]] --;
                left ++;
            }
            maxLen = max(maxLen, right - left + 1);
        }
        return maxLen;
    }
};
```

回到这个题目，首先找到数组中的最大数，设 $mx=max(nums)$ 右端点 $right$ 从左到右遍历 $nums$ 。遍历到元素$x=nums[right]$  如果 $x=mx$ ，就把计数器 $cntMx$ 加一。如果此时 $cntMx = k$ 则不断右移左指针 $left$ ，直到窗内的 $mx$ 的出现次数 **小于** $k$ 为止。此时，对于右端点为 $right$ 且左端点小于 $left$ 的子数组，$mx$ 的出现次数都至少为 $k$ ，把答案增加 $left$ 。

```c++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        int left = 0;
        int right = 0;
        int maxVal = 0;
        for (int i = 0; i < nums.size(); i++) maxVal = max(maxVal, nums[i]);
        int maxValCnt = 0;
        long long sum = 0;

        for (right; right < nums.size(); right++)
        {
            if (nums[right] == maxVal) maxValCnt ++;
            while (maxValCnt == k)
            {
                if (nums[left] == maxVal) maxValCnt --;
                left ++;
            }
            sum += left;
        }

        return sum;
    }
};
```

#### 1631.最小体力消耗路径

![截屏2023-12-11 12.28.59](/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-11 12.28.59.png)

看到这个题目，最小路径，第一反应是DP，但是这里是往 **上，下，左，右** 四个方向移动，转念一想，这已经是DP解决不了的问题了。因为，你无法确定都有哪些位置能够到达你当前的位置，也就是无法推出状态转移方程。

事实上，当题目允许往任意方向移动时，考察的往往就不是DP了，而是图论。从本质上说，DP问题是一类特殊的图论问题。那为什么有一些DP题目简单修改条件后，就只能彻底转化为图论问题来解决呢？这是因为修改条件后，导致我们DP状态展开不再是一个拓扑序列。换句话说，DP题虽然都属于图论范畴。但对于不是拓扑图的图论问题，我们无法使用DP求解。而此类看似DP，实则图论的问题，通常是最小生成树或者最短路问题。

**Kruskal**

**当一道题我们决定往图论方向思考时，我们的重点应该放在如何建图上。** 因为解决特定的图论问题时（最短路/最小生成树/二分图匹配），我们都是使用特定的算法。由于使用到的算法都有固定的模版，因此编码难度很低，而如何建图的思维难度则很高。对于本题，我们可以按照如下分析进行建图：

因为在任意格子可以往任意方向移动，所以相邻的格子之间存在一条无向边。题目要求我们求的就是从起点到终点，经过路径中的最小权重的最大值是多少。我们可以先遍历所有的格子，将所有的边加入集合。存储的格式为数组 `[a,b,w]` ，代表编号为 `a` 的点和编号为 `b` 的点之间的权重为 `w` 。按照题意， `w` 为两者的高度差的绝对值。对集合进行排序，按照 `w` 进行从小到大排序 (Kruskal)当我们有了排好序的候选边集合之后，我们可以对边进行从前往后处理，每次加入一条边之后，使用并查集来查询起点和终点是否连通。

```c++
// 并查集模板
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    int n;
    // 当前连通分量数目
    int setCount;
    
public:
    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }
    
    int findset(int x) {
        return parent[x] == x ? x : parent[x] = findset(parent[x]);
    }
    
    bool unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            swap(x, y);
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    bool connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
};

class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        vector<tuple<int, int, int>> edges;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int id = i * n + j;
                if (i > 0) {
                    edges.emplace_back(id - n, id, abs(heights[i][j] - heights[i - 1][j]));
                }
                if (j > 0) {
                    edges.emplace_back(id - 1, id, abs(heights[i][j] - heights[i][j - 1]));
                }
            }
        }
        sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {
            auto&& [x1, y1, v1] = e1;
            auto&& [x2, y2, v2] = e2;
            return v1 < v2;
        });

        UnionFind uf(m * n);
        int ans = 0;
        for (const auto [x, y, v]: edges) {
            uf.unite(x, y);
            if (uf.connected(0, m * n - 1)) {
                ans = v;
                break;
            }
        }
        return ans;
    }
};

```

#### 2415.反转二叉树的奇数层

方法一：广度优先搜索

我们直接按照层次遍历该二叉树，然后将奇数层中的值进行反转。二叉树按照层次遍历是一个基本的广度优先搜索问题，在遍历的同时，对每一层进行标记，如果当前该层为奇数层，则将该层中的节点用数组保存起来，然后将该层所有节点的值进行反转即可。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* reverseOddLevels(TreeNode* root) {
        queue<TreeNode *> qu;
        qu.emplace(root);
        bool isOdd = false;
        while (!qu.empty())
        {
            int sz = qu.size();
            vector<TreeNode *> arr;
            for (int i = 0; i < sz; i++)
            {
                TreeNode *node = qu.front();
                qu.pop();
                if (isOdd) arr.emplace_back(node);
                if (node->left)
                {
                    qu.emplace(node->left);
                    qu.emplace(node->right);
                }
            }

            if (isOdd) 
            {
                for (int l = 0, r = sz - 1; l < r; l++, r--) swap(arr[l]->val, arr[r]->val);
            }
            isOdd ^= true;
        }
        return root;
    }
};
```





























