---
title: åŠ›æ‰£
date: 2024-05-06 10:20:46
tags:
---

## 1.å“ˆå¸Œ

#### 1.ä¸¤æ•°ä¹‹å’Œ

å¦‚æœç›´æ¥æš´åŠ›å¾ˆç®€å•ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ ã€‚è¿™é‡Œå…¶å®æ—¶é—´çš„å¤æ‚åº¦ä¸»è¦æ¥è‡ªäºå†…å±‚å¾ªç¯çš„å¤æ‚åº¦ï¼Œå¤–å±‚å¾ªç¯ï¼Œçš„ $O(n)$ æ—¶é—´å¤æ‚åº¦æ˜¯ä¸å¯é¿å…çš„ï¼Œå¯¹äº $nums[i]$ æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨æ•°ç»„ä¸­æ‰¾åˆ°ä¸€ä¸ªæ•°ç­‰äº $target - nums[i]$ ã€‚åªæ˜¯å¾ªç¯çš„è¯ï¼Œè¿˜æ˜¯ $O(n)$ çš„æ—¶é—´å¤æ‚åº¦ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“ˆå¸Œçš„æ–¹æ³•ï¼Œç›´æ¥ç”¨ $O(1)$ çš„æ—¶é—´å¤æ‚åº¦æ‰¾åˆ° $target - nums[i]$ ã€‚

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp;
        for (int i = 0; i < nums.size(); i++) {
            // æ‰¾ä¸€ä¸ªé”®å€¼ä¸º target - nums[i] çš„ç´¢å¼•
            auto it  = mp.find(target - nums[i]);
            // å¦‚æœæ‰¾åˆ°äº†é”®å€¼ä¸º target - nums[i] çš„ç´¢å¼•ï¼Œé‚£ä¹ˆè¿”å›ç­”æ¡ˆ
            if (it != mp.end()) {
                return {it->second, i};
            }
            mp[nums[i]] = i;
        }
        return {};
    }
};
```

#### 49.å­—æ¯å¼‚ä½è¯åˆ†ç»„

æˆ‘ä»¬å¯ä»¥é€‰æ‹©å°†æ’åºåçš„å­—ç¬¦ä¸²ä½œä¸ºé”®ï¼Œæ— åºçš„å­—ç¬¦ä¸²ä½œä¸ºé”®å€¼ `unordered_map<string, vector<string>> mp;` è¿™æ ·éå†ä¸€è¾¹å­—ç¬¦ä¸²ï¼Œå°±å¯ä»¥ç­›é€‰å‡ºæ‰€æœ‰çš„ç­”æ¡ˆã€‚

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        for (string& str : strs) {
            string key = str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        }
        vector<vector<string>> res;
        for (auto it = mp.begin(); it != mp.end(); it++) {
            res.emplace_back(it->second);
        }
        return res;
        
    }
};
```



#### 128.æœ€é•¿è¿ç»­åºåˆ—

é¦–å…ˆæˆ‘ä»¬è€ƒè™‘æšä¸¾æ•°ç»„ä¸­çš„æ¯ä¸ªæ•° $x$ ã€‚è€ƒè™‘ä¸æ–­å°è¯• $x+1,x+2,x+3,...$ æ˜¯å¦å­˜åœ¨ã€‚å¯¹äºåŒ¹é…çš„è¿‡ç¨‹ï¼Œç›´æ¥çš„æ–¹æ³•æ˜¯ $O(n)$ éå†æ•°ç»„å»çœ‹æ˜¯å¦å­˜åœ¨è¿™ä¸ªæ•°ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹æ³•ï¼Œç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨å­˜å‚¨æ•°ç»„ä¸­çš„æ•°ï¼Œè¿™æ ·æŸ¥çœ‹ä¸€ä¸ªæ•°æ˜¯å¦å­˜åœ¨èƒ½ä¼˜åŒ–è‡³ $O(1)$ çš„æ—¶é—´å¤æ‚åº¦ã€‚

ä½†æ˜¯ä»…ä»…è¿™æ ·ï¼Œæˆ‘ä»¬çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦æœ€åæƒ…å†µè¿˜æ˜¯ä¼šè¾¾åˆ° $O(n^2)$ ï¼ˆå³å¤–å±‚éœ€è¦æšä¸¾ $n$ ä¸ªæ•°ï¼Œå†…å±‚ä¹Ÿéœ€è¦æš´åŠ›åŒ¹é… $n$ æ¬¡ï¼‰ã€‚è¿™æ ·æ— æ³•æ»¡è¶³é¢˜ç›®æ—¶é—´å¤æ‚åº¦ $O(n)$ çš„è¦æ±‚ã€‚ä½†æ˜¯æˆ‘ä»¬ä»”ç»†åˆ†æè¿™ä¸ªæšä¸¾çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬ä¼šå‘ç°å…¶å®æˆ‘ä»¬è¿›è¡Œäº†å¾ˆå¤šä¸å¿…è¦çš„æšä¸¾ï¼Œå¦‚æœå·²çŸ¥æœ‰ä¸€ä¸ª $x, x+1, x+2, ..., x+y$ çš„è¿ç»­åºåˆ—ï¼Œè€Œæˆ‘ä»¬åœ¨ä¸‹ä¸€ä¸ªæ•°å­— $x+ 2$ çš„æ—¶å€™ä»ç„¶ä¸€ä¸ªä¸€ä¸ªçš„æšä¸¾ï¼Œè¿™æ ·å¾—åˆ°çš„ç»“æœæ˜¯ä¸€å®šä¸ä¼šä¼˜äºä»¥ $x$ ä¸ºèµ·ç‚¹çš„çš„ç­”æ¡ˆçš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨å¤–å±‚åˆ¤æ–­ `x - 1` æ˜¯å¦åœ¨æ•°ç»„ä¸­å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨ï¼Œé‚£ä¹ˆä»–å°±æ˜¯å·²ç»åˆ¤æ–­è¿‡çš„ï¼Œä¸éœ€è¦åœ¨åˆ¤æ–­ï¼Œç›´æ¥è·³è¿‡å³å¯ã€‚

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (auto num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (auto num : num_set) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }
        return longestStreak;
    }
};
```

## 2.åŒæŒ‡é’ˆ

#### 283.ç§»åŠ¨é›¶

åŒæŒ‡é’ˆï¼Œ`left` å’Œ `right` å½“`left` ä¸º0æ—¶ï¼Œ`right`æ‰¾åˆ°`left`åè¾¹ç¬¬ä¸€ä¸ªä¸ä¸ºé›¶çš„æ•°å­—è¿›è¡Œäº¤æ¢ã€‚

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if (nums.size() == 1) return;
        for (int left = 0, right = 1; left < right && right < nums.size(); ) {
            if (nums[left] == 0) {
                while (right < nums.size() && nums[right] == 0) {
                    right ++;
                }
                if (right == nums.size()) return;
                nums[left] = nums[right];
                nums[right] = 0;
            }
            left ++;
            right ++;
        }
    }
};
```

#### 11.ç››æœ€å¤šæ°´çš„å®¹å™¨

è¿™é“é¢˜ç›®ï¼Œè§‚å¯Ÿæ•°æ®çš„è§„æ¨¡ï¼Œå¦‚æœé‡‡ç”¨æš´åŠ›çš„åŒå±‚`for`å¾ªç¯è¿›è¡Œæšä¸¾ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸€å®šè¶…æ ‡ã€‚è¿™é‡Œæˆ‘ä»¬è§‚å¯Ÿï¼Œæ˜¯è§£å†³ä¸¤æ¡çº¿ä¹‹é—´çš„é¢ç§¯æœ€å¤§çš„é—®é¢˜ï¼Œé‚£ä¹ˆè‡ªç„¶è€Œç„¶æƒ³åˆ°å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆæ¥è§£å†³ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥æ³¨æ„å¦‚ä½•è§£å†³æŒ‡é’ˆçš„ç§»åŠ¨ï¼Œé¦–å…ˆåœ¨`height[0]` å’Œ `height[8]`ä¹‹é—´æŒ‡é’ˆå¦‚ä½•ç§»åŠ¨å‘¢ï¼Ÿæ­¤æ—¶æŒ‡é’ˆ `height[0] < height[8]` é‚£å°±æ˜¯è¯´æˆ‘ä»¬æ­¤æ—¶æ‰¾åˆ°æ¯” `height[0]`å¤§çš„å€¼å³å¯ã€‚å¯ä»¥ç…§æ ·ç†è§£ï¼Œæˆ‘ä»¬æ­¤æ—¶åœ¨æ•°ç»„ä¸­å¯»æ‰¾åªè¦æ¯” `height[8]`å°çš„å€¼ï¼Œé‚£ä¹ˆé¢ç§¯ä¸€å®šæ¯”æ­¤æ—¶é¢ç§¯å°ï¼Œæ‰€ä»¥æˆ‘ä»¬é€‰æ‹©ç§»åŠ¨ä¸¤ä¸ªæ•°å€¼ä¹‹é—´è¾ƒå°çš„æ•°å­—ï¼Œè¿™æ ·æ‰æœ‰å¯èƒ½å‡ºç°æ¯”ç°åœ¨å¤§çš„é¢ç§¯ã€‚

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int res = -1;
        while (left < right) {
            res = max(res, min(height[left], height[right]) * (right - left));
            if (height[left] > height[right]) right --;
            else left ++;
        }
        return res;
    }
};
```

#### 15.ä¸‰æ•°ä¹‹å’Œ

åˆ©ç”¨åŒæŒ‡é’ˆè¿›è¡Œæ—¶é—´å¤æ‚åº¦çš„å‹ç¼©ï¼Œé¦–å…ˆæˆ‘ä»¬å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œè¿™æ ·å¯ä»¥æ–¹ä¾¿åç»­è¿›è¡Œå·¦å³æŒ‡é’ˆçš„ç§»åŠ¨ã€‚æ’åºåï¼Œæˆ‘ä»¬è¦å¯¹æ•°ç»„ä¸­ä¸€æ ·çš„æ•°å­—è¿›è¡Œå»é‡ï¼Œ`if (i - 1 >= 0 && nums[i] == nums[i - 1]) continue` è¿™å¥ä»£ç å°±æ˜¯è¿›è¡Œå»é‡çš„ä»£ç ã€‚ä¹‹åæˆ‘ä»¬å®šä¹‰å·¦æŒ‡é’ˆæŒ‡å‘`nums[i]` çš„ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æŒ‡é’ˆæŒ‡å‘æœ€åä¸€ä¸ªæ•°å­—ã€‚å®šä¹‰ `target` ä¸ºç›®æ ‡æ•°å­—ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•è¿›è¡Œæ—¶é—´å¤æ‚åº¦çš„å‹ç¼©ï¼Œæˆ‘ä»¬å°†ä¸‰æ•°ä¹‹å’Œé—®é¢˜è½¬åŒ–ä¸ºä¸¤ä¸ªæ•°å­—çš„å’Œç­‰äº `-nums[i]` ã€‚æˆ‘ä»¬è®¡ç®—è¿™ä¸ªå’Œ`sum`ã€‚å¦‚æœè¿™ä¸ªå’Œ `sum > 0` `right--` å¦åˆ™ `left++` ã€‚ä½†æ˜¯è¿™é‡Œæœ‰ä¸ªé—®é¢˜ï¼Œå°±æ˜¯ä¼šæœ‰ä¸€æ ·çš„æ•°å­—é€ æˆç­”æ¡ˆæ•°ç»„é‡å¤ã€‚æ‰€ä»¥æˆ‘ä»¬è¦è¿›è¡Œä¸€æ ·çš„æ•°å­—è·³è¿‡çš„æ“ä½œã€‚

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < nums.size(); i++) {
            if (i - 1 >= 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1, right = nums.size() - 1;
            int target = nums[i];
            while (left < right) {
                int sum = target + nums[left] + nums[right];
                if (sum > 0) right--;
                else if (sum < 0) left++;
                else {
                    res.push_back({target, nums[left], nums[right]});
                    for (left ++; left < right && nums[left] == nums[left - 1]; left++);
                    for (right--; left < right && nums[right] == nums[right + 1]; right--);
                }
            }
        }
        return res;    
    }
};
```

#### 42.æ¥é›¨æ°´

![æˆªå±2024-05-06 10.21.59](æˆªå±2024-05-06 10.21.59.png)

è¿™é‡Œæˆ‘ä»¬å°†æ¯ä¸€å—åŒºåŸŸéƒ½è§†ä¸ºä¸€ä¸ªåº•è¾¹é•¿åº¦ä¸º`1` çš„æœ¨æ¡¶ï¼Œè¿™æ˜¯æœ¨æ¡¶çš„å®¹æ°´é‡ä¸º `min(å·¦è¾¹æœ€é«˜çš„æœ¨æ¿ï¼Œå³è¾¹æœ€é«˜çš„æœ¨æ¿)- height[i]` é‚£ä¹ˆå¦‚ä½•æ±‚å¯¹äºä¸€ä¸ªä½ç½®çš„å·¦è¾¹æœ€é«˜æœ¨æ¿å’Œå³è¾¹æœ€é«˜æœ¨æ¿å‘¢ï¼Ÿè¿™é‡Œæˆ‘ä»¬ç”¨åˆ°å‰åç¼€çš„æ–¹æ³•ã€‚

```c++
// 0 1 1 2 2 2 2 3 3 3 3 3
// 3 3 3 3 3 3 3 3 2 2 2 1
// 0 0 1 0 1 2 1 0 0 1 0 0
```

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        vector<int> pre_max(height.size(), 0);
        vector<int> suf_max(height.size(), 0);
        pre_max[0] = height[0];
        suf_max[height.size() - 1] = height[height.size() - 1];
        for (int i = 1; i < height.size(); i++) {
            pre_max[i] = max(pre_max[i - 1], height[i]);
        }
        for (int i = height.size() - 2; i >= 0; i--) {
            suf_max[i] = max(suf_max[i + 1], height[i]);
        }
        int res = 0;
        for (int i = 0; i < height.size(); i++) {
            res += min(pre_max[i], suf_max[i]) - height[i];
        }

        return res;
    }
};
```

**ç›¸å‘åŒæŒ‡é’ˆçš„åšæ³•**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0, left = 0, right = height.size() - 1, pre_max = 0, suf_max = 0;
        while (left <= right) {
            pre_max = max(pre_max, height[left]);
            suf_max = max(suf_max, height[right]);
            if (pre_max < suf_max) {
                // å·¦è¾¹æœ¨æ¡¶çš„å®¹é‡å°±çŸ¥é“äº†
                res += pre_max - height[left];
                left ++;
            } else {
                res += suf_max - height[right];
                right --;
            }
        }
        return res;
    }
};
```



## 3.æ»‘åŠ¨çª—å£

#### 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­—ä¸²

æ»‘åŠ¨çª—å£ï¼Œåˆ©ç”¨é›†åˆç»´æŠ¤ä¸€ä¸ªæ²¡æœ‰é‡å¤å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œä¸æ–­æšä¸¾å³æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦ï¼Œå¹¶åœ¨é›†åˆä¸­åˆ¤æ–­å®ƒåœ¨æ‰€ç»´æŠ¤çš„å­—ç¬¦ä¸²ä¸­æ˜¯å¦å‡ºç°è¿‡ï¼Œå¦‚æœå‡ºç°è¿‡ï¼Œå°±ä¸æ–­ç§»åŠ¨æ‰€ç»´æŠ¤çš„å­—ç¬¦ä¸²çš„å·¦è¾¹ç•Œï¼Œä½¿å¾—æ‰€ç»´æŠ¤çš„å­—ç¬¦ä¸²ä¸­æ²¡æœ‰ä¸æ­¤æ—¶å³æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦ä¸²é‡å¤çš„å­—ç¬¦ã€‚ç„¶åæ’å…¥å³æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦ï¼Œæ›´æ–°ç­”æ¡ˆã€‚

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> st;
        int res = 0;
        for (int right = 0, left = 0; right < s.size(); right++) {
            // ä¸æ–­æ»‘åŠ¨å³æŒ‡é’ˆï¼Œç›´åˆ°å½“å‰å³æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦æ²¡æœ‰é‡å¤
            while (st.count(s[right])) {
                // å½“å‰å³æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦åœ¨stä¸­æœ‰é‡å¤çš„ï¼Œæ‰€ä»¥ä¸æ–­æ»‘åŠ¨å·¦æŒ‡é’ˆï¼Œå¹¶æ“¦å»stä¸­çš„å·¦æŒ‡é’ˆå­—ç¬¦
                st.erase(s[left++]);
            }
            // å½“æ»‘åŠ¨å®Œæˆï¼Œæ­¤æ—¶å³æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦åœ¨stä¸­æ²¡æœ‰é‡å¤çš„ï¼Œæ’å…¥å³æŒ‡é’ˆçš„å­—ç¬¦ æ›´æ–°ç­”æ¡ˆ
            st.insert(s[right]);
            res = max(res, right - left + 1);
        }

        return res;
    }
};
```

#### 438.æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯

é¦–å…ˆæˆ‘æƒ³åˆ°çš„æ˜¯æš´åŠ›è§£æ³•ï¼Œåˆ©ç”¨æ¯æ¬¡åœ¨`s`ä¸­æˆªå–ä¸€æ®µé•¿åº¦ç­‰äº`p`çš„å­å­—ç¬¦ä¸²ã€‚ç„¶åæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯å¼‚ä½å­—ç¬¦ä¸²ã€‚è¿™ç§æ–¹æ³•æ¯”è¾ƒç›´æ¥ï¼Œå®ç°èµ·æ¥ä¹Ÿæ²¡æœ‰éš¾åº¦ã€‚æˆ‘ç”¨çš„æ˜¯å­—å…¸æ¥æ¯”è¾ƒå­—ç¬¦ä¸²æ˜¯å¦æ˜¯å¼‚ä½å­—ç¬¦ä¸²ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦å¾ˆé«˜ã€‚ä¸å‡ºæ„æ–™çš„è¶…æ—¶äº†ã€‚

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map <char, int> mp_1;
        for (int i = 0; i < p.size(); i++) {
            mp_1[p[i]] ++;
        }
        vector <int> res;
        unordered_map <char, int> mp_2;
        for (int left = 0, right = p.size() - 1; right < s.size();left++, right++) {
            mp_2.clear();
            int flag = 1;
            for (int i = left; i <= right; i++) {
                mp_2[s[i]]++;
            }
            for (auto mp_1_ : mp_1) {
                if (mp_2[mp_1_.first] != mp_1_.second) {
                    flag = 0;
                    break;
                }
            }
            if (flag) {
                res.push_back(left);
            }
        }
        return res;
    }
};
```

æ¥ç€æƒ³ï¼Œè¿™ä¸ªè§£æ³•ä¸­å¯ä»¥ä¼˜åŒ–çš„ç‚¹åœ¨å“ªé‡Œï¼Ÿé¦–å…ˆåˆ†ææ—¶é—´å¤æ‚åº¦ï¼Œä¸€ä¸ªæœ€å¤–å±‚çš„å¾ªç¯ï¼Œå†…éƒ¨æ˜¯æœ‰ä¸¤ä¸ªå¾ªç¯ï¼Œä¸€ä¸ªå¾ªç¯è®°å½•å½“å‰çš„å­å­—ç¬¦ä¸²çš„å­—å…¸é›†åˆï¼Œå¦å¤–ä¸€ä¸ªå¾ªç¯è¿›è¡Œæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²ã€‚æœ€åçš„æƒ…å†µå°±æ˜¯ $O(n^2)$ã€‚

æ­¤æ—¶å…¶å®æœ‰ä¸€ä¸ªå¯ä»¥ä¼˜åŒ–çš„ç‚¹ï¼Œå°±æ˜¯ä¸éœ€è¦æ¯æ¬¡é‡å¤å¾ªç¯è®¡ç®—`mp_2`ï¼Œæˆ‘ä»¬åªéœ€è¦å‡å»ä¸Šæ¬¡çš„å·¦ç«¯ç‚¹ï¼Œåœ¨åŠ ä¸Šè¿™æ¬¡çš„å³ç«¯ç‚¹å³å¯ã€‚

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector <int> res;
        if (s.size() < p.size()) return res;
        unordered_map <char, int> mp_1;
        unordered_map <char, int> mp_2;
        for (int i = 0; i < p.size(); i++) {
            mp_1[p[i]] ++;
            mp_2[s[i]] ++;
        }

        
        
        for (int left = 0, right = p.size() - 1; right < s.size();left++, right++) {
            
            int flag = 1;
            if (left != 0) {
                mp_2[s[left - 1]] --;
                mp_2[s[right]] ++;
            }
            for (auto mp_1_ : mp_1) {
                if (mp_2[mp_1_.first] != mp_1_.second) {
                    flag = 0;
                    break;
                }
            }
            if (flag) {
                res.push_back(left);
            }
        }
        return res;
    }
};
```

ç»è¿‡è¿™æ¬¡ä¼˜åŒ–ï¼Œå°±é€šè¿‡äº†ã€‚

## å­ä¸²

#### 560.å’Œä¸ºkçš„å­æ•°ç»„

é¦–å…ˆæƒ³åˆ°æš´åŠ›è§£å†³çš„æ–¹æ³•ï¼Œæˆ‘ä»¬éå†æ•´ä¸ªæ•°ç»„ï¼Œä¾æ¬¡è®¡ç®—ä» `i` åˆ°`j` ä¹‹é—´çš„å’Œï¼Œç„¶åä¸ `k ` è¿›è¡Œå¤§å°çš„æ¯”è¾ƒã€‚

```c++
class Solution {
public:
    int cla_nums_i_j(vector<int>& nums, int begin, int end) {
        int res = 0;
        for (int i = begin; i <= end; i++) {
            res += nums[i];
        }
        return res;
    }

    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int res = 0;
        vector<vector<int>>dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i <= j) {
                    dp[i][j] = cla_nums_i_j(nums, i, j); 
                    if (dp[i][j] == k) {  
                        res ++;
                    }
                }
            }
        }
        return res;
    }
};
```

å¾ˆæ˜æ˜¾ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦è‡³å°‘ä¸º $O(n^2)$ ï¼ˆæ²¡æœ‰è®¡ç®—`cla_nums_i_j`çš„æ—¶é—´å¤æ‚åº¦ï¼‰ã€‚æ‰€ä»¥è¿™æ ·æ˜¯ä¸€å®šä¼šè¶…æ—¶çš„ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œä¼˜åŒ–ã€‚é¦–å…ˆæˆ‘ä»¬æœ‰å¿…è¦é€ä¸ªè®¡ç®—`dp[i][j]` å—ï¼Ÿæˆ‘ä»¬èƒ½å¦åªè®¡ç®—å…¶ä»–çš„å€¼ï¼Œç„¶åç”¨è¿™äº›å€¼æŠŠæ‰€æœ‰çš„å€¼æ¨ç®—å‡ºæ¥ï¼Ÿä¾‹å¦‚`dp[i][j] = dp[0][j] - dp[0][i]`ã€‚

```c++
class Solution {
public:
    int cla_nums_i_j(vector<int>& nums, int begin, int end) {
        int res = 0;
        for (int i = begin; i <= end; i++) {
            res += nums[i];
        }
        return res;
    }

    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int res = 0;
        vector<int> dp(n, 0);
        for (int i = 0; i < n; i++) {
            dp[i] = cla_nums_i_j(nums, 0, i);
            if (dp[i] == k) {
                res ++;
            }
        }
        for (int i = 1; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (dp[j] - dp[i - 1] == k) {
                    res ++;
                }
            }
        }
        return res;
    }
};
```

è¿™æ¬¡è¿›è¡Œäº†ç®€å•çš„ä¼˜åŒ–ï¼Œä½†æ˜¯ä»ç„¶ä½¿ç”¨äº†åŒå±‚å¾ªç¯æ¥è¿›è¡Œ`i~j` ä¹‹é—´çš„å…ƒç´ å’Œçš„åˆ¤æ–­ã€‚è¿™æ¬¡é€šè¿‡äº†`87/93` ä¸ªæ ·ä¾‹ã€‚ä»ç„¶æ˜¯æ—¶é—´å¤æ‚åº¦è¿‡é«˜ã€‚è¿˜æœ‰ä¼˜åŒ–çš„ç©ºé—´ï¼Œæˆ‘åœ¨è®¡ç®—`dp[i]`æ—¶æ¯æ¬¡éƒ½è°ƒç”¨äº†`cla_nums_i_j` è¿™é‡Œæ¯æ¬¡éƒ½æœ‰é‡å¤è®¡ç®—ã€‚

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int res = 0;
        int tmp = 0;
        vector<int> dp(n, 0);
        for (int i = 0; i < n; i++) {
            tmp += nums[i];
            dp[i] = tmp;
            if (dp[i] == k) {
                res ++;
            }
        }
        for (int i = 1; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (dp[j] - dp[i - 1] == k) {
                    res ++;
                }
            }
        }
        return res;
    }
};
```

è¿™æ¬¡é€šè¿‡äº†ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ä»ç„¶å¾ˆé«˜\*_*!ã€‚

## åŠ¨æ€è§„åˆ’

 ![image-20240624100453657](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/image-20240624100453657.png)



**å®Œå…¨èƒŒåŒ…ç†è®º**

æœ‰ $N$ ä»¶ç‰©å“å’Œä¸€ä¸ªæœ€å¤šèƒ½èƒŒé‡é‡ä¸º $W$ çš„èƒŒåŒ…ã€‚ç¬¬ $i$ ä»¶ç‰©å“çš„é‡é‡æ˜¯ $weight[i]$ ï¼Œå¾—åˆ°çš„ä»·å€¼æ˜¯ $value[i]$ ã€‚æ¯ä»¶ç‰©å“éƒ½æœ‰æ— é™ä¸ªï¼ˆä¹Ÿå°±æ˜¯å¯ä»¥æ”¾å…¥èƒŒåŒ…å¤šæ¬¡ï¼‰ï¼Œæ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…é‡Œç‰©å“ä»·å€¼æ€»å’Œæœ€å¤§ã€‚**å®Œå…¨èƒŒåŒ…å’Œ01èƒŒåŒ…é—®é¢˜å”¯ä¸€ä¸åŒçš„åœ°æ–¹å°±æ˜¯ï¼Œæ¯ç§ç‰©å“æœ‰æ— é™ä»¶**ã€‚

**01èƒŒåŒ…éå†é¡ºåºçš„æ ¸å¿ƒæ€è·¯**

```c++
for(int i = 0; i < weight.size(); i++) { // éå†ç‰©å“
 	for(int j = bagWeight; j >= weight[i]; j--) { // éå†èƒŒåŒ…å®¹é‡
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
 	}
}
```

å†…å±‚çš„å¾ªç¯ï¼Œä»å¤§åˆ°å°éå†ï¼Œä¸ºäº†ä¿è¯æ¯ä¸ªç‰©å“ä»…è¢«æ·»åŠ ä¸€æ¬¡ã€‚

**å®Œå…¨èƒŒåŒ…æ ¸å¿ƒæ€è·¯**

```c++
// å…ˆéå†ç‰©å“ï¼Œå†éå†èƒŒåŒ…
for(int i = 0; i < weight.size(); i++) { // éå†ç‰©å“
 	for(int j = weight[i]; j < bagWeight ; j++) { // éå†èƒŒåŒ…å®¹é‡
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

#### 518.é›¶é’±å…‘æ¢II

`vector<int>dp(amount + 1, 0);` `dp[i]` è¡¨ç¤ºå½“å‰ `amount` ä¸º `i` ï¼Œæœ‰ `dp[i]` ç§æ–¹æ³•å¯ä»¥å‡‘æˆ `i` ã€‚ç”±äºæ¯ç§ç¡¬å¸å¯ä»¥ä½¿ç”¨æ— é™æ¬¡ã€‚æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é¢˜ç›®ã€‚å…ˆè¿›è¡Œç‰©å“çš„éå†ï¼Œä¹‹åè¿›è¡ŒèƒŒåŒ…å®¹é‡çš„éå†ã€‚

**é€’æ¨å…¬å¼**

> `dp[j]` ï¼ˆè€ƒè™‘`coins[i]`çš„ç»„åˆæ€»å’Œï¼‰å°±æ˜¯æ‰€æœ‰çš„ `dp[j - coins[i]]` ç›¸åŠ 
>
> ä¾‹å¦‚åœ¨è€ƒè™‘ç¬¬ä¸€å±‚å¾ªç¯æ—¶ `dp[5] = dp[0] + dp[1] + dp[2] + d[3] + dp[4]` 

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int>dp(amount + 1, 0); // dp[j]è¡¨ç¤ºå½“å‰amountä¸ºjï¼Œæœ‰dp[j]ç§æ–¹æ³•å¯ä»¥å‡‘æˆjã€‚
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
};
```

è¿™é‡Œå¤–å±‚å¾ªç¯åªèƒ½æ˜¯ç‰©å“ï¼Œå› ä¸ºå¦‚æœå¤–å±‚æ˜¯èƒŒåŒ…å®¹é‡çš„è¯ï¼Œæˆ‘ä»¬è®¡ç®—çš„æ˜¯æ’åˆ—æ•°ã€‚

#### 377.ç»„åˆæ€»åˆIV

è¿™é“é¢˜ç›®è·Ÿå‰ä¸€ä¸ªé¢˜ç›®ï¼ˆ518.é›¶é’±å…‘æ¢IIï¼‰ä¸ä¸€æ ·çš„ç‚¹åœ¨äºï¼Œè¿™ä¸ªé¢˜ç›®çš„é¡ºåºä¸åŒçš„åºåˆ—è¢«è§†ä¸ºä¸åŒçš„ç»„åˆã€‚è¿™é“é¢˜ç›®æˆ‘ä»¬å°†èƒŒåŒ…å®¹é‡æ”¾åˆ°å¤–å±‚å¾ªç¯ã€‚

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<unsigned> dp(target + 1, 0);
        dp[0] = 1;

        for (int j = 0; j <= target; j++) {
            for (int i = 0; i < nums.size(); i++) {
                if (j - nums[i] >= 0) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }

        return dp[target];
    }
};
```

è¿™é“é¢˜ç›®è¿˜æœ‰ä¸€ç§ `DFS` çš„è§£æ³•

```c++
class Solution {
public:

    void DFS(vector<int>&nums, int sum, int target, int end, int *res) {
        if (sum >= target) {
            if (sum == target) {
                (*res)++;
                cout << *res << endl;
            }

            return;
        }

        for (int i = 0; i < end; i++) {
            sum += nums[i];
            DFS(nums, sum, target, end, res);
            sum -= nums[i];
            cout << nums[i] << "|"<< sum <<"|"<<*res << endl;
        }
    }

    int combinationSum4(vector<int>& nums, int target) {
        int sum = 0;
        int res = 0;
        DFS(nums, sum, target, nums.size(), &res);
        return res;
    }
};
```

#### 139.å•è¯æ‹†åˆ†

`dp[i]` ä»£è¡¨å­—ç¬¦ä¸²`i` å‰è¾¹çš„å­—ç¬¦ä¸²èƒ½å¤Ÿè¢«æ‹¼æ¥å‡ºæ¥ã€‚åªæœ‰å½“ `dp[j]` ä¸ºçœŸï¼Œä¸” åœ¨å­—ç¬¦ä¸²åˆ—è¡¨å†…èƒ½å¤Ÿæ‰¾åˆ° `s[j, i - j]` çš„å­—ç¬¦æ—¶ `dp[i]` æ‰ä¸ºçœŸã€‚

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        auto wordDictSet = unordered_set <string> ();
        for (auto word : wordDict) wordDictSet.insert(word);

        auto dp = vector<bool>(s.size() + 1);
        dp[0] = true;

        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.find(s.substr(j ,i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
```

#### 72.ç¼–è¾‘è·ç¦»

ç»™å‡ºä¸¤ä¸ªå•è¯`word1`å’Œ`word2`ï¼Œè¿”å›å°† `word1` è½¬æ¢ä¸º `word2` æ‰€ä½¿ç”¨çš„æœ€å°æ“ä½œæ¬¡æ•°ã€‚è¿™é‡Œå•è¯ä¹‹é—´çš„è½¬æ¢æœ‰ä¸‰ç§æ–¹å¼

1. åˆ é™¤
2. æ’å…¥
3. æ›¿æ¢

`dp[i][j]`ä»£è¡¨ `word1[0 ~ i]` è½¬æ¢ä¸º `word[0 ~ j]` æ‰€ç”¨çš„æœ€å°‘æ“ä½œæ•°

| 0     | r - 1 | o - 2 | s - 3 |
| ----- | ----- | ----- | ----- |
| h - 1 | 1     | 2     | 3     |
| o - 2 | 2     | 1     | 2     |
| r - 3 | 2     | 2     | 2     |
| s - 4 | 3     | 3     | 2     |
| e - 5 | 4     | 4     | **3** |

æ ¹æ®è¿™ä¸ªå›¾å¯ä»¥æ˜æ˜¾çœ‹å‡ºï¼Œå½“ `word1[i] == word2[j]` æ—¶ï¼Œ`dp[i][j] = dp[i - 1][j - 1]` è¿™ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥ç¡®å®šä¸€ä¸ªçŠ¶æ€è½¬æ¢
$$
dp[i][j] = dp[i - 1][j - 1] \qquad word1[i] == word2[j]
$$
æ¥ä¸‹æ¥æˆ‘ä»¬éœ€è¦åˆ¤æ–­å½“ `word1[i] != word2[j]` æ—¶çš„æƒ…å†µï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“å†™å‡º
$$
dp[i][j] = \min (dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 \qquad word1[i] != word2[j]
$$
ä½†æ˜¯ï¼Œè¿™å…¶ä¸­ä»£è¡¨ä»€ä¹ˆæ„æ€ï¼Ÿ`dp[i - 1][j]` ä»è¡¨æ ¼ä¸­å¯ä»¥çœ‹å‡ºï¼Œæ˜¯ `h -> ros` çš„æ¬¡æ•°ï¼Œè€Œå®ƒçš„ä¸‹ä¸€æ­¥å˜æ¢ `ho -> ros` ã€‚å¦‚æœ `ho - > ros` çš„çŠ¶æ€å¯ä»¥ä» `h - > ros` è½¬åŒ–ï¼Œé‚£ä¹ˆä¹Ÿå°±æ˜¯è¯´ä¸éœ€è¦ä½¿ç”¨ `o` ã€‚ä¹Ÿå°±æ˜¯åˆ é™¤äº† `o` ã€‚æ‰€ä»¥è¿™ä¸ª `dp[i][j] = dp[i - 1][j]` ä»£è¡¨åˆ é™¤ã€‚åŒç† `hor -> ros = hor -> ro` ä»£è¡¨æ’å…¥`r` ã€‚`hor -> ros = ho -> ro` ä»£è¡¨æ›¿æ¢ã€‚

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len_word1 = word1.size(), len_word2 = word2.size();
        if (len_word1 == 0) return len_word2;
        // dp[i][j] ä»£è¡¨ word1[0 ~ i] è½¬æ¢ä¸º word[0 ~ j] æ‰€ç”¨çš„æœ€å°‘æ“ä½œæ•°
        vector<vector<int>>dp(len_word1 + 1, vector<int>(len_word2 + 1, 0));
        // cout << dp.size() << " " << dp[0].size() << endl;

        for (int i = 1; i <= len_word1; i++) {
            dp[i][0] = i;
            for (int j = 1; j <= len_word2; j++) {
                dp[0][j] = j;
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    cout << "i:" << i << "j:" << j << endl;
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }

        return dp[len_word1][len_word2];
    }
};
```





### åŒºé—´DP

![æˆªå±2024-06-26 15.46.24](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-06-26 15.46.24.png)

#### 516.æœ€é•¿å›æ–‡å­åºåˆ—

**æ€è·¯ä¸€ï¼š**

æ±‚ `s` å’Œåè½¬åçš„ `s` çš„ `LCS` 

#### 1143.LCS

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int text1Len = text1.size(), text2Len = text2.size();
        int dp[text1Len + 1][text2Len + 1];

        for (int i = 0; i <= text1Len; i++)
            for (int j = 0; j <= text2Len; j++) dp[i][j] = 0;

        for (int i = 0; i < text1Len; i++) {
            for (int j = 0; j < text2Len; j++) {
                if (text1[i] == text2[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
                else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }

        return dp[text1Len][text2Len];
    }
};
```

```c++
class Solution {
public:
    int longestCommonSubsequence(string& text1, string& text2) {
        int len_text1 = text1.size(), len_text2 = text2.size();
        // å®šä¹‰ dp[i][j] ä»£è¡¨ text1[0, i - 1] å’Œ text2[0, j - 1] ä¹‹é—´çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦
        vector<vector<int>> dp(len_text1 + 1, vector<int>(len_text2 + 1, 0));

        for (int i = 0; i < len_text1; i++) {
            for (int j = 0; j < len_text2; j++) {
                if (text1[i] == text2[j]) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                } else {
                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
                }
            }
        }
        return dp[len_text1][len_text2];

    }

    int longestPalindromeSubseq(string s) {
        string s1 = s;
        reverse(s1.begin(),s1.end());
        return longestCommonSubsequence(s, s1);


    }
};
```





**æ€è·¯äºŒï¼š**

ã€é€‰æˆ–ä¸é€‰ã€‘ä»ä¸¤ä¾§å‘å†…ç¼©å°é—®é¢˜è§„æ¨¡

![æˆªå±2024-06-26 15.49.28](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-06-26 15.49.28.png)

ï¼ˆç±»ä¼¼LCSï¼‰å®šä¹‰ `dfs(i,j)` è¡¨ç¤ºä» `s[i]` åˆ° `s[j]` çš„æœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦

<img src="/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-06-26 15.51.46.png" alt="æˆªå±2024-06-26 15.51.46" style="zoom:50%;" />

é€’å½’è¾¹ç•Œ ï¼š
$$
dfs(i,i) = 1 \\
dfs(i + 1, i) = 0
$$
é€’å½’å…¥å£ï¼š$dfs(0, n - 1)$

```c++
class Solution {
public:

    int dfs(int begin, int end, string& s) {
        if (begin == end) {
            return 1;
        }
        if (begin > end) {
            return 0;
        }
        if (s[begin] == s[end]) {
            return dfs(begin + 1, end - 1, s) + 2;
        } 
        return max(dfs(begin + 1, end, s), dfs(begin, end - 1, s));
        
    }

    int longestPalindromeSubseq(string s) {
        return dfs(0, s.size() - 1, s);
    }
};
```

å¾ªç¯çš„å†™æ³•ï¼š

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dp[i][j] ä»£è¡¨ä» i åˆ° j ä¹‹é—´çš„æœ€å¤§å›æ–‡å­åºåˆ—é•¿åº¦
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;

        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][s.size() - 1];
    }
};
```











```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int len = s.size();
        int dp[len + 1][len + 1];   // dp[i][j] ä¸º i åˆ° j ä¹‹é—´æœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦
        // é€’æ¨å…¬å¼ ï¼šif (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2
        // 
        for (int i = 0; i <= len; i++) 
            for (int j = 0; j <= len; j++) {
                if (i == j) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = 0;
                }
            }

        for (int i = len - 1; i >= 0; i--) {
            for (int j = i + 1; j < len; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][len - 1];
    }
};
```

#### 020.LCR å›æ–‡å­ä¸²

ä¹Ÿæ˜¯åŒæ ·çš„æ–¹æ³•ï¼Œ`dp[i][j]` è¡¨ç¤º `[i,j]` ä¹‹é—´çš„å­—ç¬¦ä¸²æ˜¯ä¸æ˜¯å›æ–‡å­—ç¬¦ä¸²ã€‚å¦‚æœæ˜¯ï¼Œæˆ–è€…`j - i == 1`å°±æ˜¯æŒ‡ä¸¤ä¸ªåªç›¸å·®ä¸€ä¸ªå­—ç¬¦ï¼Œé‚£ä¹ˆ æ­¤æ—¶å›æ–‡å­ä¸²çš„æ•°é‡å°±åŠ ä¸€ã€‚

```c++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        int res = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j] && (j - i == 1 || dp[i + 1][j - 1] == 1)) {
                    dp[i][j] = 1;
                    res ++;
                }
            }
        }
        
        return res + s.size();
    }
};
```







## æ¯æ—¥ä¸€é¢˜

#### 189.è½®è½¬æ•°ç»„

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        unordered_map<int, int> pair;

        for (int i = 0; i < nums.size(); i++) {
            int second = nums[i];
            int first = (i + k) % nums.size();
            // pair.insert({first, second});
            pair[first] = second;
        }

        cout << pair.size() << endl;

        for (auto pair_ : pair) {
            nums[pair_.first] = pair_.second;
        }
    }
};
```













#### 56.åˆå¹¶åŒºé—´

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](const vector<int> &a, const vector<int> &b) {return a[0] < b[0]; });
        vector<vector<int>> res;
        vector<int> res_tmp;
        int cnt;
        for (int i = 0; i < intervals.size(); i++) {
            res_tmp.push_back(intervals[i][0]);
            cout << "intervals[i][0]:" << intervals[i][0] << endl;
            int end = intervals[i][1];
            cnt = i + 1;
            for (cnt; cnt < intervals.size(); cnt ++) {
                if (end >= intervals[cnt][0]) {
                    if (end <= intervals[cnt][1]) {
                        end = intervals[cnt][1];
                    }
                } else {
                    break;
                }
            }
            res_tmp.push_back(end);
            i = cnt - 1;
            res.push_back(res_tmp);
            res_tmp.clear();
        }
        return res;
    }
};
```



#### 2024å¹´5æœˆ24æ—¥-1673.æ‰¾å‡ºæœ€å…·ç«äº‰åŠ›çš„å­åºåˆ—

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ­£æ•´æ•° `k` ï¼Œè¿”å›é•¿åº¦ä¸º `k` ä¸”æœ€å…· **ç«äº‰åŠ›** çš„ `nums` å­åºåˆ—ã€‚

æ•°ç»„çš„å­åºåˆ—æ˜¯ä»æ•°ç»„ä¸­åˆ é™¤ä¸€äº›å…ƒç´ ï¼ˆå¯èƒ½ä¸åˆ é™¤å…ƒç´ ï¼‰å¾—åˆ°çš„åºåˆ—ã€‚

åœ¨å­åºåˆ— `a` å’Œå­åºåˆ— `b` ç¬¬ä¸€ä¸ªä¸ç›¸åŒçš„ä½ç½®ä¸Šï¼Œå¦‚æœ `a` ä¸­çš„æ•°å­—å°äº `b` ä¸­å¯¹åº”çš„æ•°å­—ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­åºåˆ— `a` æ¯”å­åºåˆ— `b`ï¼ˆç›¸åŒé•¿åº¦ä¸‹ï¼‰æ›´å…· **ç«äº‰åŠ›** ã€‚ ä¾‹å¦‚ï¼Œ`[1,3,4]` æ¯” `[1,3,5]` æ›´å…·ç«äº‰åŠ›ï¼Œåœ¨ç¬¬ä¸€ä¸ªä¸ç›¸åŒçš„ä½ç½®ï¼Œä¹Ÿå°±æ˜¯æœ€åä¸€ä¸ªä½ç½®ä¸Šï¼Œ `4` å°äº `5` ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums = [3,5,2,6], k = 2
è¾“å‡ºï¼š[2,6]
è§£é‡Šï¼šåœ¨æ‰€æœ‰å¯èƒ½çš„å­åºåˆ—é›†åˆ {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} ä¸­ï¼Œ[2,6] æœ€å…·ç«äº‰åŠ›ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnums = [2,4,3,3,5,4,9,6], k = 4
è¾“å‡ºï¼š[2,3,3,4]
```

èƒ½å¤Ÿæƒ³åˆ°ä½¿ç”¨å•è°ƒæ ˆæ¥è¿›è¡Œå•è°ƒé€’å¢æ•°ç»„çš„ç»´æŠ¤ã€‚æ¯”å¦‚`nums = [3, 5, 2, 6]` å¯ä»¥è®¡ç®—å‡ºæ­¤æ—¶å¯¹äºè¿™ä¸ªæ•°ç»„çš„å•è°ƒé€’å¢æ•°ç»„åºåˆ—ä¸º`[2, 6]` ã€‚åŒç†æ­¤æ—¶ `nums = [2, 4, 3, 3, 5, 4, 9, 6]` å¯ä»¥è®¡ç®—å‡ºå•è°ƒé€’å¢æ•°ç»„åºåˆ—ä¸º`[2, 3, 3, 4, 6]` ã€‚ç„¶åæˆªå–å‰ `k`ä¸ªæ•°å­—ã€‚ç”±æ­¤å¯ä»¥çŸ¥é“ï¼Œå•è°ƒæ ˆå…¶å®æ˜¯ç¬¦åˆè¿™é“é¢˜ç›®çš„æ€æƒ³çš„ã€‚ä½†æ˜¯é¢˜ç›®ä¸­æœ‰è¦æ±‚è¿”å›çš„æ•°ç»„çš„é•¿åº¦å¿…é¡»æ˜¯ `k`ã€‚è¿™å°±é€ æˆè¿™ç§è§£æ³•çš„å±€é™æ€§ï¼Œæ¯”å¦‚`nums = [2, 4, 3, 3, 5, 4, 9, 6, 1]` è¿™ç§æƒ…å†µå°±æ— æ³•è§£å‡ºæ­£ç¡®ç­”æ¡ˆï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡ç»´æŠ¤å•è°ƒæ ˆçš„æ—¶å€™åŠ å…¥åˆ¤æ–­æ¡ä»¶ï¼Œå°±æ˜¯æ ˆé¡¶å…ƒç´ å‡ºæ ˆçš„æ—¶å€™ï¼Œæ­¤æ—¶æ ˆå†…å…ƒç´ æ•°é‡åŠ ä¸Šæ•°ç»„`nums` å‰©ä½™å…ƒç´ çš„æ•°é‡æ˜¯å¦å¤§äº`k`ã€‚å¦‚æœæ¯”`k`å°ï¼Œé‚£ä¹ˆæ­¤æ—¶å°±ä¸èƒ½å‡ºæ ˆã€‚

æˆ‘ä»¬åœ¨å®ç°çš„æ—¶å€™å¯ä»¥ç›´æ¥ç”¨`vector`è¿›è¡Œæ ˆæ“ä½œçš„æ¨¡æ‹Ÿã€‚

```c++
class Solution {
public:
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        if (nums.size() == k) return nums;
        
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            int x = nums[i];
            while (!res.empty() && x < res.back() && res.size() + nums.size() - i > k) {
                res.pop_back();
            }
            if (res.size() < k) {
                res.push_back(x);
            }
        }
        return res;
    }
};
```







### 1.åŠ¨æ€è§„åˆ’

##### å›æ–‡ä¸²åˆ¤å®š

```c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] è¡¨ç¤º s[i..j] æ˜¯å¦æ˜¯å›æ–‡ä¸²
        vector<vector<int>> dp(n, vector<int>(n));
        // åˆå§‹åŒ–ï¼šæ‰€æœ‰é•¿åº¦ä¸º 1 çš„å­ä¸²éƒ½æ˜¯å›æ–‡ä¸²
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        // é€’æ¨å¼€å§‹
        // å…ˆæšä¸¾å­ä¸²é•¿åº¦
        for (int L = 2; L <= n; L++) {
            // æšä¸¾å·¦è¾¹ç•Œï¼Œå·¦è¾¹ç•Œçš„ä¸Šé™è®¾ç½®å¯ä»¥å®½æ¾ä¸€äº›
            for (int i = 0; i < n; i++) {
                // ç”± L å’Œ i å¯ä»¥ç¡®å®šå³è¾¹ç•Œï¼Œå³ j - i + 1 = L å¾—
                int j = L + i - 1;
                // å¦‚æœå³è¾¹ç•Œè¶Šç•Œï¼Œå°±å¯ä»¥é€€å‡ºå½“å‰å¾ªç¯
                if (j >= n) {
                    break;
                }

                if (s[i] != s[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // åªè¦ dp[i][L] == true æˆç«‹ï¼Œå°±è¡¨ç¤ºå­ä¸² s[i..L] æ˜¯å›æ–‡ï¼Œæ­¤æ—¶è®°å½•å›æ–‡é•¿åº¦å’Œèµ·å§‹ä½ç½®
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
}
```

```c
char * longestPalindrome(char * s){
    int maxLen = 1, start = 0;
    int len = strlen(s);
    int dp[1005][1005];                             //ç”¨æ¥è®°å½•å­—ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²
    for (int i = 0; i < 1005; i++)
        dp[i][i] = 1;
    if (len < 2) return s;
    else{
        for (int L = 2; L <= len; L++) {            //æšä¸¾å­—ä¸²é•¿åº¦
            for (int i = 0; i < len; i++){          //æšä¸¾å·¦è¾¹ç•Œ
                int j = L + i - 1;                  //ç”Ÿæˆå³è¾¹ç•Œ
                if (j >= len) break;                //å¦‚æœå³è¾¹ç•Œè¶Šç•Œåˆ™å¾ªç¯é€€å‡º
                if (s[i] != s[j]) {
                    dp[i][j] = 0;                   //æ­¤æ—¶s[i][j]å­—ä¸²ä¸æ˜¯å›æ–‡ä¸²
                } else {
                    if (j - i < 3) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && (j - i + 1) > maxLen) {
                    start = i;
                    maxLen = j - i + 1;
                }
            }
        }
        s[maxLen + start] = '\0';
        return &s[start];
    } 
}
```

##### 2707.å­—ç¬¦ä¸²ä¸­çš„é¢å¤–å­—ç¬¦

![æˆªå±2024-01-09 20.36.45](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-09 20.36.45.png)

```c++
class Solution {
public:
    int minExtraChar(string s, vector<string>& dictionary) {
        // åŠ¨æ€è§„åˆ’ dp[i] ä¸º s[0:i] ä¸­å‰©ä½™å­—ç¬¦æœ€å°
        // æ­£å¸¸æƒ…å†µä¸‹ï¼šdp[i + 1] = dp[i] + 1
        // å½“å‡ºç°å­ä¸²ï¼šdp[i + 1] = min(dp[i + 1], dp[j])(éå† 0 - i ä¹‹é—´çš„å­ä¸²)
        unordered_set<string> dict(dictionary.begin(), dictionary.end());
        int n = s.size();
        vector<int> dp(n + 1);
        for (int i = 0; i < n; ++i) {
            dp[i + 1] = dp[i] + 1;
            for (int j = 0; j <= i; ++j) {
                if (dict.count(s.substr(j, i - j + 1))) {
                    dp[i + 1] = min(dp[i + 1], dp[j]);
                }
            }
        }
        return dp[n];

    }
};
```

##### 1143.æœ€é•¿å…¬å…±å­ä¸²

![æˆªå±2024-02-18 22.37.52](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-02-18 22.37.52.png)

å®šä¹‰ï¼š`dp[i][j]:=s1...siå’Œt1...tj` å¯¹åº”çš„LCSçš„é•¿åº¦ã€‚ç”±æ­¤ï¼Œ`s1...si+1å’Œt1...tj+1` å¯¹åº”çš„å…¬å…±å­åˆ—å¯èƒ½æ˜¯ï¼š

- å½“ `si+1 = tj+1` æ—¶ï¼Œ åœ¨ `s1...si å’Œ t1...tj` çš„å…¬å…±å­åˆ—æœ«å°¾è¿½åŠ ä¸Š `si+1`
- `s1...si+1 å’Œ t1...tj ` çš„å…¬å…±å­åºåˆ—
- `s1...si å’Œ t1...tj+1 ` çš„å…¬å…±å­åºåˆ—

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int text1Len = text1.size(), text2Len = text2.size();
        int dp[text1Len + 1][text2Len + 1];

        for (int i = 0; i <= text1Len; i++)
            for (int j = 0; j <= text2Len; j++) dp[i][j] = 0;

        for (int i = 0; i < text1Len; i++) {
            for (int j = 0; j < text2Len; j++) {
                if (text1[i] == text2[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
                else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }

        return dp[text1Len][text2Len];
    }
};
```

#### 139.å•è¯æ‹†åˆ†

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        auto wordDictSet = unordered_set <string> ();
        for (auto word : wordDict) wordDictSet.insert(word);

        auto dp = vector<bool>(s.size() + 1);
        dp[0] = true;

        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.find(s.substr(j ,i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
```











### 2.ç›¸å‘åŒæŒ‡é’ˆ

#### 11.ç››æœ€å¤šæ°´çš„å®¹å™¨

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-19 23.00.57.png" alt="æˆªå±2023-12-19 23.00.57" style="zoom:50%;" />

ä½¿ç”¨ç›¸å‘åŒæŒ‡é’ˆï¼Œ`left` å’Œ`right`ã€‚å›åˆ°è¿™ä¸ªé¢˜ç›®ï¼Œä½ ä¼šå‘ç°ï¼Œå¯¹äºæœ€åä¸€æ ¹çº¿ï¼Œåœ¨ä¸­é—´ä»»ä½•æ¯”ä»–çŸ®çš„çº¿æ›¿æ¢ä»–éƒ½æ— æ³•ä½¿å¾—å½“å‰çš„é¢ç§¯å¤§äºç°åœ¨çš„é¢ç§¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¦æƒ³è·å¾—å¯èƒ½ï¼ˆå› ä¸ºæ›´æ¢åè¿˜æ˜¯å¯èƒ½å°äºå½“å‰é¢ç§¯çš„ï¼‰å¤§äºå½“å‰é¢ç§¯çš„æƒ…å†µï¼Œæˆ‘ä»¬åªèƒ½é€‰æ‹©è¾ƒå°çš„`left` å’Œ `right` æ¥è¿›è¡Œæ›¿æ¢ã€‚ä¸¾ä¸ªğŸŒ°ï¼Œå¯¹äº`height[0]` å’Œ `height[8]` æ¥è¯´ï¼Œå½“å‰çš„é¢ç§¯æ˜¯`7`ã€‚è¦æƒ³è·å¾—å¤§äºå½“å‰é¢ç§¯çš„é€‰æ‹©ï¼Œæˆ‘ä»¬åªèƒ½é€‰æ‹©`height[0]`å’Œ`height[8]` ä¹‹é—´è¾ƒå°çš„å€¼è¿›è¡Œæ›¿æ¢æ‰æœ‰å¯èƒ½è·å¾—å¤§äºå½“å‰çš„é¢ç§¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æ­¤æ—¶é€‰æ‹©`left++` ï¼Œå¾—åˆ° `height[1]` ï¼Œæ­¤æ—¶çš„é¢ç§¯æ˜¯`49`ã€‚

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int res = 0;

        while (left < right) {
            res = max(res, min(height[left], height[right]) * (right - left));
            if (height[left] < height[right]) left++;
            else right--;
        }
        return res;

    }
};
```

å¤æ‚åº¦åˆ†æï¼š

æ—¶é—´å¤æ‚åº¦ï¼šO(n) 

ç©ºé—´å¤æ‚åº¦ï¼šO(1)



### 3.åŒå‘åŒæŒ‡é’ˆ

#### 100137.ç»Ÿè®¡æœ€å¤§å…ƒç´ å‡ºç°è‡³å°‘Kæ¬¡çš„å­æ•°ç»„

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-10 14.15.07.png" alt="æˆªå±2023-12-10 14.15.07" style="zoom:50%;" />

**åŒå‘åŒæŒ‡é’ˆ+æ»‘åŠ¨çª—å£** 

åœ¨å­æ•°ç»„å­ä¸²é—®é¢˜ä¸­ï¼Œç»å¸¸ä¼šç”¨åˆ°åŒæŒ‡é’ˆè¿™ä¸€æŠ€å·§ ã€‚ä¸¾ä¸ªä¾‹å­ï¼šç»™å®šä¸€ä¸ªå«æœ‰ `n` ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° `target` ã€‚æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶å’Œ `>=target`çš„é•¿åº¦æœ€å°çš„ **è¿ç»­å­æ•°ç»„** `nums` ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› `0` .

ä¾‹å¦‚209é¢˜ç›®ã€‚

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLen = nums.size() + 1;

        int left = 0;
        int right = 0;
        int sum = 0;
        for (; right < nums.size(); right++)
        {
            sum += nums[right];
            while ((sum - nums[left]) >= target)
            {
                sum -= nums[left];
                left ++;
            }
            if (sum >= target) minLen = min(minLen, right - left + 1);
        }
        return minLen <= nums.size() ? minLen : 0;
    }
};
```

 å†æ¯”å¦‚**713.ä¹˜ç§¯å°äºKçš„å­æ•°ç»„** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¿”å›å­æ•°ç»„å†…æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯ä¸¥æ ¼å°äº `k` çš„è¿ç»­å­æ•°ç»„çš„æ•°ç›®ã€‚ä¸‡å˜ä¸ç¦»å…¶å®—ï¼Œå…ƒç´ éƒ½æ˜¯æ­£æ•°ï¼Œæ–¹æ³•å’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼Œå¯¹äº `[10, 5, 2, 6]` æ¯”å¦‚æšä¸¾åˆ° `2` çš„æ—¶å€™ï¼Œå°±æŠŠ `2` æ¥åˆ°ä¸Šä¸€æ¬¡è®¡ç®—çš„ç»“æœåé¢ã€‚é‚£å¦‚æœå…ƒç´ çš„ä¹˜ç§¯ `>=k` å°±æŠŠå·¦ç«¯ç‚¹å³ç§»ï¼Œç¼©å°å­æ•°ç»„çš„é•¿åº¦ï¼Œç›´åˆ°ä¹˜ç§¯å°äº `k` ä¸ºæ­¢ã€‚é‚£ä¹ˆé—®é¢˜çš„å…³é”®ï¼Œä¹Ÿæ˜¯ä¸ä¸Šé¢˜ä¸åŒçš„ç‚¹ï¼Œ**å­æ•°ç»„çš„æ•°ç›®è¦æ€ä¹ˆç®—** è¿™é‡Œï¼Œæˆ‘ä»¬æšä¸¾åˆ° `2` ï¼Œéœ€è¦ç®—çš„å°±æ˜¯ä»¥ `2` ä¸ºå³ç«¯ç‚¹çš„æ»¡è¶³è¦æ±‚çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚`[5, 2]`ç®—æ˜¯ä¸€ä¸ªï¼Œ `[2]` å•ç‹¬ç®—ä¸€ä¸ªã€‚ç”¨ä»£ç æ¥è®¡ç®—ï¼Œå°±éœ€è¦æ¨å¯¼å‡ºæ¥ä¸€ä¸ªå…¬å¼ï¼Œå‡è®¾æ­¤æ—¶å·¦ç«¯ç‚¹ä¸º `l`ï¼Œå³ç«¯ç‚¹ä¸º`r` ã€‚é‚£ä¹ˆæˆ‘ä»¬ç°åœ¨éœ€è¦è®¡ç®—çš„å°±æ˜¯ä»¥ `r` ä¸ºå³ç«¯ç‚¹çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚æ³¨æ„å³ç«¯ç‚¹æ˜¯å›ºå®šçš„ï¼Œå¦‚æœä» `l` åˆ° `r` çš„è¿™ä¸€æ®µçš„ä¹˜ç§¯æ˜¯å°äº `k` çš„ã€‚é‚£ä¹ˆä» `l+1` åˆ° `r` çš„è¿™ä¸€æ®µä¹Ÿæ˜¯å°äº `k` çš„ã€‚ä¸€ç›´åˆ° `[r, r]` è¿™äº›å­æ•°ç»„éƒ½æ˜¯æ»¡è¶³è¦æ±‚çš„ã€‚é‚£ä¹ˆå­æ•°ç»„çš„ä¸ªæ•°å…¶å®å°±æ˜¯ä» `l` åˆ° `r` çš„å…ƒç´ ä¸ªæ•°ã€‚é‚£ä¹ˆå°±æ˜¯ `r-l+1` 

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) return 0;
        int left = 0;
        int right = 0;
        int sum = 1;
        int maxNums = 0;

        for (; right < nums.size(); right++)
        {
            sum *= nums[right];
            while (sum  >= k)
            {
                sum /= nums[left];
                left ++;  
            }
            maxNums += right - left + 1;
        }

        return maxNums;
    }
};
```

æ¥ç€è¿˜æœ‰ **3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` ,æ‰¾å‡ºå…¶ä¸­ä¸å«é‡å¤å­—ç¬¦çš„ **æœ€é•¿å­ä¸²** çš„é•¿åº¦ã€‚ç”±äºå¦‚æœå‡ºç°çš„é‡å¤å­—ç¬¦çš„å”¯ä¸€æƒ…å†µå°±æ˜¯åˆšåˆšåŠ å…¥çš„å­—ç¬¦ä¸ä¹‹å‰çš„å­—ç¬¦å‘ç”Ÿé‡å¤ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä½¿ç”¨å“ˆå¸Œçš„æ–¹æ³•ï¼Œç»Ÿè®¡ä¸€ä¸‹åˆšåŠ å…¥çš„å­—ç¬¦æ˜¯å¦å‡ºç°é‡å¤å³å¯ã€‚

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0;
        int right = 0;
        int maxLen = 0;
        unordered_map<char, int> mp;
        for (right; right < s.size(); right++)
        {
            mp[s[right]] ++;
            while (mp[s[right]] >= 2)
            {
                mp[s[left]] --;
                left ++;
            }
            maxLen = max(maxLen, right - left + 1);
        }
        return maxLen;
    }
};
```

å›åˆ°è¿™ä¸ªé¢˜ç›®ï¼Œé¦–å…ˆæ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§æ•°ï¼Œè®¾ $mx=max(nums)$ å³ç«¯ç‚¹ $right$ ä»å·¦åˆ°å³éå† $nums$ ã€‚éå†åˆ°å…ƒç´ $x=nums[right]$  å¦‚æœ $x=mx$ ï¼Œå°±æŠŠè®¡æ•°å™¨ $cntMx$ åŠ ä¸€ã€‚å¦‚æœæ­¤æ—¶ $cntMx = k$ åˆ™ä¸æ–­å³ç§»å·¦æŒ‡é’ˆ $left$ ï¼Œç›´åˆ°çª—å†…çš„ $mx$ çš„å‡ºç°æ¬¡æ•° **å°äº** $k$ ä¸ºæ­¢ã€‚æ­¤æ—¶ï¼Œå¯¹äºå³ç«¯ç‚¹ä¸º $right$ ä¸”å·¦ç«¯ç‚¹å°äº $left$ çš„å­æ•°ç»„ï¼Œ$mx$ çš„å‡ºç°æ¬¡æ•°éƒ½è‡³å°‘ä¸º $k$ ï¼ŒæŠŠç­”æ¡ˆå¢åŠ  $left$ ã€‚

```c++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        int left = 0;
        int right = 0;
        int maxVal = 0;
        for (int i = 0; i < nums.size(); i++) maxVal = max(maxVal, nums[i]);
        int maxValCnt = 0;
        long long sum = 0;

        for (right; right < nums.size(); right++)
        {
            if (nums[right] == maxVal) maxValCnt ++;
            while (maxValCnt == k)
            {
                if (nums[left] == maxVal) maxValCnt --;
                left ++;
            }
            sum += left;
        }

        return sum;
    }
};
```

### 4.äºŒåˆ†æŸ¥æ‰¾æ³•  çº¢è“æŸ“è‰²æ³•

#### 34.åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªä½ç½®

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-20 22.05.14.png" alt="æˆªå±2023-12-20 22.05.14" style="zoom:50%;" />

æš´åŠ›åšæ³•ï¼Œä»å·¦åˆ°å³ä¾æ¬¡éå†ï¼Œä½†æ˜¯æš´åŠ›åšæ³•æ²¡æœ‰åˆ©ç”¨åˆ°æ•°ç»„æ˜¯æœ‰åºçš„è¿™ä¸€æ€§è´¨ã€‚ä½†æ˜¯æˆ‘ä»¬è¦å¦‚ä½•åˆ©ç”¨åˆ°æ•°ç»„æ˜¯æœ‰åºçš„è¿™ä¸€æ€§è´¨å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸¤ä¸ªæŒ‡é’ˆ`L`å’Œ`R`ã€‚æˆ‘ä»¬æŠŠè¿™ä¸¤ä¸ªæŒ‡é’ˆåˆå§‹åŒ–`L=0, R=n-1`ï¼Œå³åˆ†åˆ«æŒ‡å‘æ•°ç»„çš„æœ€å·¦è¾¹å…ƒç´ å’Œæœ€å³è¾¹å…ƒç´ ã€‚è¡¨ç¤ºæˆ‘ä»¬ç°åœ¨éœ€è¦çŸ¥é“è¿™ä¸ªé—­åŒºé—´å†…çš„æ¯ä¸ªæ•°å’Œ8çš„å¤§å°å…³ç³»ã€‚å³ç°åœ¨é—­åŒºé—´å†…çš„é¢œè‰²éƒ½æ˜¯ä¸ç¡®å®šçš„ã€‚æ¯”å¦‚ç›®å‰`M`è¿™ä¸ªä½ç½®ï¼Œå®ƒæ¯”8å°ï¼Œç”±äºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆå®ƒå·¦è¾¹çš„æ•°ä¸€å®šæ¯”8å°ã€‚å¦‚æœå®ƒå¤§äºç­‰äº8ï¼Œå®ƒå³è¾¹çš„æ•°ä¹Ÿæ˜¯å¤§äºç­‰äº8çš„ã€‚ç°åœ¨æ˜¯`M`çš„å–å€¼é—®é¢˜ï¼Œå¦‚æœ`M`å–åœ¨ä¸­é—´ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç«‹åˆ»å°±çŸ¥é“æ•°ç»„ä¸­ä¸€åŠçš„æ•°ä¸8çš„å¤§å°å…³ç³»ã€‚

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-20 22.12.15.png" alt="æˆªå±2023-12-20 22.12.15" style="zoom:50%;" />

æˆ‘ä»¬ç”¨çº¢è‰²è¡¨ç¤ºå°äº8çš„æ•°ï¼Œç”¨è“è‰²è¡¨ç¤ºå¤§äº8çš„æ•°ã€‚

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-20 22.20.02.png" alt="æˆªå±2023-12-20 22.20.02" style="zoom:50%;" />

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-20 22.21.44.png" alt="æˆªå±2023-12-20 22.21.44" style="zoom:50%;" />

æ³¨æ„âš ï¸è¿™é‡Œ`L`æ›´æ–°ä¸º`M+1`ï¼Œå¦‚æœ`L`æ›´æ–°ä¸º`M`ã€‚é‚£ä¹ˆè€ƒè™‘åªæœ‰ä¸€ä¸ªå…ƒç´ çš„æƒ…å†µï¼Œè¿™æ—¶å€™å°±æ˜¯æ­»å¾ªç¯ã€‚

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-20 22.24.25.png" alt="æˆªå±2023-12-20 22.24.25" style="zoom:50%;" />

```c++
class Solution {
    // lower_bound è¿”å›æœ€å°çš„æ»¡è¶³ nums[i] >= target çš„ i
    // å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œæˆ–è€…æ‰€æœ‰æ•°éƒ½ < targetï¼Œåˆ™è¿”å› nums.size()
    // è¦æ±‚ nums æ˜¯éé€’å‡çš„ï¼Œå³ nums[i] <= nums[i + 1]

    // é—­åŒºé—´å†™æ³•
    int lower_bound(vector<int> &nums, int target) {
        int left = 0, right = (int) nums.size() - 1; // é—­åŒºé—´ [left, right]
        while (left <= right) { // åŒºé—´ä¸ä¸ºç©º
            // å¾ªç¯ä¸å˜é‡ï¼š
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1; // èŒƒå›´ç¼©å°åˆ° [mid+1, right]
            else
                right = mid - 1; // èŒƒå›´ç¼©å°åˆ° [left, mid-1]
        }
        return left; // æˆ–è€… right+1
    }

    // å·¦é—­å³å¼€åŒºé—´å†™æ³•
    int lower_bound2(vector<int> &nums, int target) {
        int left = 0, right = nums.size(); // å·¦é—­å³å¼€åŒºé—´ [left, right)
        while (left < right) { // åŒºé—´ä¸ä¸ºç©º
            // å¾ªç¯ä¸å˜é‡ï¼š
            // nums[left-1] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1; // èŒƒå›´ç¼©å°åˆ° [mid+1, right)
            else
                right = mid; // èŒƒå›´ç¼©å°åˆ° [left, mid)
        }
        return left; // æˆ–è€… right
    }

    // å¼€åŒºé—´å†™æ³•
    int lower_bound3(vector<int> &nums, int target) {
        int left = -1, right = nums.size(); // å¼€åŒºé—´ (left, right)
        while (left + 1 < right) { // åŒºé—´ä¸ä¸ºç©º
            // å¾ªç¯ä¸å˜é‡ï¼š
            // nums[left] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid; // èŒƒå›´ç¼©å°åˆ° (mid, right)
            else
                right = mid; // èŒƒå›´ç¼©å°åˆ° (left, mid)
        }
        return right; // æˆ–è€… left+1
    }

public:
    vector<int> searchRange(vector<int> &nums, int target) {
        int start = lower_bound(nums, target); // ä½¿ç”¨å…¶ä¸­ä¸€ç§å†™æ³•å³å¯
        if (start == nums.size() || nums[start] != target)
            return {-1, -1};
        // å¦‚æœ start å­˜åœ¨ï¼Œé‚£ä¹ˆ end å¿…å®šå­˜åœ¨
        int end = lower_bound(nums, target + 1) - 1;
        return {start, end};
    }
};

```

#### 162.å¯»æ‰¾å³°å€¼

![æˆªå±2024-01-01 20.48.21](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-01 20.48.21.png)

å¯¹äºè¿™é“é¢˜ç›®ï¼Œä¸»è¦çš„ç‚¹åœ¨äºè¦æ±‚æ—¶é—´å¤æ‚åº¦å¿…é¡»åœ¨ $O(\log n)$ã€‚è¿™å°±è¦æ±‚æˆ‘ä»¬ä¸èƒ½å¤Ÿè€ƒè™‘æš´åŠ›è§£ç­”çš„æ–¹æ³•ã€‚è€Œå¯¹äºä¸€ä¸ªæ•°ç»„ï¼Œä»ä¸­æŸ¥æ‰¾æ•°å­—æ—¶ï¼Œä¸€èˆ¬ååº”æ˜¯ç”¨åˆ°äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ã€‚ä½†æ˜¯äºŒåˆ†æŸ¥æ‰¾åªé€‚ç”¨äºæœ‰åºæ•°ç»„ä¸­ã€‚è¿™é‡Œå…¶å®æˆ‘ä»¬ä¹Ÿæ˜¯å¯ä»¥ç”¨äºŒåˆ†çš„ï¼Œè·Ÿä¹‹å‰çš„äºŒåˆ†æŸ¥æ‰¾æ–¹æ³•æ˜¯ä¸€æ ·ã€‚

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0, right = nums.size() - 2;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid - 1;
            } 
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 153.å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼

![æˆªå±2024-01-01 22.18.01](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-01 22.18.01.png)

æ‰¾åˆ°å°äºå·¦å³çš„å€¼ã€‚

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 2;
        int minNum = nums[nums.size() - 1];
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > minNum) {
                left = mid + 1;
            } 
            if (nums[mid] < minNum) {
                minNum = nums[mid];
                right = mid - 1;
            }
        }
        return minNum;
    }
};
```

#### 33.æœç´¢æ—‹è½¬æ’åºæ•°ç»„

![æˆªå±2024-01-01 22.33.46](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-01 22.33.46.png)

ä¸¤æ¬¡äºŒåˆ†çš„æ–¹æ³•ã€‚

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 2;
        int minNum = nums[nums.size() - 1];
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > minNum) {
                left = mid + 1;
            } 
            if (nums[mid] < minNum) {
                minNum = nums[mid];
                right = mid - 1;
            }
        }
        if (target == minNum) return left;
        if (target > nums[nums.size() - 1]) {
            right = left;
            left = 0;
        }
        if (target <= nums[nums.size() - 1]) {
            right = nums.size() - 1;
        }
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } 
            if (nums[mid] > target) {
                right = mid - 1;
            }
            if (nums[mid] == target) {
                return mid;
            }
        }
        return -1;

    }
};
```

ä¸€æ¬¡äºŒåˆ†æ³•ï¼šæˆ‘ä»¬åˆ†3ç§æƒ…å†µè®¨è®ºï¼Œä»€ä¹ˆæ—¶å€™ï¼Œ`nums[mid]`åœ¨`target`åŠå…¶å³ä¾§ï¼Œé‚£ä¹ˆéƒ½æŸ“æˆè“è‰²ã€‚

1. å¦‚æœ`nums[mid]`æ¯”æœ€åä¸€ä¸ªæ•°å¤§ï¼Œè¯´æ˜`nums[mid]`åœ¨å·¦è¾¹è¿™æ®µï¼Œå¦‚æœæ­¤æ—¶`target`ä¹Ÿå¤§äºæœ€åä¸€ä¸ªæ•°ã€‚é‚£ä¹ˆ`target`è·Ÿ`nums[mid]`åœ¨åŒä¸€æ®µã€‚å¹¶ä¸”å¦‚æœè¿™ä¸ªæ—¶å€™`nums[mid]`å¤§äºç­‰äº`target`ã€‚ï¼ˆè¯´æ˜`nums[mid]`åœ¨`target`åŠå…¶å³ä¾§ï¼‰é‚£ä¹ˆ`mid`åŠå…¶å³ä¾§å°±æŸ“æˆè“è‰²ã€‚
2. å°±æ˜¯`nums[mid]`å°äºç­‰äºæœ€åä¸€ä¸ªæ•°ï¼Œé‚£ä¹ˆåœ¨å³è¾¹è¿™æ®µã€‚å¦‚æœæ­¤æ—¶`target`è¿˜æ˜¯å¤§äºæœ€åä¸€ä¸ªæ•°ï¼Œé‚£ä¹ˆ`target`åœ¨å·¦è¾¹è¿™æ®µï¼Œï¼ˆç›´æ¥å°±è¯´æ˜ï¼‰`mid`åŠå…¶å³ä¾§ä¹ŸæŸ“æˆè“è‰²ã€‚
3. æƒ…å†µäºŒä¸æˆç«‹ï¼Œ`target`åœ¨ç¬¬äºŒæ®µï¼Œ`nums[mid]`å¤§äºç­‰äº`target`ï¼Œé‚£ä¹ˆä¹Ÿæ˜¯è“è‰²ã€‚
4. å…¶ä½™æƒ…å†µéƒ½æ˜¯çº¢è‰²ã€‚

```c++
class Solution {
public:
    bool is_blue(vector<int>& nums, int i, int target) {
        int end = nums[nums.size() - 1];
        if (nums[i] > end) {
            return target > end && nums[i] >= target;
        } else {
            return target > end || nums[i] >= target;
        }
    }

    int search(vector<int>& nums, int target) {
        int left = -1, right = nums.size();
        while (left + 1 < right) {
            int mid = (right + left) / 2;
            if (is_blue(nums, mid, target)) {
                right = mid;
            } else {
                left = mid;
            }
        }

        if (right == nums.size() || nums[right] != target) return -1;
        return right;

    }
};
```













### 5.å•è°ƒæ ˆ

å•è°ƒæ ˆåˆ†ä¸ºå•è°ƒé€’å¢æ ˆå’Œå•è°ƒé€’å‡æ ˆã€‚å¯¹äºä¸€ç»„æ•°ï¼Œä»å·¦åˆ°å³ä¾æ¬¡å…¥æ ˆï¼Œå¦‚æœæ ˆä¸ºç©ºæˆ–å…¥æ ˆå…ƒç´ å°äºæ ˆé¡¶å…ƒç´ ï¼Œåˆ™å…¥æ ˆï¼Œå¦åˆ™ï¼Œå¦‚æœå…¥æ ˆåˆ™ä¼šç ´åæ ˆçš„å•è°ƒæ€§ï¼Œåˆ™éœ€è¦æŠŠæ¯”å…¥æ ˆå…ƒç´ å°çš„å…ƒç´ å…¨éƒ¨å‡ºæ ˆã€‚è¿™æ˜¯å•è°ƒé€’å¢æ ˆï¼Œå•è°ƒé€’å‡æ ˆç›¸åã€‚

```c++
stack<int> st;
//æ­¤å¤„ä¸€èˆ¬éœ€è¦ç»™æ•°ç»„æœ€åæ·»åŠ ç»“æŸæ ‡å¿—ç¬¦ï¼Œå…·ä½“ä¸‹é¢ä¾‹é¢˜ä¼šæœ‰è¯¦ç»†è®²è§£
for (éå†è¿™ä¸ªæ•°ç»„)
{
	if (æ ˆç©º || æ ˆé¡¶å…ƒç´ å¤§äºç­‰äºå½“å‰æ¯”è¾ƒå…ƒç´ )
	{
		å…¥æ ˆ;
	}
	else
	{
		while (æ ˆä¸ä¸ºç©º && æ ˆé¡¶å…ƒç´ å°äºå½“å‰å…ƒç´ )
		{
			æ ˆé¡¶å…ƒç´ å‡ºæ ˆ;
			æ›´æ–°ç»“æœ;
		}
		å½“å‰æ•°æ®å…¥æ ˆ;
	}
}

```

#### 1944.é˜Ÿåˆ—ä¸­å¯ä»¥çœ‹åˆ°çš„äººæ•°

![æˆªå±2024-01-05 14.21.34](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-05 14.21.34.png)

å€’è¿‡æ¥çœ‹é—®é¢˜ï¼Œè¿™ä¸ªé—®é¢˜ä»å·¦å‘å³çœ‹é—®é¢˜ä¼šå¾ˆå¤æ‚ï¼Œä½†æ˜¯ä»å³å‘å·¦çœ‹å°±å¾ˆå¥½ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å‡çš„å•è°ƒæ ˆã€‚

```c++
class Solution {
public:
    vector<int> canSeePersonsCount(vector<int>& heights) {
        int heightsLen = heights.size();
        stack<int> s;
        vector<int> res(heightsLen, 0);
        if (heightsLen == 1) return res;

        for (int i = heightsLen - 1; i >= 0; i--) {
            while (!s.empty() && s.top() < heights[i]) {
                res[i]++;
                s.pop();
            }
            if (!s.empty()) {
                res[i] ++;
            }
            s.push(heights[i]);
        }
        return res;
    }
};
```





#### 2866.ç¾ä¸½å¡”

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-21 13.13.15.png" alt="æˆªå±2023-12-21 13.13.15" style="zoom:50%;" />



æ ¹æ®é¢˜æ„å¯ä»¥çŸ¥é“ï¼Œå‡è®¾æ•°ç»„é•¿åº¦ä¸º $n$ ï¼Œå¯¹äº  **å±±çŠ¶æ•°ç»„**  $heights$ å®šä¹‰å¦‚ä¸‹ï¼š

- å‡è®¾ $heights[i]$ ä¸ºæ•°ç»„ä¸­çš„æœ€å¤§å€¼ï¼Œåˆ™ $i$ å·¦è¾¹çš„å€¼å‡å°äºç­‰äº $heigjts[i]$ ï¼Œ$i$ å³è¾¹çš„å€¼å‡å°äºç­‰äº $heights[i]$ ã€‚
- $i$ çš„å·¦ä¾§ï¼Œä» $0$ å¼€å§‹åˆ° $i$ ä¸º **éé€’å‡** å…³ç³»ï¼Œå³ $j\in [1,i]$ æ—¶ï¼Œå‡æ»¡è¶³ $heights[j-1] \leq heights[j]$ 
- $i$ çš„å³ä¾§ï¼Œä» $i$ å¼€å§‹åˆ° $n-1$ ä¸º **éé€’å¢** å…³ç³»ï¼Œå³ $j\in[i,n-2]$ æ—¶ï¼Œå‡æ»¡è¶³ $heights[j+1] \leq heights[j]$

é¢˜ç›®ç»™å‡ºäº† **å±±çŠ¶æ•°ç»„** ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸Šé™ï¼Œå³ $heights[i]\leq maxHeights[i]$ï¼Œé¢˜ç›®è¦æ±‚è¿”å›å±±çŠ¶æ•°ç»„æ‰€æœ‰å…ƒç´ ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚

- å¯¹äº $j\in[0, i - 1]$ æ—¶ï¼Œæ­¤æ—¶ $\max(heights[j])=\min(heights[j+1], maxHeights[j])$ 
- å¯¹äº $j\in [i + 1, n - 1]$ æ—¶ï¼Œæ­¤æ—¶ $\max(heights[j])=\min(heights[j-1],maxHeights[j])$ 
- å‡è®¾æ­¤æ—¶å±±çŠ¶æ•°ç»„çš„å±±é¡¶ä¸º $heights[i]$ ï¼Œæ­¤æ—¶æ•´ä¸ªå±±çŠ¶æ•°ç»„çš„æ‰€æœ‰å…ƒç´ çš„æœ€å¤§å€¼å³å¯ç¡®å®šï¼Œæ­¤æ—¶æ•°ç»„å…ƒç´ å’Œçš„æœ€å¤§å€¼ä¹Ÿå¯ç¡®å®š
- å¯¹äºæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ å°½å¯èƒ½å–æœ€å¤§å€¼ä½¿å¾—æ•´ä¸ªæ•°ç»„å…ƒç´ ä¹‹å’Œæœ€å¤§

æ ¹æ®ä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬ä¾æ¬¡æšä¸¾ä»¥ $maxHeights[i]$ ä¸ºå±±é¡¶çš„å±±çŠ¶æ•°ç»„å…ƒç´ ä¹‹å’Œå³å¯æ±‚å‡ºæœ€å¤§çš„é«˜åº¦å’Œã€‚æœ€ç›´æ¥çš„åŠæ³•æ˜¯ä¸¤å±‚å¾ªç¯ï¼Œä½†æ˜¯æ­¤æ—¶éœ€è¦çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ ï¼Œä¼šè¶…æ—¶ã€‚

æ­¤æ—¶éœ€è¦ä¼˜åŒ–ï¼Œå¯¹äºæ¯ä¸ªç´¢å¼• $i$ å¯ä»¥å°†æ•°ç»„åˆ†ä¸ºä¸¤éƒ¨åˆ†å¤„ç†ï¼Œå³ä¿è¯æ•°ç»„çš„å·¦ä¾§æ„æˆéé€’å‡ï¼Œå³ä¾§æ„æˆéé€’å¢ã€‚ä¸ºäº†ä½¿å¾—æ•°ç»„å…ƒç´ å°½å¯èƒ½å¤§ï¼Œæ­¤æ—¶ $heights[i]$ åº”å–å€¼ä¸º $maxHeigths[i]$ï¼Œè®¾åŒºé—´ $[0,i]$ æ„æˆçš„éé€’å‡æ•°ç»„å…ƒç´ å’Œçš„æœ€å¤§å€¼ä¸º $prefix[i]$ ï¼ŒåŒºé—´ $[i,n-1]$ æ„æˆçš„éé€’å¢æ•°ç»„å…ƒç´ å’Œæœ€å¤§å€¼ä¸º $suffix[i]$ ï¼Œæ­¤æ—¶æ„æˆçš„å±±çŠ¶æ•°ç»„çš„å…ƒç´ ä¹‹å’Œä¸º $prefix[i]+suffix[i]-maxHeights[i]$ ã€‚

å¦‚ä½•ä½¿å¾—æ•°ç»„æˆä¸ºé€’å¢æˆ–é€’å‡ï¼Œæ­¤æ—¶æˆ‘ä»¬æƒ³åˆ° `å•è°ƒæ ˆ` ï¼Œå®ƒå¯ä»¥ä¿è¯æ ˆä¸­æ•°æ®çš„å•è°ƒæ€§ï¼Œåˆ©ç”¨å•è°ƒæ ˆå°†è¿ç»­å­æ•°ç»„å˜ä¸ºéé€’å‡æˆ–éé€’å¢ã€‚

- å¯¹äºå·¦ä¾§çš„éé€’å‡ï¼šå°† $maxHeights$ ä¾æ¬¡å…¥æ ˆï¼Œå¯¹äºç¬¬ $i$ ä¸ªå…ƒç´ æ¥è¯´ï¼Œä¸æ–­ä»æ ˆé¡¶å¼¹å‡ºå…ƒç´ ï¼Œç›´åˆ°æ ˆé¡¶å…ƒç´ å°äºç­‰äº $maxHeights[i]$ ã€‚å‡è®¾æ­¤æ—¶æ ˆé¡¶å…ƒç´ ä¸º $maxHeights[j]$ ï¼Œåˆ™åŒºé—´ $[j+1,i-1]$ ä¸­çš„å…ƒç´ æœ€å¤šåªèƒ½å–åˆ° $maxHeights[i]$ ï¼Œåˆ™ $prefix[i]=prefix[j]+(i-j)\times maxHeights[i]$ 
- å¯¹äºå³ä¾§çš„éé€’å‡ï¼šå°† $maxHeights$ ä¾æ¬¡å…¥æ ˆï¼Œå¯¹äºç¬¬ $i$ ä¸ªå…ƒç´ æ¥è¯´ï¼Œä¸æ–­ä»æ ˆé¡¶å¼¹å‡ºå…ƒç´ ï¼Œç›´åˆ°æ ˆé¡¶å…ƒç´  ç›´åˆ°æ ˆé¡¶å…ƒç´ å°äºç­‰äº $maxHeights[i]$ ã€‚å‡è®¾æ­¤æ—¶æ ˆé¡¶å…ƒç´ ä¸º $maxHeights[j]$ ï¼Œåˆ™åŒºé—´ $[i+1,j-1]$ ä¸­çš„å…ƒç´ æœ€å¤šåªèƒ½å–åˆ° $maxHeights[i]$ ï¼Œåˆ™ $suffix[i]=suffix[j]+(j-i)\times maxHeights[i]$ 

æˆ‘ä»¬æŒ‰ç…§ä¸Šè¿°è§„åˆ™æšä¸¾æ¯ä¸ªä½ç½® $i$ ï¼Œå¹¶è®¡ç®—å‡ºä»¥ $i$ ä¸ºå±±é¡¶çš„æ•°ç»„ä¹‹å’Œï¼Œæ­¤æ—¶å±±çŠ¶æ•°ç»„çš„æœ€å¤§å€¼å³ä¸º $\max(prefix[i]+suffix[i]-maxHeights[i])$ 

```c++
class Solution {
public:
    long long maximumSumOfHeights(vector<int>& maxHeights) {
        int n = maxHeights.size();
        long long res = 0;
        vector<long long> prefix(n), suffix(n);
        stack<int> stack1, stack2;

        for (int i = 0; i < n; i++) {
            while (!stack1.empty() && maxHeights[i] < maxHeights[stack1.top()]) {
                stack1.pop();
            }
            if (stack1.empty()) {
                prefix[i] = (long long) (i + 1) * maxHeights[i];
            } else {
                prefix[i] = prefix[stack1.top()] + (long long) (i - stack1.top()) * maxHeights[i];
            }
            stack1.emplace(i);
        }

        for (int i = n - 1; i >= 0; i--) {
            while (!stack2.empty() && maxHeights[i] < maxHeights[stack2.top()]) {
                stack2.pop();
            }
            if (stack2.empty()) {
                suffix[i] = (long long) (n - i) * maxHeights[i];
            } else {
                suffix[i] = suffix[stack2.top()] + (long long) (stack2.top() - i) * maxHeights[i];
            }
            stack2.emplace(i);
            res = max(res, prefix[i] + suffix[i] - maxHeights[i]);
        }
        return res;
    }
};
```

### æšä¸¾

#### äºŒè¿›åˆ¶æšä¸¾

```c++
#include<stdio.h>
#include<string>
#include<istream>
#include<iostream>
#include<vector>


int main()
{
    // std::vector<int> res;

    // for (int i = 0; i < 4; i++) res.push_back(i);
    for(int i = 0; i < (1 << 4); i++) //ä»0ï½2^n-1ä¸ªçŠ¶æ€
    {
        for(int j = 0; j < 4; j++) //éå†äºŒè¿›åˆ¶çš„æ¯ä¸€ä½
        {
            if(i & (1 << j))//åˆ¤æ–­äºŒè¿›åˆ¶ç¬¬jä½æ˜¯å¦å­˜åœ¨
            {
                printf("%d ",j);//å¦‚æœå­˜åœ¨è¾“å‡ºç¬¬jä¸ªå…ƒç´ 
            }
        }
        printf("\n");
    }
    return 0;

}
/*
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¾“å‡ºçš„å€¼ä¸º
0 => 1000
1 => 0100
0 1 => 1100
2 => 0010
0 2 => 1010
1 2 => 0110
0 1 2 => 1110
3 => 1=0001
0 3 => 1001
1 3 => 0101
0 1 3 => 1101
2 3 => 0011
0 2 3 => 1011
1 2 3 => 0111
0 1 2 3 => 1111
*/




```

#### [2397. è¢«åˆ—è¦†ç›–çš„æœ€å¤šè¡Œæ•°](https://leetcode.cn/problems/maximum-rows-covered-by-columns/)

```c++
#include<stdio.h>
#include<string>
#include<istream>
#include<iostream>
#include<vector>
#include<bitset>
#include<map>

using namespace std;

class Solution {
public:
    int maximumRows(vector<vector<int>>& matrix, int numSelect) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> mask(m, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++){
                mask[i] += matrix[i][j] << (n - j - 1); // è®¡ç®—æ¯ä¸€è¡Œçš„åè¿›åˆ¶å€¼ 0, 5, 3, 1
            }
        }

        cout << "mask:" << endl;

        for (int i = 0; i < mask.size(); i++) cout << mask[i] << " ";
        cout << endl;

        int res = 0;
        int cur = 0;
        int limit = (1 << n); // è¿›è¡ŒäºŒè¿›åˆ¶æšä¸¾ï¼Œå…±æœ‰ 2^n ç§æƒ…å†µï¼Œå°±æ˜¯1 å·¦ç§» 3 ä½çš„å€¼
        cout  << "limit: " << limit << endl;
        while ((++cur) < limit) {
            cout << "cur: " << cur << " curçš„äºŒè¿›åˆ¶ï¼š" << bitset<3>(cur) << " __builtin_popcount(cur): " << __builtin_popcount(cur) << endl;
            if (__builtin_popcount(cur) != numSelect) {
                continue;
            }
            int t = 0;
            for (int j = 0; j < m; j++) {
                if ((mask[j] & cur) == mask[j]) { // ä¸è¿ç®—ï¼Œå¦‚æœä¸¤ä½éƒ½ä¸º1ç»“æœæ‰æ˜¯1ï¼Œ
                    ++t;
                }
            }
            res = max(res, t);
        }
        return res;
    }
};



int main()
{
    Solution s;
    vector<vector<int>> matrix{{0, 0, 0}, {1, 0, 1}, {0, 1, 1}, {0, 0, 1}};
    int res = s.maximumRows(matrix, 2);
    std::cout << res << std::endl;
    return 0;

}

```







#### 100169.[ç§»é™¤æ …æ å¾—åˆ°çš„æ­£æ–¹å½¢ç”°åœ°çš„æœ€å¤§é¢ç§¯](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/)

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-24 12.28.03.png" alt="æˆªå±2023-12-24 12.28.03" style="zoom:50%;" />

ç›¸å½“äºç»™é¡¶ä¸€äº›æ¨ªçº¿ç«–çº¿ï¼Œæ‰¾å‡ºè¿™äº›æ¨ªçº¿ç«–çº¿ä¹‹é—´å¯èƒ½æ„é€ å‡ºæ¥çš„æœ€å¤§æ­£æ–¹å½¢ã€‚æ­£æ–¹å½¢ä¸¤æ¡è¾¹è¾¹é•¿ä¸€æ ·ï¼Œå› æ­¤æ‰¾åˆ°çš„æ¨ªçº¿çš„æ¨ªåæ ‡ä¹‹å·®éœ€è¦ç­‰äºæ‰¾åˆ°çš„ç«–çº¿çš„çºµåæ ‡ä¹‹å·®ã€‚ç”±äºæ¨ªçº¿ç«–çº¿æ•°é‡ç›¸å¯¹ä¸å¤šï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æšä¸¾æ‰€æœ‰æƒ…å†µï¼Œçœ‹å…¶ä¸­æ˜¯å¦æœ‰å…¬å…±å…ƒç´ ï¼Œæ‰¾å‡ºæœ€å¤§çš„å…¬å…±å…ƒç´ ç®—å¹³æ–¹å³å¯ã€‚è¿™åªéœ€è¦é€šè¿‡å“ˆå¸Œè¡¨è®°å½•åˆ¤æ–­å³å¯ã€‚

```c++
class Solution {
public:
    const int MOD = 1e9 + 7;
    int maximizeSquareArea(int m, int n, vector<int>& hFences, vector<int>& vFences) {
        hFences.push_back(1);
        hFences.push_back(m);
        vFences.push_back(1);
        vFences.push_back(n);
        sort(hFences.begin(), hFences.end());
        sort(vFences.begin(), vFences.end());
        int hFencesLen = hFences.size(), vFencesLen = vFences.size();
        int res = -1;
        unordered_map<int, int> mp;

        for (int i = 0; i < hFencesLen; i++) {
            for (int j = 0; j < i; j++) {
                mp[abs(hFences[i] - hFences[j])]++;
            }
        }

        for (int i = 0; i < vFencesLen; i++) {
            for (int j = 0; j < i; j++) {
                if (mp[abs(vFences[i] - vFences[j])]) {
                    int a = abs(vFences[i] - vFences[j]);
                    res = max(res, a);
                }
            }
        }

        return res == -1 ? -1 : ((long)res * (long)res) % MOD;
    }
};
```

#### æ‰¾å‡ºå‡ºç°è‡³å°‘ä¸‰æ¬¡çš„æœ€é•¿ç‰¹æ®Šå­å­—ç¬¦ä¸² I

![æˆªå±2023-12-31 12.09.55](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-31 12.09.55.png)

é•¿åº¦ä¸º $x$ çš„ç‰¹æ®Šå­—ç¬¦ä¸²é‡ŒåŒ…å«å‡ ä¸ªé•¿åº¦ä¸º $y$ çš„å­ä¸²ï¼Ÿç­”æ¡ˆæ˜¯ $(x - y + 1)$ ä¸ªã€‚

è®¾åŸä¸²ä¸­ï¼Œæœ€é•¿çš„ç‰¹æ®Šå­ä¸²é•¿åº¦ä¸º $m$ ï¼Œé‚£ä¹ˆé•¿åº¦ä¸º $(m - 2)$ çš„å­ä¸²åœ¨è¯¥ä¸²ä¸­è‡³å°‘å‡ºç° $m - (m - 2) + 1 = 3$ æ¬¡ï¼Œå› æ­¤ç­”æ¡ˆè‡³å°‘æ˜¯ $(m-2)$ï¼Œè‡³å¤šæ˜¯ $m$ ã€‚

å› æ­¤ç›´æ¥ä» $m$ åˆ° $(m - 2)$ æšä¸¾ç­”æ¡ˆï¼Œå¹¶è®¡ç®—è¿™ä¸ªé•¿åº¦çš„ç‰¹æ®Šå­ä¸²æœ‰å‡ ä¸ªå³å¯ã€‚



```c++
class Solution {
public:
    int maximumLength(string s) {
        int sLen = s.size();
        vector<int> vec[26];
        int len = 1;
        char last = s[0];
        for (int i = 1; i < sLen; i++) {
            if (s[i] != last) {
                vec[last - 'a'].push_back(len);
                last = s[i];
                len = 0;
            }
            len++;
        }
        vec[last - 'a'].push_back(len);

        int mx = 0;
        for (int i = 0; i < 26; i++) {
            for (auto v : vec[i]) {
                mx = max(mx, v);
            }
        }

        for (int ans = mx; ans >= mx - 2 && ans ; ans--) {
            for (int i = 0; i < 26; i++) {
                int cnt = 0;
                for (auto v : vec[i]) {
                    if (v >= ans) cnt += (v - ans) + 1;
                    if (cnt >= 3) return ans;
                }
            }
        }

        return -1;
    }
};
```





### å»ºå›¾-floyd

#### [100156. è½¬æ¢å­—ç¬¦ä¸²çš„æœ€å°æˆæœ¬ I](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/)

å»ºå›¾ï¼Œä» $original[i]$ å‘ $changed[i]$ è¿è¾¹ï¼Œè¾¹æƒä¸º $cost[i]$ ã€‚ç„¶åç”¨Floydç®—æ³•æ±‚å›¾ä¸­ä»»æ„ä¸¤ç‚¹æœ€çŸ­è·¯ï¼Œå¾—åˆ° $dis$ çŸ©é˜µï¼Œæœ€åç´¯åŠ æ‰€æœ‰çš„ $dis[original[i]][changed[i]]$ ï¼Œå³ä¸ºç­”æ¡ˆï¼Œå¦‚æœç­”æ¡ˆä¸ºæ— ç©·å•Šï¼Œè¿”å›-1.

```c++
class Solution {
public:
    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {
        int n = original.size();
        vector<vector<int>> g(26, vector<int>(26, 10000001));

        for (int i = 0; i < 26; i++) g[i][i] = 0;

        for (int i = 0; i < n; i++) {
            int o = original[i] - 'a';
            int c = changed[i] - 'a';
            g[o][c] = min(g[o][c], cost[i]);
        }

        // Floyd
        for (int k = 0; k < 26; k++) {
            for (int x = 0; x < 26; x++) {
                for (int y = 0; y < 26; y++) {
                    g[x][y] = min(g[x][y], g[x][k] + g[k][y]);
                }
            }
        }

        int m = source.size();
        long long ans = 0;
        for (int j = 0; j < m; j++) {
            int cur = g[source[j] - 'a'][target[j] - 'a'];
            if (cur >= 10000001) return -1;
            ans += cur;
        }
        return ans;
    }
};
```

#### [2735. æ”¶é›†å·§å…‹åŠ›](https://leetcode.cn/problems/collecting-chocolates/)

**å·§å¦™æšä¸¾**

- æšä¸¾æ“ä½œæ¬¡æ•°ï¼Œä»æ“ä½œ`0`æ¬¡æšä¸¾åˆ°æ“ä½œ`n-1`æ¬¡
- å¦‚æœä¸æ“ä½œï¼Œç¬¬ $i$ ä¸ªå·§å…‹åŠ›å¿…é¡»èŠ±è´¹ $nums[i]$ æ”¶é›†ï¼Œæ€»èŠ±è´¹ä¸ºæ‰€æœ‰ $nums[i]$ ä¹‹å’Œã€‚å¦‚æœåªæ“ä½œä¸€æ¬¡ï¼Œç¬¬ $i$ ä¸ªå·§å…‹åŠ›å¯ä»¥åœ¨æ“ä½œå‰è´­ä¹°ï¼Œå–æœ€å°å€¼ï¼Œå³ $\min(nums[i], num[(i + 1) \mod n])$ .å¦‚æœæ“ä½œä¸¤æ¬¡ï¼Œè´­ä¹°ç¬¬ $i$ ä¸ªå·§å…‹åŠ›çš„èŠ±è´¹ä¸º $\min(nums[i], nums[(i + 1) \mod n], nums[(i + 2) \mod n])$ã€‚ä¾‹å¦‚ç¤ºä¾‹1ï¼Œæˆ‘ä»¬å¯ä»¥æ“ä½œä¸¤æ¬¡ï¼Œè¿™æ ·æ¯å—å·§å…‹åŠ›éƒ½åªéœ€è¦1çš„èŠ±è´¹ï¼Œæ€»æˆæœ¬ä¸º $2x+1+1+1=13$ã€‚
- å¦‚æœæš´åŠ›æšä¸¾æ“ä½œæ¬¡æ•°ï¼Œå†æšä¸¾æ¯ä¸ªå·§å…‹åŠ›ï¼Œå†è®¡ç®—è´­ä¹°è¿™ä¸ªå·§å…‹åŠ›çš„æœ€å°èŠ±è´¹ï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^3)$ã€‚ä¸€ä¸ªåˆæ­¥çš„ä¼˜åŒ–æ˜¯ï¼Œç”¨ $O(n^2)$ çš„æ—¶é—´é¢„å¤„ç†æ‰€æœ‰å­æ•°ç»„çš„æœ€å°å€¼ï¼Œä¿å­˜åˆ°ä¸€ä¸ªäºŒç»´æ•°ç»„ä¸­ã€‚è¿™æ ·åšéœ€è¦ $O(n^2)$ çš„æ—¶é—´å’Œç©ºé—´ã€‚ä½†å…¶å®ä¸éœ€è¦ä¸å¤„ç†ï¼š
  1. ç”¨ä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°ç»„ $s$ ç»Ÿè®¡ä¸åŒæ“ä½œæ¬¡æ•°ä¸‹çš„æ€»æˆæœ¬ã€‚
  2. å†™ä¸€ä¸ªäºŒé‡å¾ªç¯ï¼Œæšä¸¾å­æ•°ç»„çš„å·¦ç«¯ç‚¹ $i$ å’Œå³ç«¯ç‚¹ $j$ã€‚
  3. åœ¨æšä¸¾å³ç«¯ç‚¹çš„åŒæ—¶ï¼Œç»´æŠ¤ä» $nums[i]$ åˆ° $nums[j]$ çš„æœ€å°å€¼ $mn$ ã€‚
  4. æŠŠ $mn$ åŠ åˆ° $s[j - i]$ ä¸­ï¼Œè¿™æ˜¯å› ä¸ºé•¿ä¸º $j - i + 1$ çš„å­æ•°ç»„æ°å¥½å¯¹åº”ç€æ“ä½œ $j-i$ æ¬¡æ—¶è¦è®¡ç®—çš„å­æ•°ç»„ã€‚
  5. æœ€åè¾“å‡º $\min(s)$ ã€‚

```c++
class Solution {
public:
    long long minCost(vector<int>& nums, int x) {
        int n = nums.size();
        vector<long long> s(n);  // s[k] ç»Ÿè®¡æ“ä½œ k æ¬¡çš„æ€»æˆæœ¬
        for (int i = 0; i < n; i++) {
            s[i] = (long long) i * x;
        }
        for (int i = 0; i < n; i++) {
            int mn = nums[i];
            for (int j = i; j < n + i; j++) { // å­æ•°ç»„å³ç«¯ç‚¹ï¼ˆæŠŠæ•°ç»„è§†ä¸ºç¯å½¢çš„ï¼‰ 
                mn = min(mn, nums[j % n]);  // ç»´æŠ¤ä» nums[i] åˆ° nums[j] çš„æœ€å°å€¼
                s[j - i] += mn;  // ç´¯åŠ æ“ä½œ j - i æ¬¡çš„èŠ±è´¹
            }
        }
        return *min_element(s.begin(), s.end());
    }
};
```

#### é“¾è¡¨

##### 206åè½¬é“¾è¡¨

![æˆªå±2024-01-02 22.42.44](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-02 22.42.44.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
    
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;

    }
};
```

##### 92.åè½¬é“¾è¡¨

![æˆªå±2024-01-02 22.58.03](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-02 22.58.03.png)

ä»ä¸Šé¢˜å¯ä»¥çŸ¥é“ï¼Œåè½¬ç»“æŸåï¼Œä»åŸæ¥çš„é“¾è¡¨ä¸Šçœ‹ï¼š $pre$ æŒ‡å‘åè½¬è¿™ä¸€æ®µçš„æœ«å°¾ï¼Œ$cur$ æŒ‡å‘åè½¬è¿™ä¸€æ®µåç»­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

![æˆªå±2024-01-02 23.26.25](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-02 23.26.25.png)



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* p0 = dummy;

        for (int i = 0; i < left - 1; i++) p0 = p0->next;

        ListNode* pre = nullptr;
        ListNode* cur = p0->next;

        for (int i = 0; i < right - left + 1; i++) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        p0->next->next = cur;
        p0->next = pre;

        return dummy->next;
    }
};
```

##### 25.Kä¸ªä¸€ç»„åè½¬é“¾è¡¨

![æˆªå±2024-01-02 23.50.11](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-02 23.50.11.png)



![æˆªå±2024-01-02 23.46.44](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-02 23.46.44.png)

è·Ÿä¸Šè¾¹çš„é¢˜ç›®ç±»ä¼¼ï¼Œä¸è¿‡è¿™é‡Œä¸»è¦æ˜¯æ³¨æ„ï¼Œ$p0$çš„å˜åŒ–ï¼Œåœ¨ä¸€æ¬¡åè½¬ä¹‹åï¼Œæˆ‘ä»¬æŠŠ $next$ æ”¹ä¸º $p0\to next$ ï¼Œå³1ä½ç½®ï¼Œå…¶å®è¿™ä¹Ÿæ˜¯ç»è¿‡åè½¬åçš„ä¸‹ä¸€ä¸ª $p0$çš„èµ·å§‹ä½ç½®ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int ListNodeLen = 0;
        ListNode* cur = new ListNode(-1);
        cur = head;
        while (cur) {
            cur = cur->next;
            ListNodeLen ++;
        }

        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* p0 = dummy;

        while (ListNodeLen >= k) {
            ListNodeLen -= k;
            ListNode* pre = nullptr;
            cur = p0->next;
            ListNode* next = new ListNode(-1);
            for (int i = 0; i < k; i++) {
                next = cur->next;
                cur->next = pre;
                pre = cur;
                cur = next;
            }
            next = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = next;
        }
        return dummy->next;
    }
};
```

##### 2487.ä»é“¾è¡¨ä¸­ç§»é™¤èŠ‚ç‚¹

![æˆªå±2024-01-03 17.15.59](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 17.15.59.png)

åè¿‡æ¥éå†ï¼Œæ¯æ¬¡ä¿å­˜éå†ä¸­çš„æœ€å¤§å€¼ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNodes(ListNode* head) {
        // å°†é“¾è¡¨åè½¬
        ListNode* pre = nullptr;
        ListNode* cur = head;
    
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        vector<ListNode*> vec;
        int max = 0;

        while (pre) {
            if (pre->val >= max) {
                vec.push_back(pre);
                max = pre->val;
            }
            pre = pre->next;
        }

        ListNode* res = new ListNode(-1);
        res = vec[vec.size() - 1];

        for (int i = vec.size() - 1; i > 0; i--) {
            vec[i]->next = vec[i - 1];
        }
        vec[0]->next = nullptr;
        return res;
    }
};
```

##### 876.é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹

![æˆªå±2024-01-03 22.22.21](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 22.22.21.png)

ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªå«åšæ…¢æŒ‡é’ˆï¼Œä¸€ä¸ªå«åšå¿«æŒ‡é’ˆã€‚æ¯æ¬¡å¾ªç¯ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ•°å­¦å½’çº³æ³•ï¼Œè¯æ˜é•¿åº¦ä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œå¦‚æœå¿«æŒ‡é’ˆåœ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ…¢æŒ‡é’ˆä¸€å®šåœ¨ä¸­é—´ç»“ç‚¹ã€‚å¯¹äºå¶æ•°é•¿åº¦ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚ å¦‚æœå¿«æŒ‡é’ˆæŒ‡å‘ç©ºï¼Œé‚£ä¹ˆæ…¢æŒ‡é’ˆä¸€å®šåœ¨ä¸­é—´ç»“ç‚¹ä¸Šã€‚

![æˆªå±2024-01-03 22.28.44](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 22.28.44.png)

ç»¼åˆè¿™ä¸¤ç§æƒ…å†µï¼Œå½“å¿«æŒ‡é’ˆæŒ‡å‘ç©ºï¼Œæˆ–è€…ä»–çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ç©ºï¼Œè¿™ä¸ªæ—¶å€™å°±é€€å‡ºå¾ªç¯ï¼Œ

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* node1 = head;
        ListNode* node2 = head;
        while (node1 && node1->next) {
            node1 = node1->next;
            node1 = node1->next;
            node2 = node2->next;
        }
        return node2;
    }
};
```

##### 141.ç¯å½¢é“¾è¡¨

![æˆªå±2024-01-03 22.35.14](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 22.35.14.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* node1 = head;
        ListNode* node2 = head;
        while (node1 && node1->next) {
            node1 = node1->next;
            node1 = node1->next;
            node2 = node2->next;
            if (node1 == node2) {
                return true;
            }
        }
        return false;
    }
};
```

##### 142.ç¯å½¢åˆ—è¡¨2

![æˆªå±2024-01-03 22.40.21](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 22.40.21.png)

![æˆªå±2024-01-03 22.40.50](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 22.40.50.png)

 å¿«æŒ‡é’ˆç§»åŠ¨è·ç¦»æ˜¯æ…¢æŒ‡é’ˆçš„ä¸¤å€ï¼Œ
$$
2(a+b)=a+b+k(b+c)\\
2a+2b=a+b+b+c+(k-1)(b+c)\\
a-c=(k-1)(b+c)
$$
![æˆªå±2024-01-03 22.43.28](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 22.43.28.png)

 

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* node1 = head;
        ListNode* node2 = head;
        while (node1 && node1->next) {
            node1 = node1->next;
            node1 = node1->next;
            node2 = node2->next;
            if (node1 == node2) {
                while (node2 != head) {
                    node2 = node2->next;
                    head = head->next;
                }
                return node2;
            }
        }
        return NULL;
    }
};
```

##### é‡æ’é“¾è¡¨

![æˆªå±2024-01-03 22.59.08](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-03 22.59.08.png)

æ‰¾åˆ°ä¸­é—´ç»“ç‚¹ï¼Œç„¶åå°†ä¸­é—´ç»“ç‚¹ä¹‹åçš„ç»“ç‚¹å…¨éƒ¨åè½¬ï¼Œä¹‹åå†è¿›è¡Œä¸¤ä¸ªé“¾è¡¨çš„äº¤é”™æ’åˆ—å³å¯ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }

        // å°†é“¾è¡¨åè½¬
        ListNode* pre = nullptr;
        ListNode* cur = slow;
    
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        // head2 ä¸ºå½“å‰åè½¬é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
        ListNode* head1 = head;
        ListNode* head2 = pre;

        while (head2 != slow && head2->next) {
            ListNode* next1 = head1->next;
            ListNode* next2 = head2->next;
            head1->next = head2;
            head2->next = next1;
            head1 = next1;
            head2 = next2;
        }

    }
};
```

##### 2807.åœ¨é“¾è¡¨ä¸­æ’å…¥æœ€å¤§å…¬çº¦æ•°

![æˆªå±2024-01-06 20.21.08](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-06 20.21.08.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    int gcd(int m, int n) {
        while (n != 0) {
            int temp = m % n;
            m = n;
            n = temp;
        }
        return m;
    }
    ListNode* insertGreatestCommonDivisors(ListNode* head) {
        ListNode* pre = new ListNode(-1);
        ListNode* next = new ListNode(-1);

        pre = head;
        while (pre && pre->next) {
            next = pre->next;
            int tmp = gcd(pre->val, next->val);
            ListNode* cur = new ListNode(-1);
            cur->val = tmp;
            cur->next = pre->next;
            pre->next = cur;
            pre = cur->next;
        }
        return head;
    }
};
```

##### 237.åˆ é™¤é“¾è¡¨é‡å¤èŠ‚ç‚¹

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;

    }
};
```

##### 19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹

é¦–å…ˆï¼Œåœ¨ä¹‹å‰çš„åè½¬é“¾è¡¨çš„é¢˜ç›®ï¼Œæœ‰äº›é¢˜ç›®ç”¨åˆ°äº†å“¨å…µèŠ‚ç‚¹è¿™ä¸ªæŠ€å·§ï¼Œé‚£ä¹ˆä»€ä¹ˆæ—¶å€™éœ€è¦å“¨å…µèŠ‚ç‚¹ï¼Œä»€ä¹ˆæ—¶å€™ä¸éœ€è¦å“¨å…µèŠ‚ç‚¹ï¼Ÿå¯¹äºåˆ é™¤èŠ‚ç‚¹æ¥è¯´ï¼Œä¸€èˆ¬æ¥è¯´éœ€è¦åˆ é™¤å¤´èŠ‚ç‚¹çš„è¯ï¼Œéœ€è¦å“¨å…µèŠ‚ç‚¹ã€‚

å¯¹äºè¿™ä¸ªé¢˜ç›®æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆè®©ä¸€ä¸ªæŒ‡é’ˆèµ°å®Œæ•´ä¸ªé“¾è¡¨ï¼Œæ±‚å‡ºé“¾è¡¨é•¿åº¦ï¼Œå†ç»“åˆnæ±‚å‡ºå€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹åœ¨é“¾è¡¨å“ªä¸ªä½ç½®ã€‚

æˆ‘ä»¬ä¹Ÿå¯ä»¥åˆå§‹åŒ–å·¦å³æŒ‡é’ˆï¼Œå½“å³æŒ‡é’ˆèµ°åˆ°ç¬¬nä¸ªä½ç½®çš„æ—¶å€™ï¼Œæˆ‘ä»¬è®©å·¦æŒ‡é’ˆå¼€å§‹ç§»åŠ¨ï¼Œè¿™æ ·å·¦å³æŒ‡é’ˆä¸­é—´ç›¸å·®nä¸ªä½ç½®ã€‚å½“å³æŒ‡é’ˆèµ°åˆ°åº•çš„æ—¶å€™ï¼Œå·¦æŒ‡é’ˆå°±æ˜¯ç­”æ¡ˆã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1);
        ListNode* left = new ListNode(-1);
        ListNode* right = new ListNode(-1);
        dummy->next = head;
        left = dummy;
        right = dummy;
        int cnt = 0;
        
        while (right && right->next) {
            if (cnt >= n) {
                left = left->next;
            }
            right = right->next;
            cnt++;
        }

        left->next = left->next->next;

        return dummy->next;
    }
};
```

##### 83.åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ 

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        ListNode* next = new ListNode(-1);
        dummy = head;
        if (!head || !head->next ) return dummy;
        next = head->next;

        while (head->next) {
            if (head->val == head->next->val) {
                head->next = head->next->next;  
            } else {
                head = head->next;
            }
            
        }
        return dummy;
    }
};
```

##### 82.åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ 2

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* cur = dummy;

        while (cur->next && cur->next->next) {
            int val = cur->next->val;
            if (cur->next->next->val == val) {
                while (cur->next && cur->next->val == val) {
                    cur->next = cur->next->next;
                }
            } else {
                cur = cur->next;
            }
        }

        return dummy->next;
    }
};
```



### äºŒå‰æ ‘ä¸é€’å½’

å¦‚ä½•è®¡ç®—äºŒå‰æ ‘çš„æ·±åº¦ï¼Œä¸è¦ä¸€å¼€å§‹å°±é™·å…¥ç»†èŠ‚ï¼Œè€Œæ˜¯æ€è€ƒæ•´æ£µæ ‘ä¸å…¶å·¦å³å­æ ‘çš„å…³ç³»ã€‚æ•´æ£µæ ‘çš„æ·±åº¦=maxï¼ˆå·¦å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œå³å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼‰+1.ã€‚è¿™æ ·æ€è€ƒåï¼Œä½ ä¼šå‘ç°ï¼ŒåŸé—®é¢˜ï¼šè®¡ç®—æ•´æ£µæ ‘çš„æœ€å¤§æ·±åº¦ï¼Œå­é—®é¢˜ï¼šè®¡ç®—å·¦/å³å­æ ‘çš„æœ€å¤§æ·±åº¦ã€‚å­é—®é¢˜ä¸åŸé—®é¢˜æ˜¯ç›¸ä¼¼çš„ã€‚ç±»æ¯”å¾ªç¯ï¼Œæ‰§è¡Œçš„ä»£ç ä¹Ÿåº”è¯¥æ˜¯ç›¸åŒçš„ï¼Œä½†å­é—®é¢˜éœ€è¦æŠŠè®¡ç®—ç»“æœè¿”ç»™ä¸Šä¸€çº§é—®é¢˜ï¼Œè¿™æ›´é€‚åˆç”¨é€’å½’å®ç°ã€‚ç”±äºå­é—®é¢˜çš„è§„æ¨¡æ¯”åŸé—®é¢˜å°ï¼Œä¸æ–­é€’å½’ä¸‹å»ï¼Œæ€»ä¼šæœ‰ä¸ªå°½å¤´ï¼Œå³é€’å½’çš„è¾¹ç•Œæ¡ä»¶ï¼ˆbase caseï¼‰ã€‚ç›´æ¥è¿”å›å®ƒçš„ç­”æ¡ˆï¼ˆå½’ï¼‰ã€‚

#### 104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

![æˆªå±2024-01-19 15.22.07](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-19 15.22.07.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int deep(TreeNode* root) {
        if (!root) return 0;
        int l_d = deep(root->left);
        int l_r = deep(root->right);
        return max(l_d, l_r) + 1;
    }

    int maxDepth(TreeNode* root) {
        return deep(root);
    }
};
```

#### 100.ç›¸åŒçš„æ ‘

![æˆªå±2024-01-19 16.13.09](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-19 16.13.09.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p || !q) {
            return p == q;
        }
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

#### 101.å¯¹ç§°äºŒå‰æ ‘

![æˆªå±2024-01-19 16.18.30](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-19 16.18.30.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p || !q) {
            return p == q;
        }
        return p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left);
    }
    bool isSymmetric(TreeNode* root) {
        return isSameTree(root->left, root->right);
    }
};
```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int deep(TreeNode* root) {
        if (!root) return 0;
        int l = deep(root->left);
        if (l == -1) return -1;
        int r = deep(root->right);
        if (r == -1 || abs(r - l) > 1) return -1;
        return max(l, r) + 1;
    }

    bool isBalanced(TreeNode* root) {
        return deep(root) == -1 ? false : true;
    }
};
```

#### 199.äºŒå‰æ ‘çš„å³è§†å›¾

![æˆªå±2024-01-19 16.39.27](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-19 16.39.27.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    void f(TreeNode* node, int depth) {
        if (!node) return;
        if (depth == ans.size()) {
            ans.push_back(node->val);
        }
        
        f(node->right, depth + 1);
        f(node->left, depth + 1);
    }


    vector<int> rightSideView(TreeNode* root) {
        f(root, 0);
        return ans;
    }
};
```























### å‘¨èµ›

#### 380-2024-1-14

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2024-01-14 18.46.28.png" alt="æˆªå±2024-01-14 18.46.28" style="zoom:50%;" />

```c++
class Solution {
public:
    int maxFrequencyElements(vector<int>& nums) {
        int numsLen = nums.size();
        vector<int> cnt(105, 0);
        int max_nums = -1;
        int res = 0;
        for (int i = 0; i < numsLen; i++) {
            cnt[nums[i]] ++;
            if (cnt[nums[i]] > max_nums) {
                max_nums = cnt[nums[i]];
                res = max_nums;
            }
            else if (cnt[nums[i]] == max_nums) {
                res += max_nums;
            }
        }
        return res;
    }
};
```



![æˆªå±2024-01-14 18.47.10](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2024-01-14 18.47.10.png)

ä¸€å¼€å§‹æƒ³çš„æ˜¯ç›´æ¥æš´åŠ›ï¼Œç»“æœå°±æ˜¯è¶…æ—¶ã€‚WAWAï¼

ä¸¤ç§è§£æ³•ï¼š

1. äºŒåˆ†+æ•°ä½DP
2. äºŒåˆ†+æšä¸¾æ•°ä½

è¦ç”¨åˆ°äºŒåˆ†ï¼Œå°±è¦è€ƒè™‘æ˜¯å¦æœ‰å•è°ƒæ€§ï¼Œå¯¹äºè¿™é“é¢˜ç›®ï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°`num` è¶Šå¤§ å…¶ä»·å€¼å’Œè¶Šå¤§ï¼Œè¿™å°±æ˜¯é¢˜ç›®åŒ…å«çš„å•è°ƒæ€§ã€‚

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2024-01-14 18.58.33.png" alt="æˆªå±2024-01-14 18.58.33" style="zoom:50%;" />

æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªå°äºç­‰äº`k` çš„æœ€å¤§çš„ä¸€ä¸ªåŒ…å«numçš„ansã€‚è¿™æ ·å°±å˜æˆäº†ï¼Œç»™å®š `num` ç»Ÿè®¡ `1~num` çš„ä»·å€¼å’Œï¼Œåˆ¤æ–­ä»·å€¼å’Œæ˜¯å¦ `<=k` ã€‚äºŒåˆ†ç›¸å½“äºå¤šèŠ±è´¹ `log` çš„æ—¶é—´ï¼Œé¢å¤–å¢åŠ ä¸€ä¸ªæ¡ä»¶ã€‚

**æ•°ä½DPæ¨¡ç‰ˆ**

```c++
class Solution {
public:
    long long findMaximumNumber(long long k, int x) {
        auto check = [&](long long num) {
            int m = 64 - __builtin_clzll(num);  //ç¡®å®šä¸€ä¸ªæ•´æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æœ‰å¤šå°‘ä½
            vector<vector<long long>> memo(m, vector<long long>(m + 1, -1));
            function<long long(int, int, bool)>dfs = [&](int i, int cnt1, bool is_limit) -> long long {
                if (i < 0) return cnt1;
                if (!is_limit && memo[i][cnt1] >= 0) return memo[i][cnt1];
                int up = is_limit ? num >> i & 1 : 1;
                long long res = 0;
                for (int d = 0; d <= up; d++) {
                    res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0), is_limit && d == up);
                }
                if (!is_limit) memo[i][cnt1] = res;
                return res;
            };
            return dfs(m - 1, 0, true) <= k;
        };

        // 
        long long left = 0, right = (k + 1) << x;
        while (left + 1 < right) {
            long long mid = left + (right - left) / 2;
            (check(mid) ? left : right) = mid;
        }
        return left;
    }
};
```



### æ‚ä¹±é¢˜ç›®

#### 	2023å¹´5æœˆ

##### å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-12 21.28.37.png" alt="æˆªå±2023-05-12 21.28.37" style="zoom:50%;" />

å¯¹äºäºŒå‰æ ‘é—®é¢˜ï¼Œé¦–å…ˆè¦æƒ³åˆ°å‡ ç§éå†æ–¹æ³•ï¼š

1. å‰åºéå†

2. ä¸­åºéå†

3. ååºéå†

4. æ·±åº¦ä¼˜å…ˆæœç´¢DFS

5. å®½åº¦ä¼˜å…ˆæœç´¢BFS

   è¿™é“é¢˜ç›®è¦æ±‚çš„æ˜¯æŠŠæ¯ä¸€è¡Œéƒ½ä¸²è”èµ·æ¥ï¼Œé‚£ä¹ˆBFSæŒ‰å±‚éå†å°±å¾ˆåˆé€‚ã€‚

   ```c++
   /*
   // Definition for a Node.
   class Node {
   public:
       int val;
       Node* left;
       Node* right;
       Node* next;
   
       Node() : val(0), left(NULL), right(NULL), next(NULL) {}
   
       Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
   
       Node(int _val, Node* _left, Node* _right, Node* _next)
           : val(_val), left(_left), right(_right), next(_next) {}
   };
   */
   // è¿™æ˜¯ä¸€ä¸ªBFSæ¨¡ç‰ˆ
   class Solution {
   public:
       void levelOrder(TreeNode* root)
       {
         if(root == nullptr) return;
         queue<TreeNode*> q;
         q.push(root);																				// æŠŠèŠ‚ç‚¹æ·»åŠ åˆ°é˜Ÿåˆ—å°¾éƒ¨
         while(!q.empty())
         {
           TreeNode* node = q.front();												// å‡ºé˜Ÿåˆ—
           q.pop();
           if (node->left != nullptr)
             	q.push(node->left);
           if (node->right != nullptr)
             	q.push(node->right);
         }
       }
   };
   // å…·ä½“è§£é¢˜ä»£ç 
   class Solution {
   public:
       Node* connect(Node* root) {
           if (root == nullptr) return root;
           queue<Node*> q;
           q.push(root);
           while(!q.empty())
           {
               int len_level = q.size();                   // ä»£è¡¨æ¯ä¸€å±‚èŠ‚ç‚¹çš„æ•°é‡
               Node* pre = nullptr;                        // å‰ä¸€ä¸ªèŠ‚ç‚¹
               for (int i = 0; i != len_level; i++)
               {
                   Node* node = q.front();
                   q.pop();
                   if (pre != nullptr)
                       pre->next = node;
                   pre = node;
                   if (node->left)
                       q.push(node->left);
                   if (node->right)
                       q.push(node->right);
               }
           }
           return root;
       }
   };
   
   ```

##### äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-13 21.48.17.png" alt="æˆªå±2023-05-13 21.48.17" style="zoom:50%;" />

å¯ä»¥å§æ•´ä¸ªæ ‘éƒ½éå†ä¸€éï¼Œç„¶åå§ç»“æœå­˜å‚¨åˆ°vectorä¸­ï¼Œåœ¨è¿›è¡Œæ’åºæ‰¾åˆ°ç¬¬Kå°çš„å…ƒç´ ã€‚

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        vector<int> vec;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            TreeNode* node = q.front();
            q.pop();
            vec.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        sort(vec.begin(), vec.end());
        return vec[k-1];
    }
};
```

------------------2023å¹´5æœˆ13æ—¥-----------

##### å²›å±¿æ•°é‡

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-13 21.56.03.png" alt="æˆªå±2023-05-13 21.56.03" style="zoom:50%;" />

é¢˜ç›®æ€è·¯ï¼šDFSè§£å†³ï¼Œ

è¿™é¢˜è®©æ±‚çš„æ˜¯å²›å±¿çš„æ•°é‡ï¼ŒäºŒç»´æ•°ç»„ä¸­å€¼æ˜¯1çš„éƒ½æ˜¯å²›å±¿ï¼Œå¦‚æœå¤šä¸ª1æ˜¯è¿ç€çš„ï¼Œé‚£ä¹ˆä»–ä»¬åªèƒ½ç®—ä¸€ä¸ªå²›å±¿ã€‚æœ€ç®€å•çš„ä¸€ç§æ–¹å¼æ˜¯éå†æ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªæ•°å€¼ï¼Œå¦‚æœæ˜¯1å°±è¯´æ˜æ˜¯å²›å±¿ï¼Œç„¶åæŠŠå®ƒç½®ä¸º0æˆ–è€…å…¶ä»–çš„å­—ç¬¦éƒ½å¯ä»¥ï¼Œç„¶åå†éå†ä»–çš„ä¸Šä¸‹å·¦å³4ä¸ªä½ç½®ã€‚å¦‚æœæ˜¯1ï¼Œå°±è¯´æ˜è¿™ä¸¤ä¸ªå²›å±¿æ˜¯è¿ç€çš„ï¼Œåªèƒ½ç®—æ˜¯ä¸€ä¸ªå²›å±¿ã€‚æˆ‘ä»¬è¿˜è¦æŠŠå®ƒç½®ä¸º0ï¼Œç„¶åä»¥å®ƒä¸ºä¸­å¿ƒéå†å®ƒçš„ä¸Šä¸‹å·¦å³4ä¸ªä½ç½®ã€‚å¦‚æœæ˜¯0ï¼Œå°±è¯´æ˜ä¸æ˜¯å²›å±¿ï¼Œå°±ä¸åœ¨å¾€å®ƒçš„ä¸Šä¸‹å·¦å³4ä¸ªä½ç½®éå†äº†ã€‚

```c++
class Solution {
public:
    // æŠŠå½“å‰æ ¼å­ä»¥åŠä»–é‚»è¿‘ä¸º1çš„æ ¼å­éƒ½ç½®ä¸º1
    void dfs(vector<vector<char>>& grid, int i, int j)
    {
        if (i < 0|| i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')
            return;
        // æŠŠå½“å‰æ ¼å­ç½®ä¸º0ï¼Œç„¶åéå†ä»–çš„ä¸Šä¸‹å·¦å³4ä¸ªæ–¹å‘
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }
    int numIslands(vector<vector<char>>& grid) {
        if (grid.size() == 0) return 0;
        int lands_cnt = 0;
        for (int i = 0; i != grid.size(); i++)
        {
            for (int j = 0; j != grid[0].size(); j++)
            {
                if (grid[i][j] == '1')
                {
                    lands_cnt ++;
                    dfs(grid, i, j);
                }
            }
        }
        return lands_cnt;
    }
};
```

ä½†æ˜¯æ˜¾ç„¶ï¼Œè¿™ç§æ–¹æ³•æ•ˆç‡å¾ˆå·®ï¼Œå•ä»ä¸¤ä¸ªåµŒå¥—çš„forå¾ªç¯æ¥è¯´ï¼Œè¿™é‡Œå°±å·²ç»æ˜¯
$$
O(n^2)
$$
2023å¹´5æœˆ16æ—¥22:22

------

##### ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-21 21.14.39.png" alt="æˆªå±2023-05-21 21.14.39" style="zoom:50%;" />

å¯ä»¥ä½¿ç”¨BFSæ¥è¿›è¡Œæœç´¢ï¼Œå°†æ•´ä¸ªè¿‡ç¨‹è§†ä¸ºnå‰æ ‘ã€‚

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-22 22.23.41.png" alt="æˆªå±2023-05-22 22.23.41" style="zoom:50%;" />



```c++
#include <curl/curl.h>
#include <string>
#include <iostream>
#include <vector>
#include <queue>






int main() {
    std::string digits = "23";
    std::vector<std::string> res;
    if (digits.size() == 0)
    {
        for (int i = 0; i != res.size(); i++)
            std::cout << res[i] << " ";
        std::cout << std::endl;
    }

    std::vector<std::vector<char>> tab = {{'a', 'b', 'c'}, {'d', 'e', 'f'}, {'g', 'h', 'i'},
                                {'j', 'k', 'l'}, {'m', 'n', 'o'}, {'p', 'q', 'r', 's'},
                                {'t', 'u', 'v'}, {'w', 'x', 'y', 'z'}
                                };
    for (int i = 0; i != tab.size(); i ++)
    {
        for (int j = 0; j != tab[0].size(); j ++)
        {
            std::cout << tab[i][j] <<" ";
        }
        std::cout << std::endl;
    }

    std::queue<std::string> que;
    que.push("");
    while(que.front().size() != digits.size())
    {
        std::string remove = que.front();
        que.pop();
        std::vector<char> chars = tab[digits[remove.size()] - '2'];
        for (int i = 0; i < chars.size(); i++)
        {
            que.push(remove + chars[i]);
        }
    }
    while (!que.empty())
    {
        std::string str = que.front();
        std::cout << str << std::endl;
        res.push_back(str);
        que.pop();
    }




    std::cout << digits << std::endl;
    return 0;
}

```

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-22 23.12.09.png" alt="æˆªå±2023-05-22 23.12.09" style="zoom:50%;" />

##### æœ‰æ•ˆæ‹¬å·ç”Ÿæˆ

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-26 22.46.13.png" alt="æˆªå±2023-05-26 22.46.13" style="zoom:50%;" />

é€šè¿‡è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œç”Ÿæˆçš„ä»»ä½•æ‹¬å·ç»„åˆä¸­éƒ½æœ‰ä¸¤ä¸ªè§„å¾‹ï¼š

1. æ‹¬å·ç»„åˆä¸­å·¦æ‹¬å·çš„æ•°é‡ç­‰äºå³æ‹¬å·çš„æ•°é‡
2. æ‹¬å·ç»„åˆä¸­ä»»ä½•ä½ç½®å·¦æ‹¬å·çš„æ•°é‡éƒ½æ˜¯å¤§äºç­‰äºå³æ‹¬å·çš„æ•°é‡

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-26 22.47.16.png" alt="æˆªå±2023-05-26 22.47.16" style="zoom:50%;" />

```c++
class Solution {
public:
    void dfs(vector<string> &res, int left, int right, string cur_str)
    {
        if (left == 0 && right == 0) // å·¦å³æ‹¬å·éƒ½ä¸å‰©ä½™äº†ï¼Œè¯´æ˜æ‰¾åˆ°äº†æœ‰æ•ˆçš„æ‹¬å·
        {
            res.push_back(cur_str);
            return;
        }
        // å·¦æ‹¬å·åªæœ‰å‰©ä½™çš„æ—¶å€™æ‰å¯ä»¥é€‰ï¼Œå¦‚æœå·¦æ‹¬å·çš„æ•°é‡å·²ç»é€‰å®Œäº†ï¼Œæ˜¯ä¸èƒ½å†é€‰å·¦æ‹¬å·
        // å¦‚æœé€‰å®Œäº†å·¦æ‹¬å·æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥é€‰æ‹©å³æ‹¬å·çš„
        if (left < 0) return;
        // å¦‚æœå³æ‹¬å·å‰©ä½™æ•°é‡å°äºå·¦æ‹¬å·çš„å‰©ä½™æ•°é‡ï¼Œè¯´æ˜ä¹‹å‰é€‰æ‹©çš„æ— æ•ˆ
        if (right < left) return;
        dfs(res, left - 1, right, cur_str + '(');
        dfs(res, left, right - 1, cur_str + ')');

    }

    vector<string> generateParenthesis(int n) {
        vector<string> res;
        dfs(res, n, n, "");
        return res;
    }
};
```

##### å…¨æ’åˆ—<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-27 21.40.35.png" alt="æˆªå±2023-05-27 21.40.35" style="zoom:50%;" />

é¦–å…ˆæ ¹æ®æ•°å­¦å®šä¹‰ï¼šå…¨æ’åˆ—çš„æ€»ä¸ªæ•°ä¸º $n!$ä¸ªã€‚æ ¹æ®ä¹‹å‰çš„æ€è·¯ï¼Œå¯ä»¥ä»æœç´¢çš„æ–¹æ³•å…¥æ‰‹ã€‚

<img src="/Users/huangqiuzhao/Downloads/IMG_6219E6E27471-1.jpeg" alt="IMG_6219E6E27471-1" style="zoom:50%;" />

```c++
// å›æº¯æ¨¡ç‰ˆ
voidÂ backtrack(å‚æ•°)Â {
Â Â Â Â ifÂ (ç»ˆæ­¢æ¡ä»¶)Â {
Â Â Â Â Â Â Â Â å­˜æ”¾ç»“æœ;
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â forÂ (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰)Â {
Â Â Â Â Â Â Â Â å¤„ç†èŠ‚ç‚¹;
Â Â Â Â Â Â Â Â backtrack(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨);Â //Â é€’å½’
Â Â Â Â Â Â Â Â å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
Â Â Â Â }
}
class Solution {

private:
    vector<vector<int>> result;
public:

    void backTrack(vector<int> &nums, int first, int len)
    {
        if (first == len)
        {
            result.emplace_back(nums);
            return;
        }
        for (int i = first; i < len; i++)
        {
            swap(nums[i], nums[first]);
            backTrack(nums, first + 1, len);
            swap(nums[i], nums[first]);
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        backTrack(nums, 0, nums.size());
        return result;
    }
};


```

##### å•è¯æœç´¢

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-05-31 21.29.08.png" alt="æˆªå±2023-05-31 21.29.08" style="zoom:50%;" />

é¦–å…ˆååº”å°±æ˜¯ä¹‹å‰é‡åˆ°è¿‡çš„å²›å±¿é—®é¢˜ï¼Œè¿›è¡ŒDFSæœç´¢ï¼Œ

```c++
class Solution {
public:
    bool dfs(vector<vector<char>>& board, string word, int i, int j, int index)
    {
        // è¾¹ç•Œåˆ¤æ–­ï¼Œå¦‚æœè¶Šç•Œç›´æ¥è¿”å›false, indexè¡¨ç¤ºçš„æ˜¯æŸ¥æ‰¾åˆ°å­—ç¬¦ä¸²wordçš„ç¬¬å‡ ä¸ªå­—ç¬¦
        // å¦‚æœè¿™ä¸ªå­—ç¬¦ä¸ç­‰äºboard[i][j], è¯´æ˜è¿™ä¸ªåæ ‡è·¯å¾„æ˜¯èµ°ä¸é€šçš„, ç›´æ¥è¿”å›false
        if (i >= board.size() || i < 0 || j >= board[0].size() || j < 0 || board[i][j] != word[index])
            return false;
        // å¦‚æœwordçš„æ¯ä¸ªå­—ç¬¦éƒ½æŸ¥æ‰¾å®Œäº†ï¼Œç›´æ¥è¿”å›truetrue
        if (index == word.size() - 1)
            return true;
        // æŠŠå½“å‰çš„åæ ‡å€¼ä¿å­˜ä¸‹æ¥ï¼Œä¸ºäº†åœ¨æœ€åå¤åŸ
        char tmp = board[i][j];
        // ç„¶åä¿®æ”¹å½“å‰åæ ‡çš„å€¼
        board[i][j] = '.';
        // èµ°é€’å½’, æ²¿ç€å½“å‰åæ ‡çš„ä¸Šä¸‹å·¦å³4å„æ–¹å‘æŸ¥æ‰¾
        bool res = dfs(board, word, i + 1, j, index + 1) || dfs(board, word, i - 1, j, index + 1) || dfs(board, word, i, j + 1, index + 1) || dfs(board, word, i, j - 1, index + 1);
        // é€’å½’ä¹‹åå†æŠŠå½“å‰çš„åæ ‡å¤åŸ
        board[i][j] = tmp;
        return res;
    } 

    bool exist(vector<vector<char>>& board, string word) {
        for (int i = 0; i < board.size(); i++)
        {
            for (int j = 0; j < board[0].size(); j ++)
            {
                if (dfs(board, word, i, j, 0))
                    return true;
            }
        }
        return false;
    }
};
```

#### 2023å¹´6æœˆ

##### 1ã€é¢œè‰²åˆ†ç±»

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-06-05 21.14.20.png" alt="æˆªå±2023-06-05 21.14.20" style="zoom:50%;" />

æ„Ÿè§‰å¯ä»¥ä½¿ç”¨å†’æ³¡æ’åºå•Šï¼ŒåŸåœ°è¿›è¡Œæ’åºã€‚

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        for(int i = 0; i != nums.size(); i++)
        {
            for (int j = i + 1; j != nums.size(); j++)
            {
                int tmp = nums[i];
                if (nums[i] >= nums[j])
                {
                    nums[i] = nums[j];
                    nums[j] = tmp;
                }
            }
        }
    }
};
```

å˜¿å˜¿ï¼Œæœç„¶ä¸€ä¸ªå†’æ³¡æ’åºå°±å¯ä»¥è§£å†³ã€‚ä½†æ˜¯æ•ˆç‡å¤ªå·®äº†ã€‚è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªä¸‰æŒ‡é’ˆçš„åšæ³•ï¼Œ

```c++
class Solution {
public:
    void swap(vector<int>& nums, int right, int left)
    {
        int tmp = nums[right];
        nums[right] = nums[left];
        nums[left] = tmp;
    }
    void sortColors(vector<int>& nums) {
        // 0çš„å³è¾¹ç•Œ
        int right = 0;
        // 2çš„å·¦è¾¹ç•Œ
        int left = nums.size() - 1;
        // æŒ‡å‘å½“å‰æ•°å­—
        int index = 0;
        while(index <= left)
        {
            if (nums[index] == 0)
            {
                swap(nums, right++, index++);
            }
            else if (nums[index] == 2)
            {
                swap(nums, left--, index);
            }
            else if (nums[index] == 1)
            {
                index ++;
            }
        }
    }
};
```

------

2023å¹´6æœˆ5æ—¥21:28

#### 2023-7-10ï¼ˆWEEK1ï¼‰

ğŸ˜®â€ğŸ’¨æœ€è¿‘è¿™ä¸€ä¸ªæœˆå¤ªå •è½äº†ï¼Œä¸€ä¸ªæœˆéƒ½æ²¡æœ‰åšåŠ›æ‰£é¢˜ç›®QAQï¼è¦å¥½å¥½è¡¥ä¸€ä¸‹ã€‚

  **è®¤è¯†å¤æ‚åº¦å’Œç®€å•æ’åºç®—æ³•**

è¯„ä»·ä¸€ä¸ªç®—æ³•æµç¨‹çš„å¥½åï¼Œå…ˆçœ‹æ—¶é—´å¤æ‚åº¦çš„æŒ‡æ ‡ï¼Œç„¶åå†åˆ†æä¸åŒæ•°æ®æ ·æœ¬ä¸‹çš„å®é™…è¿è¡Œæ—¶é—´ï¼Œä¹Ÿå°±æ˜¯â€œå¸¸æ•°é¡¹æ—¶é—´â€ã€‚

```c++
/é€‰æ‹©æ’åº

public static void selectionSort(vector<int>& arr)
{
  if (arr == NULL || arr.size() < 2)
    return;
  for (int i = 0; i < arr.size(); i++)
  {
    int minIndex = i;
    for (int j = i + 1; j < arr.size(); j++)
    {
      minIndex = arr[j] < arr[minIndex] ? j : minIndex;
    }
    swap(arr, i, minIndex);
  }
}

public static void swap(vector<int>& arr, int i, int j)
{
  int tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}

```

```c++
// å†’æ³¡æ’åº
void  swap(std::vector<int> & arr; int i; int j)
{
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[i] ^ arr[j];
arr[i] = arr[i] ^ arr[j];
}


void bubbleSort(std::vector<int> & arr)
{
    if (arr.size() < 2)
        return;
    for (int e = arr.size() - 1; e > 0; e --)
    {
        for (int i = 0; i < e; i++)
        {
            if (arr[i] > arr[i + 1])
                swap(arr, i, i + 1);
        }
    }
}
```

#### 2023-10-8

å‘¨èµ›é”™é¢˜è®°å½•ï¼š

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-10-08 12.09.20.png" alt="æˆªå±2023-10-08 12.09.20" style="zoom:50%;" />

è€ƒè™‘ä¸¤ä¸ªæ•° $a$å’Œ $b$çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œè®¨è®ºäºŒè¿›åˆ¶ç¬¬ $i$ä½åœ¨ $a$å’Œ $b$ä¸­æ˜¯å¦ä¸º1çš„æƒ…å†µï¼š

- è‹¥aå’Œbçš„ç¬¬iä½éƒ½æ˜¯0ï¼Œé‚£ä¹ˆ`a AND b` å’Œ`a OR b`çš„ç¬¬iä½ä¹Ÿéƒ½æ˜¯0.
- è‹¥aå’Œbçš„ç¬¬iä½æ°æœ‰ä¸€ä¸ª1ï¼Œé‚£ä¹ˆ`a AND b` çš„ç¬¬iä½æ˜¯0ï¼Œ`a OR b`çš„ç¬¬iä½æ˜¯1.
- è‹¥ *a* å’Œ *b* çš„ç¬¬ i*i* ä½éƒ½æ˜¯ 1ï¼Œé‚£ä¹ˆ `a AND b` å’Œ `a OR b` çš„ç¬¬ i ä½ä¹Ÿéƒ½æ˜¯ 1ã€‚

ä»¤`f(a)`è¡¨ç¤º`a`çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æœ‰å‡ ä¸ª1ï¼Œä¸éš¾å‘ç°`f(a) + f(b) = f(a AND b) + f(a OR b)`ã€‚åªä¸è¿‡æ‰€æœ‰çš„1é¦–å…ˆéƒ½è¢« `a OR b`æŠ¢äº†ï¼Œå‰©ä¸‹çš„1æ‰ä¼šç•™ç»™ `a AND b`ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªäºŒè¿›åˆ¶ä½ä¸­ï¼Œ1çš„æ€»æ•°ä¸å˜ã€‚åªä¸è¿‡æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»»æ„æ¬¡æ“ä½œï¼ŒæŠŠ1éƒ½é›†ä¸­åœ¨æŸä¸ªæ•°é‡Œã€‚ä¸ºäº†é€‰æ‹©$k$ä¸ªå…ƒç´ ä½¿å¾—å¹³æ–¹å’Œæœ€å¤§ï¼Œæˆ‘ä»¬é¦–å…ˆ è¦è®©$k$ä¸ªå…ƒç´ å°½å¯èƒ½å¤§ã€‚åœ¨ $k$ä¸ªå…ƒç´ çš„æ€»å’Œç›¸åŒçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¿˜è¦è®©æœ€å¤§å€¼å°½å¯èƒ½å¤§ï¼ˆè¯æ˜å¯ä»¥è€ƒè™‘ $y=x^2+(c-x)^2$çš„å‡½æ•°å›¾åƒï¼‰
æˆ‘ä»¬æŠŠ 1 éƒ½é›†ä¸­åœ¨æŸä¸ªæ•°é‡Œï¼Œå®Œç¾ç¬¦åˆè¿™ä¸¤æ¡æ€§è´¨ã€‚

å› æ­¤åšæ³•å°±æ˜¯ç»Ÿè®¡æ¯ä¸ªäºŒè¿›åˆ¶ä½é‡Œæœ‰å¤šå°‘ä¸ª1ï¼Œç„¶åç”¨è¿™äº›1æ‹¼å‡ºå°½å¯èƒ½å¤§çš„æ•°ã€‚

> ### æŒ‰ä½ä¸[è¿ç®—ç¬¦](https://so.csdn.net/so/search?q=è¿ç®—ç¬¦&spm=1001.2101.3001.7020)ï¼ˆ&ï¼‰
>
> å‚åŠ è¿ç®—çš„ä¸¤ä¸ªæ•°æ®ï¼ŒæŒ‰**äºŒè¿›åˆ¶ä½**è¿›è¡Œâ€œä¸â€è¿ç®—ã€‚
> è¿ç®—è§„åˆ™ï¼š0&0=0; 0&1=0; 1&0=0; 1&1=1;
> å³ï¼š**ä¸¤ä½åŒæ—¶ä¸ºâ€œ1â€ï¼Œç»“æœæ‰ä¸ºâ€œ1â€ï¼Œå¦åˆ™ä¸º0**
>
> ### æŒ‰ä½æˆ–è¿ç®—ç¬¦ï¼ˆ|ï¼‰
>
> å‚åŠ è¿ç®—çš„ä¸¤ä¸ªå¯¹è±¡ï¼ŒæŒ‰äºŒè¿›åˆ¶ä½è¿›è¡Œâ€œæˆ–â€è¿ç®—ã€‚
> è¿ç®—è§„åˆ™ï¼š0|0=0ï¼› 0|1=1ï¼› 1|0=1ï¼› 1|1=1ï¼›
> å³ ï¼š**å‚åŠ è¿ç®—çš„ä¸¤ä¸ªå¯¹è±¡åªè¦æœ‰ä¸€ä¸ªä¸º1ï¼Œå…¶å€¼ä¸º1**ã€‚
>
> ### å¼‚æˆ–è¿ç®—ç¬¦ï¼ˆ^ï¼‰
>
> å‚åŠ è¿ç®—çš„ä¸¤ä¸ªæ•°æ®ï¼ŒæŒ‰äºŒè¿›åˆ¶ä½è¿›è¡Œâ€œå¼‚æˆ–â€è¿ç®—ã€‚
> è¿ç®—è§„åˆ™ï¼š0^0=0ï¼› 0^1=1ï¼› 1^0=1ï¼› 1^1=0ï¼›
> å³ï¼š**å‚åŠ è¿ç®—çš„ä¸¤ä¸ªå¯¹è±¡ï¼Œå¦‚æœä¸¤ä¸ªç›¸åº”ä½ä¸ºâ€œå¼‚â€ï¼ˆå€¼ä¸åŒï¼‰ï¼Œåˆ™è¯¥ä½ç»“æœä¸º1ï¼Œå¦åˆ™ä¸º0ã€‚**
>
> ### æŒ‰ä½å–åè¿ç®—ç¬¦ï¼ˆ~ï¼‰
>
> æŒ‰ä½å–åè¿ç®—ç¬¦ï¼ˆ~ï¼‰æ˜¯æŒ‡å°†æ•´æ•°çš„å„ä¸ªäºŒè¿›åˆ¶ä½éƒ½å–åï¼Œå³1å˜ä¸º0ï¼Œ0å˜ä¸º1ã€‚
>
> ### æŒ‰ä½å·¦ç§»è¿ç®—ç¬¦ï¼ˆ<<ï¼‰
>
> å·¦ç§»è¿ç®—ç¬¦æ˜¯ç”¨æ¥å°†ä¸€ä¸ªæ•°çš„å„äºŒè¿›åˆ¶ä½å·¦ç§»è‹¥å¹²ä½ï¼Œç§»åŠ¨çš„ä½æ•°ç”±å³æ“ä½œæ•°æŒ‡å®šï¼ˆå³æ“ä½œæ•°å¿…é¡»æ˜¯éè´Ÿå€¼ï¼‰ï¼Œå…¶å³è¾¹ç©ºå‡ºçš„ä½ç”¨0å¡«è¡¥ï¼Œé«˜ä½å·¦ç§»æº¢å‡ºåˆ™èˆå¼ƒè¯¥é«˜ä½ã€‚
>
> åœ¨é«˜ä½æ²¡æœ‰1çš„æƒ…å†µä¸‹ï¼Œå·¦ç§»1ä½ç›¸å½“äºè¯¥æ•°ä¹˜ä»¥2ï¼Œå·¦ç§»2ä½ç›¸å½“äºè¯¥æ•°ä¹˜ä»¥2*2ï¼4,15ï¼œï¼œ2=60ï¼Œå³ä¹˜äº†ï¼”ã€‚
> ä½†æ­¤ç»“è®ºåªé€‚ç”¨äºè¯¥æ•°å·¦ç§»æ—¶è¢«æº¢å‡ºèˆå¼ƒçš„é«˜ä½ä¸­ä¸åŒ…å«1çš„æƒ…å†µã€‚
>
> ### æŒ‰ä½å³ç§»è¿ç®—ç¬¦ï¼ˆ>>ï¼‰
>
> å³ç§»è¿ç®—ç¬¦æ˜¯ç”¨æ¥å°†ä¸€ä¸ªæ•°çš„å„äºŒè¿›åˆ¶ä½å³ç§»è‹¥å¹²ä½ï¼Œç§»åŠ¨çš„ä½æ•°ç”±å³æ“ä½œæ•°æŒ‡å®šï¼ˆå³æ“ä½œæ•°å¿…é¡»æ˜¯éè´Ÿå€¼ï¼‰ï¼Œç§»åˆ°å³ç«¯çš„ä½ä½è¢«èˆå¼ƒï¼Œå¯¹äºæ— ç¬¦å·æ•°ï¼Œé«˜ä½è¡¥0ã€‚å¯¹äºæœ‰ç¬¦å·æ•°ï¼ŒæŸäº›æœºå™¨å°†å¯¹å·¦è¾¹ç©ºå‡ºçš„éƒ¨åˆ†ç”¨ç¬¦å·ä½å¡«è¡¥ï¼ˆå³â€œç®—æœ¯ç§»ä½â€ï¼‰ï¼Œè€Œå¦ä¸€äº›æœºå™¨åˆ™å¯¹å·¦è¾¹ç©ºå‡ºçš„éƒ¨åˆ†ç”¨0å¡«è¡¥ï¼ˆå³â€œé€»è¾‘ç§»ä½â€ï¼‰ã€‚

```c++
class Solution {
public:
    
    int maxSum(vector<int>& nums, int k) {
        const int MAXP = 30;
        // cnt[i]è¡¨ç¤ºç¬¬iä¸ªäºŒè¿›åˆ¶ä½æœ‰å‡ ä¸ª1
        int cnt[35] = {0};
        for (auto x : nums)
        {
            for (int i = 0; i <= MAXP; i++)
            {
                cnt[i] += x >> i & 1;
                // x å³ç§» i ä½ ç¬¬iä½ä¸1è¿›è¡Œä¸è¿ç®—ã€‚åˆ¤æ–­è¯¥ä½æ˜¯å¦æ˜¯1.
            }
        }
        
        long long ans = 0;
        const int MOD = 1e9 + 7;
        // æ‹¼å‡ºå°½å¯èƒ½å¤§çš„kä¸ªæ•°
        while(k--)
        {
            int now = 0;
            for (int i = MAXP; i >= 0; i--)
            {
                if (cnt[i])
                    // è¡¨ç¤º ç¬¬iä½ä¸º1 æŠŠç¬¬iä½æ‹¼è¿›nowä¸­ã€‚
                {
                    now |= 1 << i;
                    cnt[i]--;
                } 
            }
            ans = (ans + 1LL * now * now) % MOD;
        }
        return ans;
        
        
    }
};
```



<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-10-08 12.41.46.png" alt="æˆªå±2023-10-08 12.41.46" style="zoom:50%;" />

ä»€ä¹ˆæ—¶å€™è¿”å›-1ï¼Ÿ

æ³¨æ„åˆ°ï¼Œåè½¬ä¸¤ä¸ªå­—ç¬¦ï¼š

- å¦‚æœéƒ½æ˜¯0æˆ–è€…1ï¼Œé‚£ä¹ˆåè½¬å1çš„ä¸ªæ•°ä¼šåŠ 2æˆ–è€…å‡2ï¼›
- å¦‚æœä¸€ä¸ªæ˜¯0å¦ä¸€ä¸ªæ˜¯1ï¼Œé‚£ä¹ˆåè½¬å1çš„ä¸ªæ•°ä¸å˜ã€‚
- æ‰€ä»¥ï¼Œæ— è®ºæ˜¯é‚£ç§æ“ä½œï¼Œéƒ½ä¸ä¼šæ”¹å˜å­—ç¬¦ä¸²ä¸­çš„1çš„ä¸ªæ•°çš„å¥‡å¶æ€§ã€‚

æ•…ï¼Œåªè¦ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­çš„1çš„ä¸ªæ•°çš„å¥‡å¶æ€§ä¸åŒï¼Œå°±ç›´æ¥è¿”å›-1.

ç„¶åï¼Œå…ˆè€ƒè™‘DPï¼Œåœ¨è€ƒè™‘è´ªå¿ƒã€‚æ¯•ç«ŸDPå°±æ˜¯å¯¹æš´åŠ›æœç´¢çš„ä¼˜åŒ–ã€‚

è€ƒè™‘ $s_1$å’Œ $s_2$çš„æœ€åä¸€å¯¹å­—ç¬¦ï¼ˆä¹Ÿå¯ä»¥è€ƒè™‘ç¬¬ä¸€å¯¹å­—ç¬¦ï¼‰ï¼š

å¦‚æœç›¸åŒï¼Œé‚£ä¹ˆæ— éœ€ä¿®æ”¹ã€‚

å¦‚æœä¸åŒï¼š

é€‰æ‹©ç¬¬ä¸€ç§æ“ä½œï¼Œç›¸å½“äºåé¢å¯ä»¥å…è´¹åè½¬ä¸€ä¸ªå­—ç¬¦ã€‚

é€‰æ‹©ç¬¬äºŒç§æ“ä½œï¼Œé‚£ä¹ˆä¸‹ä¸ªå­—ç¬¦è¦æŠŠ0çœ‹ä½œ1ï¼ŒæŠŠ1çœ‹ä½œ0.

æ‰€ä»¥é™¤äº†çŸ¥é“å½“å‰ä¸‹æ ‡iï¼Œè¿˜éœ€è¦çŸ¥é“å…è´¹åè½¬æ¬¡æ•°jï¼Œä»¥åŠä¸Šä¸€ä¸ªå­—ç¬¦æ˜¯å¦é€‰æ‹©äº†ç¬¬äºŒç§æ“ä½œpreRew.

å®šä¹‰$dfsï¼ˆi,j,preRew)$ï¼Œå‚æ•°å«ä¹‰å¦‚ä¸‹ï¼Œè¿”å›å€¼æ˜¯åœ¨è¿™ç§çŠ¶æ€ä¸‹çš„æœ€å°æ“ä½œä»£ä»·ä¹‹å’Œã€‚

åˆ†ç±»è®¨è®ºï¼š

å¦‚æœ`(s1[i] == s2[i]) == (not pre_rev) `è¡¨ç¤ºs1[i]å’Œs2[i]æ˜¯ç›¸ç­‰çš„ï¼Œæ— éœ€æ“ä½œï¼Œè¿”å› $dfs(i - 1, j, false)$ã€‚

å¦åˆ™ï¼š

é€‰æ‹©ç¬¬ä¸€ç§æ“ä½œï¼š $dfs(i - 1, j + 1, false) + x$ã€‚

é€‰æ‹©ç¬¬äºŒç§æ“ä½œï¼š$dfs(i - 1, j, true) + 1$

å¦‚æœ $j > 0$å…è´¹åè½¬ä¸€æ¬¡ï¼š $dfs(i - 1, j - 1, false)$ã€‚

è¿™ä¸‰ç§æƒ…å†µå–æœ€å°å€¼ã€‚

é€’å½’è¾¹ç•Œï¼Œå½“ $i < 0$æ—¶ï¼š

å¦‚æœ $j > 0$æˆ–è€… $preRew$ä¸ºçœŸï¼Œé‚£ä¹ˆä¸åˆæ³•ï¼Œè¿”å› æ— ç©·å¤§

å¦åˆ™è¿”å›0.

```c++
class Solution {
public:

    int minOperations(string s1, string s2, int x) {
        int n = s1.size();
        // ç®—å‡ºæˆ‘ä»¬è¦å¤„ç†çš„å­—ç¬¦ä¸²
        vector<int> vec;
        for (int i = 0; i < n; i++) vec.push_back(s1[i] == s2[i] ? 0 : 1);

        const int INF = 1e9;
        int f[n + 1][2][2];
        for (int i = 0; i <= n; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) f[i][j][k] = INF;
        // åˆå€¼
        f[0][0][0] = 0;

        // dp
        for (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) {
            int nxt = vec[i] ^ j;
            if (nxt) {
                f[i + 1][1][k] = min(f[i + 1][1][k], f[i][j][k] + 1);
                if (k == 0) f[i + 1][0][1] = min(f[i + 1][0][1], f[i][j][k] + x);
                else f[i + 1][0][0] = min(f[i + 1][0][0], f[i][j][k]);
            } else {
                f[i + 1][0][k] = min(f[i + 1][0][k], f[i][j][k]);
            }
        }

        return f[n][0][0] < INF ? f[n][0][0] : -1;


    }
};
```

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-10-08 20.54.56.png" alt="æˆªå±2023-10-08 20.54.56" style="zoom:50%;" />

```c++
class Solution {
public:
    int minSetSize(vector<int>& arr) {
        map<int,int> mp;
        for (int i = 0; i < arr.size(); i++)
        {
            mp[arr[i]] ++;
        }
        vector<int>res;
        for (auto& x: mp) 
        {
            res.push_back(x.second);
        }
        sort(res.begin(), res.end());
        int cnt = 0, sum = 0;
        for (int i = res.size() - 1; i >= 0; i--)
        {
            sum += res[i];
            cnt ++;
            if (sum >= arr.size() / 2)
            {
                break;
            }
        }
        return cnt;

    }
};
```

#### 907.å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-11-27 20.16.44.png" alt="æˆªå±2023-11-27 20.16.44" style="zoom:50%;" />

ä¸€èˆ¬æ¥è¯´ï¼Œè®¡ç®—æ¯ä¸ªå­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œï¼Œå…ˆæ˜¯æšä¸¾æ¯ä¸ªå­æ•°ç»„ï¼Œåœ¨æ±‚å‡ºæ¯ä¸ªå­æ•°ç»„çš„æœ€å°å€¼ï¼Œæœ€åç´¯åŠ æœ€å°å€¼ã€‚ä½†æ˜¯æšä¸¾æ¯ä¸ªå­æ•°ç»„éœ€è¦ $O(n^2)$çš„æ—¶é—´ï¼Œè€Œé¡ºåºæ‰«æå­æ•°ç»„å¹¶è®¡ç®—å­æ•°ç»„çš„æœ€å°å€¼ï¼Œåˆéœ€è¦ $O(n)$çš„æ—¶é—´ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºæ­£å‘æ€ç»´æ¥è¯´ï¼Œç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^3)$ï¼Œè¿™å¯¹äº $1 <= n < 3 * 10^4$çš„æ•°æ®è§„æ¨¡æ¥è¯´ï¼Œæ˜¯ä¸å¯æ¥å—çš„ï¼Œ

ä¸€ç§ä¼˜åŒ–æ–¹å‘æ˜¯ é€†å‘æ€ç»´ã€‚

æ­£å‘æ€ç»´æ˜¯æšä¸¾æ‰€æœ‰å­æ•°ç»„ï¼Œè®¡ç®—æ¯ä¸ªå­æ•°ç»„çš„æœ€å°å€¼ï¼Œé‚£ä¹ˆé€†å‘æ€ç»´æ˜¯æšä¸¾æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´  $arr[i]$ä½œä¸ºæœ€å°å€¼ï¼Œç„¶åç»Ÿè®¡ä»¥ $arr[i]$ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°ã€‚

é¦–å…ˆï¼Œæšä¸¾æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´  $arr[i]$ä½œä¸ºæœ€å°å€¼ï¼Œè¿™ä¸ªå¾ˆç®€å•ï¼Œåªéœ€è¦ $O(n)$æ—¶é—´ï¼Œæ¥ä¸‹æ¥ï¼Œå¦‚ä½•ç»Ÿè®¡ä»¥ $arr[i]$ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°ï¼Œè¿™æ˜¯è§£å†³é—®é¢˜çš„å…³é”®ã€‚

æšä¸¾å…ƒç´  $arr[i]$ï¼Œè®¡ç®—ä»¥ $arr[i]$ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°ï¼Œæˆ‘ä»¬å¸Œæœ›è¿™ä¸ªå­é—®é¢˜èƒ½å¤Ÿåœ¨ $O(1)$çš„æ—¶é—´å†…è§£å†³ï¼Œæˆ–è€…è‡³å°‘åœ¨ $Oï¼ˆlog nï¼‰$æ—¶é—´å†…è§£å†³ï¼Œå› ä¸ºå¦‚æœæ˜¯ $O(n)$çš„è¯ï¼Œç®—æ³•æ•´ä½“æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œè¿™ä¹Ÿæ˜¯ä¸è¡Œçš„ã€‚

é‚£ä¹ˆï¼Œé—®é¢˜å°±å˜æˆï¼Œå¦‚ä½•åœ¨ $O(1)$æ—¶é—´å†…ç»Ÿè®¡ä»¥ $arr[i]$ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°ï¼Œ`åœ¨çº¿è®¡ç®—` æ˜¾ç„¶ä¸å¯èƒ½ï¼Œå”¯ä¸€å¯è¡Œçš„æ˜¯ï¼Œ`ç¦»çº¿` å¯¹æ•°ç»„è¿›è¡Œé¢„å¤„ç†ï¼Œè€Œæˆ‘ä»¬ç¦»çº¿é¢„å¤„ç†ä¿¡æ¯ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬åœ¨ `O(1)` æ—¶é—´å†…ç»Ÿè®¡ä»¥ `arr[i]` ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°ã€‚

è®¡ç®— `ä»¥ arr[i] ç»“å°¾ä¸” arr[i] ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°`ï¼Œæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ° `arr[i]` å·¦ä¾§ç¬¬ä¸€ä¸ªæ¯” `arr[i]` å¤§çš„æ•°ï¼›è®¡ç®— `ä»¥ arr[i] å¼€å§‹ä¸” arr[i] ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°`ï¼Œæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ° `arr[i]` å³ä¾§ç¬¬ä¸€ä¸ªæ¯” `arr[i]` å¤§çš„æ•°ã€‚ä»è€ŒæŠŠé—®é¢˜è½¬åŒ–ä¸ºæ±‚è§£ä¸¤ä¸ª [496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I](https://leetcode.cn/problems/next-greater-element-i/) çš„å­é—®é¢˜ã€‚è¿™æ—¶å€™ï¼Œä½¿ç”¨ `å•è°ƒæ ˆ` å°±éå¸¸æ˜¾ç„¶äº†ï¼Œå› ä¸ºæ±‚è§£ `ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ é—®é¢˜` æ˜¯ `å•è°ƒæ ˆ` çš„ `æ¨¡æ¿é¢˜` ~

ä¸Šé¢æˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ªå­é—®é¢˜ï¼š1. è®¡ç®— `ä»¥ arr[i] ç»“å°¾ä¸” arr[i] ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°`ï¼›2. è®¡ç®— `ä»¥ arr[i] å¼€å§‹ä¸” arr[i] ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°`ã€‚ç¨åŠ æ€è€ƒåï¼Œæˆ‘ä»¬å°±ä¼šå‘ç°ï¼Œè¿™ä¸¤ä¸ªå­é—®é¢˜çš„å®šä¹‰æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºè¿™æ ·ä¼šå‡ºç° `é‡å¤çš„å­æ•°ç»„`ã€‚å¦‚æœè¯´ä¸€å¼€å§‹çš„ `é€†å‘æ€ç»´` æ˜¯è§£å†³æœ¬é¢˜çš„ `ç¬¬ä¸€ä¸ªéš¾ç‚¹`ï¼Œé‚£ä¹ˆï¼Œ`å¦‚ä½•é‡æ–°å®šä¹‰ä¸Šè¿°ä¸¤ä¸ªå­é—®é¢˜ï¼Œä½¿å¾—ä¸ä¼šç»Ÿè®¡é‡å¤çš„å­æ•°ç»„`ï¼Œåˆ™æ˜¯è§£å†³æœ¬é¢˜çš„ `ç¬¬äºŒä¸ªéš¾ç‚¹`ï¼Œè¿™ä¸ªå®˜è§£å·²ç»è¯´äº†ï¼Œå¤§å®¶çœ‹å®˜è§£çš„æ—¶å€™ï¼Œéœ€è¦ç‰¹åˆ«ç•™æ„è¿™ä¸€ç‚¹ ~

è€ƒè™‘æ‰€æœ‰æ»¡è¶³ä»¥æ•°ç»„`arr`ä¸­çš„æŸä¸ªå…ƒç´  `arr[i]`ä¸ºæœ€å³ä¸”æœ€å°çš„å…ƒç´ çš„å­åºåˆ—ä¸ªæ•° `C[i]`é‚£ä¹ˆé¢˜ç›®è¦æ±‚æ±‚è¿ç»­å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œå³ä¸º $\sum^{(n-1)}_{i = 0} arr_i \times C_i$ï¼Œå…¶ä¸­æ•°ç»„ `arr`çš„é•¿åº¦ä¸º`n`ã€‚æˆ‘ä»¬å¿…é¡»å‡è®¾å½“å‰å…ƒç´ ä¸ºæœ€å³è¾¹ä¸”æœ€å°çš„å…ƒç´ ï¼Œè¿™æ ·æ‰å¯ä»¥æ„é€ å‡ºäº’ä¸ç›¸äº¤çš„å­åºåˆ—ã€‚

ç»è¿‡ä»¥ä¸Šæ€è€ƒï¼Œæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°æ¯ä¸ªå…ƒç´  `arr[i]`ä»¥è¯¥å…ƒç´ ä¸ºæœ€å³ä¸”æœ€å°çš„å­åºåˆ—çš„æ•°ç›® `left[i]`ï¼Œä»¥åŠä»¥è¯¥å…ƒç´ ä¸ºæœ€å·¦ä¸”æœ€å°çš„å­åºåˆ—çš„æ•°ç›® `right[i]`ï¼Œåˆ™ä»¥ `arr[i]`ä¸ºæœ€å°å…ƒç´ çš„å­åºåˆ—çš„æ•°ç›®åˆè®¡ä¸º `left[i]*right[i]`ã€‚ä¸ºäº†é˜²æ­¢é‡å¤è®¡ç®—ï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½® `arr[i]`å·¦è¾¹çš„å…ƒç´ éƒ½å¿…é¡»æ»¡è¶³å°äºç­‰äº`arr[i]`ï¼Œ`arr[i]`å³è¾¹çš„å…ƒç´ å¿…é¡»æ»¡è¶³ä¸¥æ ¼å°äº`arr[i]`ã€‚å½“ç„¶è¿™å°±å˜æˆæ±‚æœ€å°çš„ä¸‹æ ‡ $j<=i$,ä¸”è¿ç»­å­åºåˆ—ä¸­çš„å…ƒç´  `arr[j], arr[j+1], ..., arr[i]`éƒ½æ»¡è¶³å¤§äºç­‰äº `arr[i]`ï¼Œä»¥åŠæœ€å¤§çš„ä¸‹æ ‡ $k>i$æ»¡è¶³è¿ç»­å­åºåˆ— `arr[i+1],...,arr[k]`éƒ½æ»¡è¶³ä¸¥æ ¼å¤§äº `arr[i]`ä¸Šè¿°å³è½¬åŒ–ä¸ºç»å…¸çš„å•è°ƒæ ˆé—®é¢˜ï¼Œå³æ±‚æ•°ç»„ä¸­å½“å‰å…ƒç´  $x$å·¦è¾¹ç¬¬ä¸€ä¸ªå°äº $x$çš„å…ƒç´ ä»¥åŠå³è¾¹ç¬¬ä¸€ä¸ªå°äºç­‰äº $x$çš„å…ƒç´ ã€‚

å…·ä½“åšæ³•ï¼š

- æ±‚å·¦è¾¹ç¬¬ä¸€ä¸ªå°äº`arr[i]`çš„å…ƒç´ ï¼šä»å·¦å‘å³éå†æ•°ç»„ï¼Œå¹¶ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å¢çš„æ ˆï¼Œéå†å½“å‰å…ƒç´ `arr[i]`ï¼Œå¦‚æœé‡åˆ°å½“å‰æ ˆé¡¶çš„å…ƒç´ å¤§äºç­‰äº`arr[i]`åˆ™å°†å…¶å¼¹å‡ºï¼Œç›´åˆ°æ ˆé¡¶å…ƒç´ å°äº`arr[i]`ï¼Œæ ˆé¡¶å…ƒç´ å³ä¸ºå·¦è¾¹ç¬¬ä¸€ä¸ªå°äº`arr[i]`çš„å…ƒç´ `arr[j]`ï¼Œæ­¤æ—¶`left[i]=i-j`.
- æ±‚å³è¾¹ç¬¬ä¸€ä¸ªå¤§äºç­‰äº arr[i] çš„å…ƒç´ ï¼šä»å³å‘å·¦éå†æ•°ç»„ï¼Œç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å¢çš„æ ˆï¼Œéå†å½“å‰å…ƒç´  arr[i]ï¼Œå¦‚æœé‡åˆ°å½“å‰æ ˆé¡¶çš„å…ƒç´ å¤§äº arr[i] åˆ™å°†å…¶å¼¹å‡ºï¼Œç›´åˆ°æ ˆé¡¶çš„å…ƒç´ å°äºç­‰äº arr[i]ï¼Œæ ˆé¡¶çš„å…ƒç´ å³ä¸ºå³è¾¹ç¬¬ä¸€ä¸ªå°äºç­‰äº arr[i] çš„å…ƒç´  arr[k]\ï¼Œæ­¤æ—¶ right[i]=kâˆ’iã€‚
- è¿ç»­å­æ•°ç»„ arr[j],arr[j+1],â‹¯â€‰,arr[k]çš„æœ€å°å…ƒç´ å³ä¸º arr[i]ï¼Œä»¥ arr[i] ä¸ºæœ€å°å…ƒç´ çš„è¿ç»­å­åºåˆ—çš„æ•°é‡ä¸º (iâˆ’j)Ã—(kâˆ’i)(i - j)ã€‚

- 

```c++
class Solution {
public:

    int sumSubarrayMins(vector<int>& arr) {
        int n = arr.size();
        vector<int> monoStack;
        vector<int> left(n), right(n);

        for (int i = 0; i < n; i++)
        {
            while (!monoStack.empty() && arr[i] <= arr[monoStack.back()]) monoStack.pop_back();

            left[i] = i - (monoStack.empty() ? -1 : monoStack.back());
            monoStack.emplace_back(i);
        }
        monoStack.clear();

        for (int i = n - 1; i >= 0; i--)
        {
            while (!monoStack.empty() && arr[i] < arr[monoStack.back()]) monoStack.pop_back();

            right[i] = (monoStack.empty() ? n : monoStack.back()) - i;
            monoStack.emplace_back(i);
        }

        long long ans = 0;
        long long mod = 1e9 + 7;
        for (int i = 0; i < n; i++)
            ans = (ans + (long long)left[i] * right[i] * arr[i]) % mod;
        return ans;
    }
};
```



#### 2336.æ— é™é›†ä¸­çš„æœ€å°æ•°å­—

![æˆªå±2023-11-29 10.54.01](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-11-29 10.54.01.png)

åˆ©ç”¨å“ˆå¸Œçš„æ–¹æ³•ã€‚

```c++
class SmallestInfiniteSet {
public:
    SmallestInfiniteSet() {
        for (int i = 0; i < 1005; i++) hash[i] = 1;
    }
    
    int popSmallest() {
        cnt = 1;
        while (cnt < 1000 && !hash[cnt])
        {
            cnt ++;
        }
        hash[cnt] = 0;
        return cnt;
    }
    
    void addBack(int num) {
        hash[num % 1005] = 1; 
    }

private:
    int hash[1005];
    int cnt = 1;
};

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj = new SmallestInfiniteSet();
 * int param_1 = obj->popSmallest();
 * obj->addBack(num);
 */
```

#### 2310.ä¸ªä½æ•°ä¸ºKçš„æ•´æ•°ä¹‹å’Œ

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-11-29 13.41.51.png" alt="æˆªå±2023-11-29 13.41.51" style="zoom:50%;" />

æšä¸¾+åˆ©ç”¨åŒä½™æ€§è´¨ä¼˜åŒ–è‡³ $O(1)$æ—¶é—´å¤æ‚åº¦

é¦–å…ˆåˆ†æä¸€ä¸‹ç­”æ¡ˆè‡³å°‘ä¹‹å¤šæ˜¯å¤šå°‘ï¼Œç­”æ¡ˆèŒƒå›´æ¯”è¾ƒå°ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•æšä¸¾ç­”æ¡ˆ $n$ã€‚æŠŠä¸ªä½æ•°å•ç‹¬æ‹†å¼€çœ‹ï¼Œæ¯ä¸ªæ•°å¯ä»¥è¡¨ç¤ºä¸º$10$çš„å€æ•°åŠ ä¸Š $k$çš„å½¢å¼ã€‚ç”±äºè¿™ $n$ä¸ªæ•°éƒ½ä»¥ $k$ç»“å°¾ï¼Œé‚£ä¹ˆ $num-nk$å¿…é¡»æ˜¯ $10$ çš„å€æ•°ã€‚ä»å°åˆ°å¤§æšä¸¾ $n$ ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³ $num-nk$ æ˜¯ $ 10$ å€æ•°çš„ $n$ ã€‚ç”±äº $n$ ä¸ä¼šè¶…è¿‡ $num$ ï¼Œæˆ‘ä»¬è‡³å¤šæšä¸¾åˆ° $num$ æ—¶åœæ­¢ã€‚æ³¨æ„ç‰¹åˆ¤ $num=0$ çš„æƒ…å†µï¼Œæ­¤æ—¶è¿”å› $0$ ã€‚

è¿›ä¸€æ­¥ï¼Œç”±äº
$$
n \cdot k \equiv (n \mod 10) \cdot k (\mod 10) 
$$


æšä¸¾åˆ° $n = 11$ æ—¶ï¼Œ $(num - nk)mod 10 $ çš„ç»“æœä¼šå’Œ $n=1$ æ—¶ç›¸åŒï¼Œå¯¹äºæ›´å¤§çš„ $n$ ä¹Ÿä¼šå’Œ $n mod 10$ ç›¸åŒã€‚å› æ­¤ï¼Œè‡³å¤šæšä¸¾åˆ° $n=10$ å°±è¡Œäº†ã€‚

```c++
class Solution {
public:
    int minimumNumbers(int num, int k) {
        if (num == 0) return 0;
        for (int n = 1; n <= 10 && num - k * n >= 0; ++n) if ((num - k * n) % 10 == 0) return n;
        return -1;
    }
};
```

#### 1094.æ‹¼è½¦

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-02 13.41.48.png" alt="æˆªå±2023-12-02 13.41.48" style="zoom:50%;" />

é¦–å…ˆç¬¬ä¸€æƒ³æ³•æ˜¯è®°å½•æ¯ä¸ªç«™ç‚¹çš„äººæ•°ï¼Œç®€å•çš„å“ˆå¸Œç®—æ³•ã€‚

```c++
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        int sumPassengers = 0;
        int sum[1005];

        for (int i = 0; i < 1005; i++) sum[i] = 0;

        for (int i = 0; i < 1005; i++)
        {
            for (int j = 0; j < trips.size(); j++)
            {
                if (i < trips[j][2] && i >= trips[j][1]) sum[i] += trips[j][0];
            }
        }

        for (int i = 0; i < 1005; i++) if (sum[i] > capacity) return false;

        return true;
    }
};
```

åç»­çœ‹åˆ°åˆ«äººçš„æ–¹æ³•ï¼Œè¿˜æœ‰å·®åˆ†çš„æ–¹æ³•ï¼Œ

**å›¾è§£å·®åˆ† å…¥é—¨ ï¼ˆâ€œå‰ç¼€å’Œâ€ åˆ° â€œå·®åˆ†â€ ä¸æ»‘è¿‡åº¦ï¼‰**

**å·®åˆ†**

ä»æœ´ç´ çš„æƒ³æ³•å¼€å§‹ï¼šåˆ›å»ºä¸€ä¸ªæ•°ç»„ `cnt` ï¼Œç”¨äºå­˜å‚¨ä»æŸä¸ªç«™ç‚¹å‡ºå‘æ—¶ï¼Œè½¦ä¸Šçš„ä¹˜å®¢æ•°é‡ã€‚ä¾‹å¦‚ $cnt[x]=c$ å«ä¹‰ä¸ºåœ¨ç«™ç‚¹ $x$ å‡ºå‘æ—¶ï¼ˆåœ¨è¯¥ç«™ç‚¹çš„ä¸‹è½¦å’Œä¸Šè½¦å‡å®Œæˆï¼‰ï¼Œè½¦ä¸Šä¹˜å®¢æ•°ä¸º $c$ ä¸ªã€‚å¯¹äºæ¯ä¸ª $trips[i]=(x,a,b)$ ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ $[a,b)$ èŒƒå›´å†…çš„ $cnt[j]$ è¿›è¡ŒåŠ  $c$ æ“ä½œã€‚å¤„ç†å®Œ `trips` åï¼Œæ£€æŸ¥æ‰€æœ‰ç«™ç‚¹çš„ä¹˜å®¢äººæ•°ï¼Œæ ¹æ®æ˜¯å¦æ»¡è¶³ `capacity` é™åˆ¶è¿”å›ç­”æ¡ˆã€‚å› æ­¤ï¼Œè¿™æ˜¯ä¸€ä¸ªå…³äº `åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢` çš„ç»å…¸é—®é¢˜ï¼Œå¯ä½¿ç”¨å·®åˆ†æ±‚è§£ã€‚

æ‰€è°“**å·®åˆ†** ï¼Œæ˜¯æŒ‡ **åŸæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ ä¸å‰ä¸€å…ƒç´ ä¹‹å·®æ‰€å½¢æˆçš„æ•°ç»„** ï¼Œä¸ä¹‹ç›¸å¯¹åº”çš„æ˜¯â€œå‰ç¼€å’Œâ€ ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œå¯¹åŸæ•°ç»„è¿›è¡Œè¯¸ä½ç´¯åŠ ï¼ˆå‰ç¼€è®¡ç®—æ“ä½œï¼‰ï¼Œæ‰€å¾—åˆ°çš„æ•°ç»„ä¸ºå‰ç¼€å’Œæ•°ç»„ã€‚å·®åˆ†æ•°ç»„ï¼Œåˆ™æ˜¯å¯¹å…¶æ‰§è¡Œå‰ç¼€è®¡ç®—åï¼Œèƒ½å¤Ÿå¾—åˆ°åŸæ•°ç»„çš„é‚£ä¸ªæ•°ç»„ã€‚ 

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-02 14.16.30.png" alt="æˆªå±2023-12-02 14.16.30" style="zoom:50%;" />

å‰ç¼€å’Œæ•°ç»„çš„ä¸»è¦ä½œç”¨ï¼Œæ˜¯åˆ©ç”¨ `å®¹æ–¥åŸç†` å¿«é€Ÿæ±‚è§£æŸæ®µä¹‹å’Œã€‚ä¾‹å¦‚è¦æŸ¥è¯¢åŸæ•°ç»„ `nums` ä¸­ä¸‹æ ‡èŒƒå›´ `[l,r]` çš„å’Œï¼Œå¯é€šè¿‡ `sum[r]-sum[l-1]` å¿«é€Ÿæ±‚è§£ã€‚

å·®åˆ†æ•°ç»„çš„ä¸»è¦ä½œç”¨ï¼Œæ˜¯å¸®åŠ©å¿«é€Ÿä¿®æ”¹æŸæ®µåŒºé—´ã€‚

ç”±äºå·®åˆ†æ•°ç»„æ‰§è¡Œ `å‰ç¼€è®¡ç®—` åå¾—åˆ°çš„æ˜¯åŸæ•°ç»„ï¼Œå› æ­¤åœ¨å·®åˆ†æ•°ç»„ä¸Šä¿®æ”¹æŸä¸ªå€¼ï¼Œä¼šå¯¹åŸæ•°ç»„æŸæ®µåç¼€äº§ç”Ÿç›¸åŒçš„å½±å“ã€‚

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-02 14.20.56.png" alt="æˆªå±2023-12-02 14.20.56" style="zoom:50%;" />

å› æ­¤ï¼Œ**å½“æˆ‘ä»¬æƒ³è¦å¯¹åŸæ•°ç»„çš„ `[l,r]` è¿›è¡Œæ•´ä½“ä¿®æ”¹æ—¶ï¼Œåªéœ€è¦å¯¹å·®åˆ†æ•°ç»„çš„ `l` å’Œ `r+1` ä½ç½®æ‰§è¡Œç›¸åº”æ“ä½œå³å¯ã€‚**

ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æƒ³å¯¹åŸæ•°ç»„ `nums` çš„ `[l,r]` è¿›è¡Œæ•´ä½“â€œåŠ ä¸€â€æ“ä½œï¼Œé‚£ä¹ˆå¯è½¬æ¢ä¸ºå¯¹å·®åˆ†æ•°ç»„ `c[l]` çš„åŠ ä¸€æ“ä½œï¼ˆç­‰ä»·å¯¹åŸæ•°ç»„çš„ `[l,n-1]` è¿›è¡ŒåŠ ä¸€ï¼‰ï¼Œä»¥åŠå¯¹å·®åˆ†æ•°ç»„ `c[r+1]` çš„å‡ä¸€æ“ä½œï¼ˆç­‰ä»·äºå¯¹åŸæ•°ç»„çš„ `[r+1,n-1]` è¿›è¡Œå‡ä¸€ï¼Œ æœ€ç»ˆåªæœ‰ `[l,r]` æœ‰åŠ ä¸€æ•ˆæœï¼‰ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬å®Œæˆäº†å¯¹å·®åˆ†çš„åŸºæœ¬å­¦ä¹ ï¼š**å°†åŸæ•°ç»„çš„åŒºé—´ä¿®æ”¹ç­‰ä»·ä¸ºå·®åˆ†æ•°ç»„çš„ç‰¹å®šä½ç½®ä¿®æ”¹**ã€‚

å›åˆ°æœ¬é¢˜ï¼Œèµ·å§‹å…ˆç”¨ `nums` æ¥ä½œä¸ºå·®åˆ†æ•°ç»„ï¼Œå¯¹äº $trips[i]=(c,a,b)$ ï¼Œæœ‰ $c$ ä¸ªä¹˜å®¢åœ¨ $a$ ç‚¹ä¸Šè½¦ï¼Œåœ¨ $b$ ç‚¹ä¸‹è½¦ï¼Œå› æ­¤å¯¹ `[a,b)` è¿›è¡Œæ•´ä½“åŠ  $c$ æ“ä½œï¼Œå¯¹åº”å·®åˆ†æ•°ç»„æ“ä½œ `nums[a] += c; nums[b] -= c`ã€‚

å¤„ç†å®Œ $trips$ åï¼Œå¯¹å·®åˆ†æ•°ç»„ `nums` è¿›è¡Œå‰ç¼€è®¡ç®— ï¼ˆå¯ç›´æ¥å¤ç”¨ `nums`ï¼Œè¿›è¡ŒåŸåœ°è®¡ç®—ï¼‰ï¼Œä¾¿å¯å¾—åˆ°å„ä¸ªç«™ç‚¹çš„ä¹˜å®¢æ•°é‡ï¼Œä¸ `capacity` æ¯”è¾ƒç­”æ¡ˆã€‚ 

```c++
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        vector<int> nums(1010, 0);

        for (const auto& t :trips)
        {
            int c = t[0], a = t[1], b = t[2];
            nums[a + 1] += c;
            nums[b + 1] -= c;
        }

        for (int i = 1; i <= 1000; i++)
        {
            nums[i] += nums[i - 1];
            if (nums[i] > capacity) return false;
        }

        return true;
    }
};
```



#### 1423.å¯è·å¾—çš„æœ€å¤§ç‚¹æ•°

![æˆªå±2023-12-03 12.32.08](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-03 12.32.08.png)

**æ»‘åŠ¨çª—å£**

ä»ä¸¤è¾¹é€‰å¡ç‰‡ï¼Œé€‰ `k` å¼ ï¼Œå¡ç‰‡æ€»æ•°é‡ä¸º `n` å¼ ï¼Œå³æœ‰ `n-k` å¼ ä¸è¢«é€‰æ‹©ã€‚æ‰€æœ‰å¡ç‰‡æ€»å’Œ `sum` å›ºå®šï¼Œè¦ä½¿é€‰æ‹©çš„ `k` å¼ çš„æ€»å’Œæœ€å¤§ï¼Œåè¿‡æ¥å°±æ˜¯è¦è®©ä¸è¢«é€‰æ‹©çš„ `n-k` å¼ æ€»å’Œæœ€å°ã€‚åŸé—®é¢˜ç­‰ä»·ä¸º ï¼š**ä»`cardPoints` ä¸­æ‰¾é•¿åº¦ä¸º `n-k` çš„è¿ç»­æ®µï¼Œä½¿å…¶æ€»å’Œæœ€å°**ã€‚

å…·ä½“æ¥è¯´ï¼Œç”¨å˜é‡ `sum` ä»£æŒ‡ `cardPoints` æ€»å’Œï¼Œ `cur`ä»£è¡¨é•¿åº¦å›ºå®šä¸º `n-k`çš„å½“å‰çª—å£æ€»å’Œï¼Œ `minv` ä»£è¡¨æ‰€æœ‰é•¿åº¦ä¸º `n-k`  çš„çª—å£æ€»å’Œæœ€å°çš„å€¼ã€‚

èµ·å§‹å…ˆå°†æ»‘åŠ¨çª—å£å‹æ»¡ï¼Œå–å¾—ç¬¬ä¸€ä¸ªæ»‘åŠ¨çª—å£çš„ç›®æ ‡å€¼ `cur` ï¼ˆåŒæ—¶æ›´æ–°ä¸º `minv`ï¼‰ ï¼Œéšåå¾€åç»§ç»­å¤„ç† `cardPoints` ï¼Œæ¯å¾€å‰æ»‘åŠ¨ä¸€ä½ï¼Œéœ€è¦åˆ é™¤ä¸€ä¸ªå’Œæ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶ä¸æ–­æ›´æ–° `minv` ï¼Œæœ€ç»ˆ `sum-minv`å³æ˜¯ç­”æ¡ˆã€‚ 

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {

        int sum = 0, cur = 0;
        for (int i = 0; i < cardPoints.size(); i++) sum += cardPoints[i];
        for (int i = 0; i < cardPoints.size() - k; i++) cur += cardPoints[i];

        int minv = cur;

        for (int i = cardPoints.size() - k; i < cardPoints.size(); i++)
        {
            cur = cur + cardPoints[i] - cardPoints[i - cardPoints.size() + k];
            minv = min(minv, cur); 
        }

        return sum - minv;

    }
};
```

#### 100153.éœ€è¦æ·»åŠ çš„ç¡¬å¸çš„æœ€å°æ•°é‡

![æˆªå±2023-12-03 13.22.21](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-03 13.22.21.png)

**ç”¨å½’çº³æ³•æ€è€ƒ**

ä¸ºäº†æ–¹ä¾¿æè¿°ï¼ŒæŠŠ0ä¹Ÿç®—ä½œå¯ä»¥å¾—åˆ°çš„æ•°ã€‚å‡è®¾ç°åœ¨å¾—åˆ°äº† $[1,s-1]$ å†…çš„æ‰€æœ‰æ•´æ•°ï¼Œå¦‚æœæ­¤æ—¶æ–°å‘ç°äº†ä¸€ä¸ªæ•´æ•° $x$ ,é‚£ä¹ˆæŠŠ $x$ åŠ åˆ°å·²å¾—åˆ°çš„æ•°å­—ä¸­ï¼Œå°±å¾—åˆ°äº† $[x,s + x-1]$ å†…çš„æ‰€æœ‰æ•´æ•°ã€‚

åˆ†ç±»è®¨è®ºï¼š

1. å¦‚æœ $x\leq s$ ï¼Œé‚£ä¹ˆåˆå¹¶è¿™ä¸¤ä¸ªåŒºé—´ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° $[0,s+x-1]$ å†…çš„æ‰€æœ‰æ•´æ•°ã€‚
2. å¦‚æœ $x>s$ ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬æ— æ³•å¾—åˆ° $s$ ï¼Œé‚£ä¹ˆå°±ä¸€å®šè¦æŠŠ $s$ åŠ åˆ°æ•°ç»„ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥å¾—åˆ° $[s,2s-1]$ å†…çš„æ‰€æœ‰æ•´æ•°ï¼Œå†ä¸ $[0,s-1]$ åˆå¹¶ï¼Œå¯ä»¥å¾—åˆ° $[0,2s-1]$ å†…çš„æ‰€æœ‰æ•´æ•°ã€‚

æŠŠ $coins$ æ’åºï¼Œä»å°åˆ°å¤§è€ƒè™‘ $x=coins[i]$ ã€‚æŒ‰ç…§ä¸Šè¿°åˆ†ç±»è®¨è®ºæ¥çœ‹æ˜¯å¦è¦æ·»åŠ æ•°å­—ã€‚

```c++
class Solution {
public:
    int minimumAddedCoins(vector<int>& coins, int target) {
        sort(coins.begin(), coins.end());
        int ans = 0, s = 1, i = 0;
        while (s <= target)
        {
            if (i < coins.size() && coins[i] <= s)
            {
                s += coins[i];
                i ++;
            }
            else
            {
                s *= 2;
                ans ++;
            }
        }
        return ans;
    }
};
```



#### 100145.ç»Ÿè®¡å®Œå…¨å­å­—ç¬¦ä¸²

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-03 13.37.33.png" alt="æˆªå±2023-12-03 13.37.33" style="zoom:50%;" />

**ç›¸é‚»å­—æ¯ç›¸å·®è‡³å¤šä¸º2** è¿™ä¸ªçº¦æŸæŠŠ `word` åˆ’åˆ†æˆäº†å¤šä¸ªå­ä¸² `s` æ¯ä¸ªå­ä¸²åˆ†åˆ«å¤„ç†ã€‚å¯ä»¥ç”¨**åˆ†ç»„å¾ªç¯**æ‰¾åˆ°æ¯ä¸ªå­ä¸² `s`ã€‚

> åˆ†ç»„å¾ªç¯
>
> æŒ‡çš„æ˜¯å°†æ•´ä¸ªæ•°ç»„æˆ–è€…å­—ç¬¦ä¸²åˆ†æˆå¾ˆå¤šç‰‡æ®µï¼Œè¿™äº›ç‰‡æ®µçš„åˆ¤æ–­å¤„ç†é€»è¾‘æ˜¯ä¸€æ ·çš„ã€‚åˆ†ç»„å¾ªç¯éœ€è¦ä½¿ç”¨åŒå‘åŒæŒ‡é’ˆï¼Œä½†æ˜¯ä¸æ»‘åŠ¨çª—å£ä¸åŒçš„æ˜¯ï¼Œæ»‘åŠ¨çª—å£æ˜¯æ”¶é›†å·¦å³åŒºé—´å†…è¿ç»­æ•°ç»„æˆ–è€…å­—ç¬¦ä¸²ï¼Œå½“ä¸æ»¡è¶³æ”¶é›†è¦æ±‚æ—¶ç§»åŠ¨å³æŒ‡é’ˆï¼Œè€Œå½“æ»¡è¶³åç§»åŠ¨å·¦æŒ‡é’ˆï¼Œæ­¤æ—¶å·¦æŒ‡é’ˆç§»åŠ¨åˆ°åŸæ¥å·¦æŒ‡é’ˆçš„ä¸‹ä¸€ä½ï¼Œè€Œåˆ†ç»„å¾ªç¯æ˜¯å·¦æŒ‡é’ˆç§»åŠ¨åˆ°å³æŒ‡é’ˆä¸‹ä¸€ä½ã€‚
>
> ```c++
> // æ¨¡ç‰ˆ l,r åˆ†åˆ«è¡¨ç¤ºå·¦å³æŒ‡é’ˆ
> 
> int l = 0, r = 0;
> while (r < n)
> {
> 	// æ¯ä¸€æ¬¡æ±‚æ–°åŒºé—´åˆ™é‡æ–°èµ‹å€¼l
> 	l = rï¼›
>  // r è¡¨ç¤ºæœ€é•¿è¿ç»­åŒºé—´æœ€åä¸€ä¸ª
>  while (r < n - 1 && s[r] == s[r + 1])
>  {
>    	r ++;
>  }
> 	// æ±‚å®ŒåŒºé—´åæ”¶é›†ç»“æœ
> 	res = max(r - l + 1, res);
> 	// å¹¶ç§»åŠ¨råˆ°ä¸‹ä¸€ä¸ª
> 	r ++;
> }
> ```
>
> 

å¯¹äºæ¯ä¸ªå­ä¸²ï¼Œç”±äºæ¯ä¸ªå­—ç¬¦æ°å¥½å‡ºç° `k` æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾æœ‰ `m` ç§å­—ç¬¦ï¼Œè¿™æ ·é—®é¢˜å°±å˜æˆäº†ï¼š

é•¿åº¦å›ºå®šä¸º  `mÂ·k` çš„æ»‘åŠ¨çª—å£ï¼Œåˆ¤æ–­æ¯ç§å­—ç¬¦æ˜¯å¦éƒ½å‡ºç°äº†æ°å¥½ `k`æ¬¡ã€‚



#### 1038.ä»äºŒå‰æœç´¢æ ‘åˆ°æ›´å¤§å’Œæ ‘

![æˆªå±2023-12-04 20.34.57](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-04 20.34.57.png)

æ‰“å¡é¢˜

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // éå†
    void bst(TreeNode* root)
    {
        if (!root) return;
        bst(root->right);
        cnt += root->val;
        root->val = cnt;
        bst(root->left);
    } 
    TreeNode* bstToGst(TreeNode* root) {
        bst(root);
        return root;
    }
private:
    int cnt = 0;
};
```

#### 1685.æœ‰åºæ•°ç»„ä¸­å·®ç»å¯¹å€¼ä¹‹å’Œ

![æˆªå±2023-12-04 20.37.32](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-04 20.37.32.png)

åˆ©ç”¨å‰ç¼€å’Œè§£å†³ï¼Œé¦–å…ˆè®¡ç®—å‡ºå‰ç¼€å’Œï¼Œç„¶åéå†`nums`ï¼Œä»¥å½“å‰å…ƒç´ `nums[i]` ä¸ºåˆ†ç•Œç‚¹ï¼Œ `i`å‰è¾¹çš„å…ƒç´ ä¸€å®šæ˜¯æ¯” `nums[i]`å°ï¼Œ`i`åè¾¹çš„å…ƒç´ ä¸€å®šæ¯” `nums[i]`å¤§ã€‚è¿™æ—¶ï¼Œæˆ‘ä»¬æŠŠè¿™ä¸ªé—®é¢˜æ”¾åœ¨äºŒç»´ç©ºé—´çœ‹ã€‚

![æˆªå±2023-12-04 20.46.32](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-04 20.46.32.png)

æ¯”å¦‚åœ¨ `i=1`çš„ä½ç½®åœ¨`nums[1]`å·¦è¾¹çš„æ¯” `nums[1]` å°ï¼Œæ­¤æ—¶`sum(|nums[i]-nums[j]|)` ä¸ºå·¦è¾¹çš„æ©™è‰²é¢ç§¯ã€‚å¯ä»¥å†™ä¸º `left=nums[i] * i - f[i]` ã€‚åŒç†ï¼Œå³è¾¹éƒ¨åˆ†ä¸º å³è¾¹æ©™è‰²é¢ç§¯ ï¼Œå¯ä»¥å†™ä¸º `f[n]-f[i] - (n - i) * nums[i]` ã€‚è¿™æ ·ï¼Œå°±å¯ä»¥æŠŠ`result[i]` çš„æ±‚è§£è¿‡ç¨‹ç­‰ä»·ä¸º `nums[i]` å·¦å³ä¸¤è¾¹çš„é¢ç§¯ã€‚

```c++
class Solution {
public:
    vector<int> getSumAbsoluteDifferences(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        long long f[n + 1];
        f[0] = 0;
        for (int i = 0; i < n; i++) f[i + 1] = f[i] + nums[i];

        for (int i = 0; i < n; i++)
        {
            int target = nums[i];
            long long left = target * i - f[i];
            long long right = f[n] - f[i] - (n - i) * target;
            res[i] = left + right;
        }
        return res;
    }
};
```

#### 2477.åˆ°è¾¾é¦–éƒ½çš„æœ€å°‘æ²¹è€—

![æˆªå±2023-12-05 10.27.40](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-05 10.27.40.png)**è´ªå¿ƒ+æ·±åº¦ä¼˜å…ˆæœç´¢ ** 

é¢˜ç›®ç­‰ä»·äºç»™å‡ºäº†ä¸€æ£µä»¥èŠ‚ç‚¹$0$ ä¸ºæ ¹ç»“ç‚¹çš„æ ‘ï¼Œå¹¶ä¸”åˆå§‹æ ‘ä¸Šçš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸Šéƒ½æœ‰ä¸€ä¸ªäººï¼Œç°åœ¨æ‰€æœ‰äººéƒ½éœ€è¦é€šè¿‡ `è½¦å­` å‘èŠ‚ç‚¹ $0$ ç§»åŠ¨ã€‚

å¯¹äºæŸä¸€èŠ‚ç‚¹ $x$ ï¼Œ$x\neq 0$ ï¼Œå…¶çˆ¶èŠ‚ç‚¹ä¸º $y$ ã€‚å› ä¸ºä»¥èŠ‚ç‚¹ $x$ ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘ä¸Šçš„äººéƒ½éœ€è¦é€šè¿‡è¾¹ $x\to y$ å‘èŠ‚ç‚¹ $0$ ç§»åŠ¨ï¼Œæ‰€ä»¥ä¸ºäº†ä½¿è¿™æ¡è¾¹ä¸Šçš„ `è½¦å­` åˆ©ç”¨ç‡æœ€é«˜ï¼Œæˆ‘ä»¬è´ªå¿ƒçš„è®© $x$ çš„å…¨éƒ¨å­èŠ‚ç‚¹ä¸Šçš„äººåˆ°äº†èŠ‚ç‚¹ $x$ åå†ä¸€èµ·åè½¦å‘ä¸Šç§»åŠ¨ï¼Œæˆ‘ä»¬ä¸å¦¨è®¾ä»¥èŠ‚ç‚¹ $x$ ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘å¤§å°ä¸º $cnt_x$ é‚£ä¹ˆæˆ‘ä»¬è‡³å°‘éœ€è¦ `è½¦å­`çš„æ•°é‡ä¸º $\lceil \frac{cnt_x}{seats} \rceil$ ï¼Œå…¶ä¸­ $seatx$ ä¸ºä¸€è¾†è½¦çš„ç»™å®šåº§ä½æ•°ã€‚

é‚£ä¹ˆï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»æ ¹èŠ‚ç‚¹ $0$ å¾€ä¸‹è¿›è¡Œ `æ·±åº¦ä¼˜å…ˆæœç´¢` ï¼Œæ¯ä¸€æ¡è¾¹ä¸Š `è½¦å­ğŸš—`çš„æ•°ç›®å³ä¸ºè¯¥æ¡è¾¹ä¸Šæ±½æ²¹çš„å¼€é”€ï¼Œç»Ÿè®¡å…¨éƒ¨è¾¹ä¸Šæ±½æ²¹çš„å¼€é”€å³ä¸ºæœ€ç»ˆç­”æ¡ˆã€‚

```c++
class Solution {
public:
    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        int n = roads.size();
        vector<vector<int>> g(n + 1);
        for (auto &e : roads)
        {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }

        long long res = 0;
        function<int(int, int)> dfs = [&](int cur, int fa) -> int 
        {
            int peopleSum = 1;
            for (auto ne : g[cur])
            {
                if (ne != fa) // åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€æ£µå­æ ‘
                {
                    int peopleCnt = dfs(ne, cur);
                    peopleSum += peopleCnt;
                    res += (peopleCnt + seats - 1) / seats;
                }
            }
            return peopleSum;
        };
        dfs(0, -1);
        return res;
    }
};
```

ä¹‹å‰å¡ä½çš„åŸå› ä¸»è¦åœ¨ï¼Œä¸çŸ¥é“æ€ä¹ˆç¡®å®šä¸€æ¡æ”¯è·¯èµ°åˆ°å¤´ã€‚è¿™é‡Œäº†å¾ˆæ˜æ˜¾ 

```c++
/*
dfs(0, -1)
dfs(1, 0)
dfs(3, 1)
dfs(2, 3)
dfs(3, 3)
*
*/
```

#### 2257.ç»Ÿè®¡ç½‘æ ¼å›¾ä¸­æ²¡æœ‰è¢«ä¿å«çš„æ ¼å­æ•°

![æˆªå±2023-12-06 09.59.40](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-06 09.59.40.png)

**å¹¿åº¦ä¼˜å…ˆæœç´¢+å­˜å‚¨æ¯ä¸ªæ ¼å­çš„çŠ¶æ€**

ä¸ºäº†æ–¹ä¾¿æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ç”¨äºŒç»´æ•°ç»„ `grid` æ¥è¡¨ç¤ºç½‘æ ¼å›¾çš„çŠ¶æ€ã€‚å…¶ä¸­ï¼Œè­¦å«å¯¹åº”çš„çŠ¶æ€å€¼ä¸º$-1$ ï¼Œå¢™å¯¹åº”çš„çŠ¶æ€å€¼ä¸º $-2$ ï¼Œæœªè¢«ä¿å«çš„æ ¼å­å¯¹åº”çš„çŠ¶æ€å€¼ä¸º $0$ ï¼Œè¢«ä¿å«çš„æ ¼å­å¯¹åº”çš„çŠ¶æ€å€¼ä¸ºæ­£æ•´æ•°ã€‚äºŒç»´æ•°ç»„çš„åˆå§‹å€¼å‡ä¸º $0$ ï¼Œéšåæˆ‘ä»¬éå† `guards` å’Œ `walls` æ•°ç»„å¯¹åº”æ›´æ–°ç½‘æ ¼å›¾ã€‚

åœ¨æ¢å¤äº†ç½‘æ ¼å›¾åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢ç»´æŠ¤æ¯ä¸ªæ ¼å­çš„çŠ¶æ€ã€‚ç”±äºè§†çº¿æ˜¯å‘ç‰¹å®šæ–¹å‘çš„ï¼Œå› æ­¤åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œé™¤äº†è¦ç»´æŠ¤æ ¼å­çš„æ¨ªçºµåæ ‡ï¼Œè¿˜è¦ç»´æŠ¤å½“å‰çš„è§†çº¿æ–¹å‘ã€‚æˆ‘ä»¬ç”¨ $(i,j,k)$ æ¥è¡¨ç¤ºå¹¿åº¦ä¼˜å…ˆæœç´¢çš„çŠ¶æ€ï¼Œå…¶ä¸­ $(i,j)$ ä»£è¡¨å½“å‰ç‚¹çš„æ¨ªçºµåæ ‡ï¼Œ $k$ ä¸º $[0,3]$ é—­åŒºé—´å†…æ•´æ•°ï¼Œåˆ†åˆ«ä»£è¡¨å³ã€ä¸Šã€å·¦ã€ä¸‹çš„è§†çº¿æ–¹å‘ã€‚åŒæ ·çš„ï¼Œä¸ºäº†é˜²æ­¢æ¯ä¸ªéè­¦å«æˆ–è€…å¢™çš„ç‚¹è¢«é‡å¤æˆ–é—æ¼ï¼Œæˆ‘ä»¬ç”¨ $4$ ä¸ªäºŒè¿›åˆ¶ä½ç»„æˆçš„æ­£æ•´æ•°æ¥è¡¨ç¤ºè¯¥æ ¼å­çš„çŠ¶æ€ï¼Œå…¶ä¸­ä»ä½åˆ°é«˜çš„ç¬¬ $k$ ä½ä¸º $1$ ä»£è¡¨æœ‰æŒ‡å‘ç¬¬ $k$ ä¸ªæ–¹å‘çš„è§†çº¿ç»è¿‡è¯¥ç‚¹ï¼Œåä¹‹åˆ™ä»£è¡¨æ²¡æœ‰ã€‚

æˆ‘ä»¬ç”¨é˜Ÿåˆ— $q$ æ¥è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚é¦–å…ˆï¼Œå¯¹äºæ¯ä¸ªè­¦å«ç‚¹ $(i,j)$ ï¼Œç”±äºè­¦å«å¯ä»¥çœ‹åˆ°å››ä¸ªæ–¹å‘ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å°† $k$ ä¸º $[0,3]$ é—­åŒºé—´å†…å¯¹åº”çš„å››ç§çŠ¶æ€ $(i,j,k)$ å…¨éƒ¨åŠ è¿›é˜Ÿåˆ—ã€‚

å½“éå†åˆ° $(x,y,k)$ æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆè®¡ç®—æ²¿ç€è¯¥è§†çº¿æ–¹å‘çš„ä¸‹ä¸€ä¸ªåæ ‡ $(n_x,n_y)$ ï¼Œå¦‚æœè¯¥åæ ‡ä¸åˆæ³•æˆ–ä¸ºå¢™æˆ–è­¦å«ï¼Œåˆ™æˆ‘ä»¬ç›´æ¥è·³è¿‡è¯¥åæ ‡ï¼›å¯¹äºä½™ä¸‹çš„æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥è¯¥åæ ‡å¯¹åº”çŠ¶æ€ $grid[i][j]$ ä¸­ä»ä½åˆ°é«˜çš„ç¬¬ $k$ ä½çš„æ•°å€¼ã€‚æ­¤æ—¶æœ‰ä¸¤ç§æƒ…å†µï¼š

- ç¬¬ $k$ ä½ä¸º$1$ ï¼Œåˆ™è¯´æ˜è¯¥åæ ‡åŠè§†çº¿æ–¹å‘å¯¹åº”çš„çŠ¶æ€ $(n_x,n_y,k)$ å·²è¢«éå†è¿‡ï¼Œæˆ‘ä»¬ç›´æ¥è·³è¿‡å³å¯ï¼›
- ç¬¬ $k$ ä½ä¸º $0$ ï¼Œåˆ™è¯´æ˜è¯¥åæ ‡åŠè§†çº¿æ–¹å‘å¯¹åº”çš„çŠ¶æ€ $n_x,n_y,k$ æœªè¢«éå†è¿‡ï¼Œæˆ‘ä»¬éœ€è¦å°†è¯¥ä½ç½®ä¸º $1$ ï¼Œå¹¶å°†è¯¥çŠ¶æ€åŠ å…¥é˜Ÿåˆ— $q$ çš„å°¾éƒ¨ã€‚

æœ€ç»ˆï¼Œå½“å¹¿åº¦ä¼˜å…ˆæœç´¢å®Œæˆæ—¶ï¼Œä¸€ä¸ªæ ¼å­æœªè¢«ä¿å«å½“ä¸”ä»…å½“ $grid$ ä¸­çš„å¯¹åº”çŠ¶æ€å€¼ä¸º $0$ ã€‚æˆ‘ä»¬åªéœ€è¦éå† $grid$ ï¼Œç»´æŠ¤æ•°å€¼ä¸º $0$ çš„æ ¼å­æ•°é‡ï¼Œå¹¶è¿”å›å³å¯ã€‚

```c++
class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<int>> grid(m, vector<int> (n));  // ç½‘æ ¼çŠ¶æ€æ•°ç»„
        queue<tuple<int, int, int>> q;   // å¹¿åº¦ä¼˜å…ˆæœç´¢é˜Ÿåˆ—
        // æ¯ä¸ªæ–¹å‘çš„å•ä½å‘é‡
        vector<int> dx = {1, 0, -1, 0};
        vector<int> dy = {0, 1, 0, -1};
        for (const auto& guard : guards)
        {
            grid[guard[0]][guard[1]] = -1;
            for (int k = 0; k < 4; k++)
            {
                // å°†å››ä¸ªæ–¹å‘è§†çº¿å¯¹åº”çš„çŠ¶æ€å‡æ·»åŠ è¿›æœç´¢é˜Ÿåˆ—ä¸­
                q.emplace(guard[0], guard[1], k);
                // æ¯”å¦‚ï¼Œ(0, 0) è¿™æ—¶å€™åŠ å…¥çš„å°±æ˜¯ (0, 0, 0), (0, 0, 1), (0, 0 ,2), (0, 0, 3)
            }
        }

        for (const auto& wall : walls) grid[wall[0]][wall[1]] = -2;

        while (!q.empty())
        {
            auto [x, y, k] = q.front();
            q.pop();
            int nx = x + dx[k];
            int ny = y + dy[k];
            // å¤ªä¼˜é›…äº†ï¼Œ k = 0 æ—¶ï¼Œ ä»£è¡¨ (nx, ny) -> (nx + 1, ny + 0) è¿™æ—¶å€™å¯¹åº”å‘ä¸‹çš„è§†çº¿
            //  k = 1 æ—¶ï¼Œ(nx, ny) -> (nx + 0, ny + 1) å³
            // k = 2, (nx, ny) -> (nx - 1, ny + 0) ä¸Š
            // k = 3, (nx, ny) -> (nx + 0, ny - 1) å·¦
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] >= 0)
            {
                // æ²¿ç€è§†çº¿æ–¹å‘çš„ä¸‹ä¸€ä¸ªåæ ‡åˆæ³•ï¼Œä¸”ä¸ä¸ºè­¦å«æˆ–å¢™
                if ((grid[nx][ny] & (1 << k)) == 0)
                {
                    // å¯¹åº”çŠ¶æ€æœªéå†è¿‡
                    grid[nx][ny] |= (1 << k);
                    q.emplace(nx, ny, k);
                }
            }
        }
        int res = 0;
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++) if (grid[i][j] == 0) res ++;

        return res;
    }
};
```

#### 2646.æœ€å°åŒ–æ—…è¡Œçš„ä»·æ ¼æ€»å’Œ

![æˆªå±2023-12-06 10.44.48](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-06 10.44.48.png)

**æš´åŠ›DFSæ¯æ¡è·¯å¾„**

å¯¹æ¯ä¸ª `trips[i]` éƒ½ DFS ä¸€æ¬¡è¿™æ£µæ ‘ï¼Œåœ¨ DFS çš„è¿‡ç¨‹ä¸­ï¼ŒæŠŠ `start` åˆ° `end` çš„è·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹ $x$ çš„ç»è¿‡æ¬¡æ•° $cnt[x]$ éƒ½åŠ ä¸€ã€‚

æ—¢ç„¶çŸ¥é“äº†æ¯ä¸ªç‚¹ä¼šè¢«ç»è¿‡å¤šå°‘æ¬¡ï¼ŒæŠŠ `price[i]` æ›´æ–°ä¸º `price[i]Â·cnt[i]` ï¼Œé—®é¢˜å°±è½¬æ¢ä¸ºè®¡ç®—å‡åŠåçš„ `price[i]` ä¹‹å’Œçš„æœ€å°å€¼ã€‚æ³¨æ„ `cnt[i]=0` æ—¶ `price[0]` ä¼šè¢«æ›´æ–°ä¸º $0$ ï¼Œæˆ‘ä»¬æ— éœ€è€ƒè™‘æ²¡æœ‰ç»è¿‡çš„èŠ‚ç‚¹ã€‚

å¯¹äºè½¬æ¢åçš„é—®é¢˜ï¼Œæˆ‘ä»¬éšä¾¿é€‰ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘ DFS ã€‚åœ¨ DFS çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹äºèŠ‚ç‚¹ $x$ åŠå…¶å„¿å­ $y$ ï¼Œåˆ†ç±»è®¨è®ºï¼š

- å¦‚æœ `price[x]` ä¸å˜ï¼Œé‚£ä¹ˆ `price[y]` å¯ä»¥å‡åŠï¼Œä¹Ÿå¯ä»¥ä¸å˜ï¼Œå–è¿™ä¸¤ç§æƒ…å†µçš„æœ€å°å€¼ï¼›
- å¦‚æœ`price[x]` å‡åŠï¼Œé‚£ä¹ˆ `price[y]`åªèƒ½ä¸å˜ã€‚

å› æ­¤å­æ ‘ $x$ éœ€è¦è¿”å›ä¸¤ä¸ªå€¼

- `price[x]` ä¸å˜æ—¶çš„å­æ ‘ $x$ çš„æœ€å°ä»·å€¼æ€»å’Œï¼›
- `price[x]` å‡åŠæ—¶çš„å­æ ‘ $x$ çš„æœ€å°ä»·å€¼æ€»å’Œï¼›

ç­”æ¡ˆå°±æ˜¯æ ¹ç»“ç‚¹ä¸å˜/å‡åŠçš„æœ€å°å€¼ã€‚

ä»¥ `start` ä¸ºæ ‘æ ¹ DFS ï¼Œæ‰¾åˆ° `end` æ—¶ï¼Œ `end` åŠå…¶ç¥–å…ˆèŠ‚ç‚¹å°±æ°å¥½ç»„æˆäº†ä» `start` åˆ° `end` çš„è·¯å¾„ã€‚

#### 64.æœ€å°è·¯å¾„å’Œ

![æˆªå±2023-12-07 19.45.13](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-07 19.45.13.png)

æ­¤é¢˜æ˜¯å…¸å‹çš„åŠ¨æ€è§„åˆ’é¢˜ç›®ã€‚

1. çŠ¶æ€å®šä¹‰
   è®¾ $dp$ ä¸ºå¤§å° $m\times n$ çŸ©é˜µï¼Œå…¶ä¸­ $dp[i][j]$ çš„å€¼ä»£è¡¨ç›´åˆ°èµ°åˆ° $(i, j)$ çš„æœ€å°è·¯å¾„å’Œ
2. è½¬ç§»æ–¹ç¨‹
   é¢˜ç›®è¦æ±‚ï¼Œåªèƒ½å‘å³æˆ–å‘ä¸‹èµ°ï¼Œæ¢å¥è¯è¯´ï¼Œå½“å‰å•å…ƒæ ¼ $(i,j)$ åªèƒ½ä»å·¦è¾¹çš„å•å…ƒæ ¼ $(i-1,j)$ æˆ–è€…ä¸Šè¾¹çš„å•å…ƒæ ¼ $(i, j -1)$ èµ°åˆ°ï¼Œå› æ­¤åªéœ€è¦è€ƒè™‘çŸ©é˜µçš„å·¦è¾¹ç•Œå’Œä¸Šè¾¹ç•Œã€‚

èµ°åˆ°å½“å‰å•å…ƒæ ¼ $(i,j)$ çš„æœ€å°è·¯å¾„å’Œ = â€œä»å·¦æ–¹å•å…ƒæ ¼ $(i-1,j)$ ä¸ä»ä¸Šæ–¹å•å…ƒæ ¼ $(i,j-1)$ èµ°æ¥çš„ **ä¸¤ä¸ªæœ€å°è·¯å¾„å’Œä¸­è¾ƒå°çš„** â€+å½“å‰å•å…ƒæ ¼å€¼ $grid[i][j]$ ã€‚å…·ä½“åˆ†ä¸ºä»¥ä¸‹ $4$ ç§æƒ…å†µï¼š

1. å½“å·¦è¾¹å’Œä¸Šè¾¹éƒ½ä¸æ˜¯çŸ©é˜µè¾¹ç•Œæ—¶ï¼šå³å½“ $i\neq 0,j\neq 0$ æ—¶ï¼Œ $dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j]$ 
2. å½“åªæœ‰å·¦è¾¹æ˜¯çŸ©é˜µè¾¹ç•Œæ—¶ï¼šåªèƒ½ä»ä¸Šè¾¹æ¥ï¼Œå³å½“ $i=0,j\neq 0$ æ—¶ï¼Œ$dp[i][j] = dp[i][j-1] + grid[i][j]$ 
3. å½“åªæœ‰ä¸Šè¾¹æ˜¯çŸ©é˜µè¾¹ç•Œæ—¶ï¼šåªèƒ½ä»å·¦è¾¹æ¥ï¼Œå³å½“ $i\neq0 j = 0$ æ—¶ï¼Œ $dp[i][j]=dp[i-1][j] + grid[i][j]$ 
4. å½“å·¦è¾¹å’Œä¸Šè¾¹éƒ½æ˜¯çŸ©é˜µè¾¹ç•Œæ—¶ï¼šå³å½“ $i=0,j=0$ æ—¶ï¼Œ$dp[i][j]=grid[i][j]$

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (i == 0 && j == 0) grid[i][j] = grid[i][j];
                if (i != 0 && j != 0) grid[i][j] = min(grid[i-1][j], grid[i][j - 1]) + grid[i][j];
                if (i == 0 && j != 0) grid[i][j] = grid[i][j - 1] + grid[i][j];
                if (i != 0 && j == 0) grid[i][j] = grid[i - 1][j] + grid[i][j];
            }
        }
        return grid[n - 1][m - 1];

    }
};
```

#### 1466.é‡æ–°è§„åˆ’è·¯çº¿

![æˆªå±2023-12-07 20.06.21](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-07 20.06.21.png)

é¢˜ç›®ç»™å®šä¸€å¼ ç”± `n` ä¸ªç‚¹ï¼ˆä½¿ç”¨ `0` åˆ° `n-1` ç¼–å·ï¼‰ï¼Œ`n-1` æ¡è¾¹æ„æˆçš„æœ‰å‘å›¾ï¼Œå¦‚æœå¿½ç•¥å˜å¾—æ–¹å‘ï¼Œå°±å˜æˆäº†ä¸€æ£µæ ‘ã€‚æˆ‘ä»¬éœ€è¦æ”¹å˜æŸäº›è¾¹çš„æ–¹å‘ä½¿å¾—æ¯ä¸ªç‚¹éƒ½å¯ä»¥è®¿é—®åˆ° `0` å·ç‚¹ã€‚

å¦‚æœå¿½ç•¥è¾¹çš„æ–¹å‘ï¼Œå°†æ¯æ¡æœ‰å‘è¾¹ä»¥åŠå…¶åå‘è¾¹åŠ å…¥åˆ°å›¾ä¸­ï¼Œé‚£ä¹ˆä»ä»»æ„ä¸€ç‚¹å‡ºå‘éƒ½èƒ½åˆ°è¾¾ `0` å·ç‚¹ã€‚è·¯å¾„ä¸Šå¯èƒ½ä¼šç»è¿‡åå‘è¾¹ï¼Œæˆ‘ä»¬éœ€è¦å˜æ›´ä¸ä¹‹å¯¹åº”çš„åŸè¾¹çš„æ–¹å‘ã€‚éœ€è¦å˜æ›´çš„æ¬¡æ•°å³ä¸ºç­”æ¡ˆã€‚

ä»¥æ¯ä¸ªç‚¹ä¸ºèµ·ç‚¹è¿›è¡Œæœç´¢çš„ä»£ä»·ä¼šå¾ˆå¤§ï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘ä» `0` å‡ºå‘å»éå†å…¶ä»–ç‚¹ï¼ˆå¯ä»¥ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢æˆ–è€…å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œæœ¬é¢˜è§£ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰ï¼ŒåŸæ¥æˆ‘ä»¬éœ€è¦ç»Ÿè®¡åå‘è¾¹çš„æ•°é‡ï¼Œç°åœ¨éœ€è¦ç»Ÿè®¡åŸæ–¹å‘è¾¹çš„æ•°é‡ã€‚

å…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬ä½¿ç”¨` 1`æ ‡è®°åŸæ–¹å‘çš„è¾¹ï¼Œä½¿ç”¨ `0` æ ‡è®°åå‘è¾¹ã€‚ç„¶åä» `0` å·ç‚¹å¼€å§‹éå†ï¼Œè®¿é—®åˆ°æŸä¸ªæ–°çš„ç‚¹æ—¶ï¼Œæ‰€ç»è¿‡çš„è¾¹è¢« `1` æ ‡è®°ï¼Œå°±ä»¤ç­”æ¡ˆåŠ  `1`ã€‚æœ€ç»ˆç»Ÿè®¡å¾—åˆ°çš„ç­”æ¡ˆå°±æ˜¯æˆ‘ä»¬éœ€è¦å˜æ›´æ–¹å‘çš„æœ€å°è·¯çº¿æ•°ã€‚

```c++
class Solution {
public:
    int dfs(int x, int parent, vector<vector<pair<int, int>>>& e)
    {
        // è¿™é‡Œ parent ä½œç”¨æ˜¯ä¿å­˜äº†ä¸Šä¸€ä¸ªèŠ‚ç‚¹
        int res = 0;
        for (auto &edge : e[x])
        {
            // è¿™é‡Œæ„æ€æ˜¯ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¯´æ˜åˆ°å¤´äº†
            // ç›´æ¥è·³è½¬ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            // æ¯”å¦‚åˆ°2äº†ï¼Œ2çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åˆ°3ä¸”3æ˜¯2çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆç›´æ¥è·³è½¬åˆ° (0, 4, 0) æ­¤æ—¶ parent = x = 3ç»§ç»­dfs
            if (edge.first == parent) continue;
            
            res += edge.second + dfs(edge.first, x, e);
        }
        return res;
    }


    int minReorder(int n, vector<vector<int>>& connections) {
        vector<vector<pair<int, int>>> e(n);

        for (auto edge : connections)
        {
            e[edge[0]].push_back(make_pair(edge[1], 1));
            e[edge[1]].push_back(make_pair(edge[0], 0));
        }
        return dfs(0, -1, e);
    }
};
```

#### 2048.ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°å€¼å¹³è¡¡æ•°

![æˆªå±2023-12-09 12.46.46](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-09 12.46.46.png)

æˆ‘é¦–å…ˆæƒ³åˆ°çš„æ˜¯ï¼Œç›´æ¥å¯¹æ¯ä¸ªæ•°å­—è¿›è¡Œæš´åŠ›åˆ¤æ–­ã€‚

```c++
class Solution {
public:
    bool judgeBeautiful(int n)
    {
        map<int, int> mp;
        int n_ = n;
        while (n_)
        {
            int tmp = n_ % 10;
            mp[tmp] = 0;
            n_ /= 10;
        }
        while (n)
        {
            int tmp = n % 10;
            mp[tmp] ++;
            n /= 10;
        }
        for (auto& mp_ : mp) if (mp_.first != mp_.second) return false;
        return true;
    }

    int nextBeautifulNumber(int n) {
        if (n == 0) return 1;
        int res;
        while (n <= 666666)
        {
            n ++;
            if (judgeBeautiful(n))
            {
                res = n;
                break;
            }
            
        }
        return n <= 666666 ? res : 1224444;
    }
};
```

#### 62.ä¸åŒè·¯å¾„

![æˆªå±2023-12-09 13.23.57](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-09 13.23.57.png)

```c++
class Solution {
public:

    int uniquePaths(int m, int n) {
        int dp[m][n];
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i != 0 && j != 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                if (i == 0 && j != 0) dp[i][j] = dp[i][j - 1];
                if (i != 0 && j == 0) dp[i][j] = dp[i - 1][j];
                if (i == 0 && j == 0) dp[i][j] = 1;
            }
        }
        return dp[m - 1][n - 1];
    }
};

```

#### 63.ä¸åŒè·¯å¾„

![æˆªå±2023-12-09 14.09.07](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-09 14.09.07.png)

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        int dp[m][n];

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (obstacleGrid[i][j] == 1) dp[i][j] = 0;
                else
                {
                    if (i != 0 && j != 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    if (i == 0 && j != 0) dp[i][j] = dp[i][j - 1];
                    if (i != 0 && j == 0) dp[i][j] = dp[i - 1][j];
                    if (i == 0 && j == 0) dp[i][j] = 1;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

#### 120.ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ

![æˆªå±2023-12-09 14.48.17](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-09 14.48.17.png)

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if (triangle.size() == 1) return triangle[0][0];
        int m = triangle.size(), n = triangle[m - 1].size();
        int dp[m][n];
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < triangle[i].size(); j++)
            {
                if (j == 0 && i != 0) dp[i][j] = dp[i - 1][j] + triangle[i][j];
                if (j == triangle[i].size() - 1 && i != 0) dp[i][j] = dp[i - 1][j - 1] + triangle[i][j];
                if (i == 0 && j == 0) dp[i][j] = triangle[0][0];
                if (j != 0 && j != triangle[i].size() - 1) dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j];
            }
        }
        int minVal = 1e5;
        for (int i = 0; i < n; i++) if (minVal > dp[m - 1][i]) minVal = dp[m - 1][i];
        return minVal;
    }
};
```

#### 931.ä¸‹é™è·¯å¾„æœ€å°å’Œ

```c++
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        
        int n = matrix.size();
        if (n == 1) return matrix[0][0];

        int dp[n][n];
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == 0) dp[i][j] = matrix[i][j];
                if (i != 0 && j == 0) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];
                if (i != 0 && j == (n - 1)) dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + matrix[i][j];
                if (i != 0 && j != 0 && j != (n - 1)) 
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]}) + matrix[i][j];
            }
        }
        int minVal = 1e5;
        for (int i = 0; i < n; i++) if (minVal > dp[n - 1][i]) minVal = dp[n - 1][i];
        return minVal;
    }
};
```



#### 100147.æœ€å¤šKä¸ªé‡å¤å…ƒç´ çš„æœ€é•¿å­æ•°ç»„

![æˆªå±2023-12-10 10.30.05](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-10 10.30.05.png)

```c++
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k) {
        int res = 0;
        unordered_map<int, int> cnt;
        int j = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            cnt[nums[i]] ++;
            while (cnt[nums[i]] > k)
            {
                cnt[nums[j++]]--;
            }
            res = max(res, i - j + 1);
        }
        return res;
    }
};
```

#### 221.æœ€å¤§æ­£æ–¹å½¢

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-10 13.40.25.png" alt="æˆªå±2023-12-10 13.40.25" style="zoom:50%;" />

æˆ‘ä»¬ç”¨ `dp[i][j`] è¡¨ç¤º ä»¥ `[i][j]` ä¸ºå³ä¸‹è§’ï¼Œä¸”åªåŒ…å« `1` çš„æ­£æ–¹å½¢çš„è¾¹é•¿æœ€å¤§å€¼ã€‚å¦‚æœæˆ‘ä»¬èƒ½è®¡ç®—å‡ºæ‰€æœ‰ `dp[i][j]` çš„å€¼ï¼Œé‚£ä¹ˆå…¶ä¸­çš„æœ€å¤§å€¼å³ä¸ºçŸ©é˜µä¸­åªåŒ…å« `1` çš„æ­£æ–¹å½¢çš„è¾¹é•¿æœ€å¤§å€¼ï¼Œå…¶å¹³æ–¹å³ä¸ºæœ€å¤§æ­£æ–¹å½¢çš„é¢ç§¯ã€‚

é‚£ä¹ˆå¦‚ä½•è®¡ç®— `dp` ä¸­çš„æ¯ä¸ªå…ƒç´ å€¼ï¼Ÿå¯¹äºæ¯ä¸ªä½ç½® `[i][j]` ï¼Œæ£€æŸ¥åœ¨çŸ©é˜µä¸­è¯¥ä½ç½®çš„å€¼â€œ

- å¦‚æœè¯¥ä½ç½®çš„å€¼æ˜¯ `0` ï¼Œåˆ™ `dp[i][j]=0` å› ä¸ºå½“å‰ä½ç½®ä¸å¯èƒ½åœ¨ç”± `1` ç»„æˆçš„æ­£æ–¹å½¢ä¸­ã€‚

- å¦‚æœè¯¥ä½ç½®çš„å€¼æ˜¯ `1` ï¼Œåˆ™ `dp[i][j]` çš„å€¼ç”±å…¶ä¸Šæ–¹ã€å·¦æ–¹å’Œå·¦ä¸Šæ–¹çš„ä¸‰ä¸ªç›¸é‚»ä½ç½®çš„ `dp` å€¼å†³å®šã€‚å…·ä½“è€Œè¨€ï¼Œå½“å‰ä½ç½®çš„å…ƒç´ å€¼ç­‰äºä¸‰ä¸ªç›¸é‚»ä½ç½®çš„å…ƒç´ ä¸­çš„æœ€å°å€¼åŠ `1` çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
  $$
  dp(i,j)=min(d(i-1,j),dp(i-1,j-1),dp(i,j-1)) + 1
  $$
  æ­¤å¤–ï¼Œè¿˜éœ€è¦è€ƒè™‘è¾¹ç•Œæ¡ä»¶ã€‚å¦‚æœ `i` å’Œ `j` ä¸­è‡³å°‘æœ‰ä¸€ä¸ªä¸º `0` åˆ™ä»¥ä½ç½®ä¸ºå³ä¸‹è§’çš„æœ€å¤§æ­£æ–¹å½¢çš„è¾¹é•¿å°±åªèƒ½æ˜¯ `1` ï¼Œå› æ­¤ `dp[i][j]=1` 

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) return 0;
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<int>> dp(rows, vector<int>(columns));
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < columns; j++)
            {
                if (matrix[i][j] == '1')
                {
                    if (i == 0 || j == 0) dp[i][j] = 1;
                    else dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }

        return maxSide * maxSide;
    }
};
```

#### 100137.ç»Ÿè®¡æœ€å¤§å…ƒç´ å‡ºç°è‡³å°‘Kæ¬¡çš„å­æ•°ç»„

<img src="/Users/huangqiuzhao/Library/Application Support/typora-user-images/æˆªå±2023-12-10 14.15.07.png" alt="æˆªå±2023-12-10 14.15.07" style="zoom:50%;" />

**åŒå‘åŒæŒ‡é’ˆ+æ»‘åŠ¨çª—å£** 

åœ¨å­æ•°ç»„å­ä¸²é—®é¢˜ä¸­ï¼Œç»å¸¸ä¼šç”¨åˆ°åŒæŒ‡é’ˆè¿™ä¸€æŠ€å·§ ã€‚ä¸¾ä¸ªä¾‹å­ï¼šç»™å®šä¸€ä¸ªå«æœ‰ `n` ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° `target` ã€‚æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶å’Œ `>=target`çš„é•¿åº¦æœ€å°çš„ **è¿ç»­å­æ•°ç»„** `nums` ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› `0` .

ä¾‹å¦‚209é¢˜ç›®ã€‚

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLen = nums.size() + 1;

        int left = 0;
        int right = 0;
        int sum = 0;
        for (; right < nums.size(); right++)
        {
            sum += nums[right];
            while ((sum - nums[left]) >= target)
            {
                sum -= nums[left];
                left ++;
            }
            if (sum >= target) minLen = min(minLen, right - left + 1);
        }
        return minLen <= nums.size() ? minLen : 0;
    }
};
```

 å†æ¯”å¦‚**713.ä¹˜ç§¯å°äºKçš„å­æ•°ç»„** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¿”å›å­æ•°ç»„å†…æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯ä¸¥æ ¼å°äº `k` çš„è¿ç»­å­æ•°ç»„çš„æ•°ç›®ã€‚ä¸‡å˜ä¸ç¦»å…¶å®—ï¼Œå…ƒç´ éƒ½æ˜¯æ­£æ•°ï¼Œæ–¹æ³•å’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼Œå¯¹äº `[10, 5, 2, 6]` æ¯”å¦‚æšä¸¾åˆ° `2` çš„æ—¶å€™ï¼Œå°±æŠŠ `2` æ¥åˆ°ä¸Šä¸€æ¬¡è®¡ç®—çš„ç»“æœåé¢ã€‚é‚£å¦‚æœå…ƒç´ çš„ä¹˜ç§¯ `>=k` å°±æŠŠå·¦ç«¯ç‚¹å³ç§»ï¼Œç¼©å°å­æ•°ç»„çš„é•¿åº¦ï¼Œç›´åˆ°ä¹˜ç§¯å°äº `k` ä¸ºæ­¢ã€‚é‚£ä¹ˆé—®é¢˜çš„å…³é”®ï¼Œä¹Ÿæ˜¯ä¸ä¸Šé¢˜ä¸åŒçš„ç‚¹ï¼Œ**å­æ•°ç»„çš„æ•°ç›®è¦æ€ä¹ˆç®—** è¿™é‡Œï¼Œæˆ‘ä»¬æšä¸¾åˆ° `2` ï¼Œéœ€è¦ç®—çš„å°±æ˜¯ä»¥ `2` ä¸ºå³ç«¯ç‚¹çš„æ»¡è¶³è¦æ±‚çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚`[5, 2]`ç®—æ˜¯ä¸€ä¸ªï¼Œ `[2]` å•ç‹¬ç®—ä¸€ä¸ªã€‚ç”¨ä»£ç æ¥è®¡ç®—ï¼Œå°±éœ€è¦æ¨å¯¼å‡ºæ¥ä¸€ä¸ªå…¬å¼ï¼Œå‡è®¾æ­¤æ—¶å·¦ç«¯ç‚¹ä¸º `l`ï¼Œå³ç«¯ç‚¹ä¸º`r` ã€‚é‚£ä¹ˆæˆ‘ä»¬ç°åœ¨éœ€è¦è®¡ç®—çš„å°±æ˜¯ä»¥ `r` ä¸ºå³ç«¯ç‚¹çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚æ³¨æ„å³ç«¯ç‚¹æ˜¯å›ºå®šçš„ï¼Œå¦‚æœä» `l` åˆ° `r` çš„è¿™ä¸€æ®µçš„ä¹˜ç§¯æ˜¯å°äº `k` çš„ã€‚é‚£ä¹ˆä» `l+1` åˆ° `r` çš„è¿™ä¸€æ®µä¹Ÿæ˜¯å°äº `k` çš„ã€‚ä¸€ç›´åˆ° `[r, r]` è¿™äº›å­æ•°ç»„éƒ½æ˜¯æ»¡è¶³è¦æ±‚çš„ã€‚é‚£ä¹ˆå­æ•°ç»„çš„ä¸ªæ•°å…¶å®å°±æ˜¯ä» `l` åˆ° `r` çš„å…ƒç´ ä¸ªæ•°ã€‚é‚£ä¹ˆå°±æ˜¯ `r-l+1` 

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) return 0;
        int left = 0;
        int right = 0;
        int sum = 1;
        int maxNums = 0;

        for (; right < nums.size(); right++)
        {
            sum *= nums[right];
            while (sum  >= k)
            {
                sum /= nums[left];
                left ++;  
            }
            maxNums += right - left + 1;
        }

        return maxNums;
    }
};
```

æ¥ç€è¿˜æœ‰ **3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` ,æ‰¾å‡ºå…¶ä¸­ä¸å«é‡å¤å­—ç¬¦çš„ **æœ€é•¿å­ä¸²** çš„é•¿åº¦ã€‚ç”±äºå¦‚æœå‡ºç°çš„é‡å¤å­—ç¬¦çš„å”¯ä¸€æƒ…å†µå°±æ˜¯åˆšåˆšåŠ å…¥çš„å­—ç¬¦ä¸ä¹‹å‰çš„å­—ç¬¦å‘ç”Ÿé‡å¤ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä½¿ç”¨å“ˆå¸Œçš„æ–¹æ³•ï¼Œç»Ÿè®¡ä¸€ä¸‹åˆšåŠ å…¥çš„å­—ç¬¦æ˜¯å¦å‡ºç°é‡å¤å³å¯ã€‚

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0;
        int right = 0;
        int maxLen = 0;
        unordered_map<char, int> mp;
        for (right; right < s.size(); right++)
        {
            mp[s[right]] ++;
            while (mp[s[right]] >= 2)
            {
                mp[s[left]] --;
                left ++;
            }
            maxLen = max(maxLen, right - left + 1);
        }
        return maxLen;
    }
};
```

å›åˆ°è¿™ä¸ªé¢˜ç›®ï¼Œé¦–å…ˆæ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§æ•°ï¼Œè®¾ $mx=max(nums)$ å³ç«¯ç‚¹ $right$ ä»å·¦åˆ°å³éå† $nums$ ã€‚éå†åˆ°å…ƒç´ $x=nums[right]$  å¦‚æœ $x=mx$ ï¼Œå°±æŠŠè®¡æ•°å™¨ $cntMx$ åŠ ä¸€ã€‚å¦‚æœæ­¤æ—¶ $cntMx = k$ åˆ™ä¸æ–­å³ç§»å·¦æŒ‡é’ˆ $left$ ï¼Œç›´åˆ°çª—å†…çš„ $mx$ çš„å‡ºç°æ¬¡æ•° **å°äº** $k$ ä¸ºæ­¢ã€‚æ­¤æ—¶ï¼Œå¯¹äºå³ç«¯ç‚¹ä¸º $right$ ä¸”å·¦ç«¯ç‚¹å°äº $left$ çš„å­æ•°ç»„ï¼Œ$mx$ çš„å‡ºç°æ¬¡æ•°éƒ½è‡³å°‘ä¸º $k$ ï¼ŒæŠŠç­”æ¡ˆå¢åŠ  $left$ ã€‚

```c++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        int left = 0;
        int right = 0;
        int maxVal = 0;
        for (int i = 0; i < nums.size(); i++) maxVal = max(maxVal, nums[i]);
        int maxValCnt = 0;
        long long sum = 0;

        for (right; right < nums.size(); right++)
        {
            if (nums[right] == maxVal) maxValCnt ++;
            while (maxValCnt == k)
            {
                if (nums[left] == maxVal) maxValCnt --;
                left ++;
            }
            sum += left;
        }

        return sum;
    }
};
```

#### 1631.æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„

![æˆªå±2023-12-11 12.28.59](/Users/huangqiuzhao/blog/source/_posts/åŠ›æ‰£/æˆªå±2023-12-11 12.28.59.png)

çœ‹åˆ°è¿™ä¸ªé¢˜ç›®ï¼Œæœ€å°è·¯å¾„ï¼Œç¬¬ä¸€ååº”æ˜¯DPï¼Œä½†æ˜¯è¿™é‡Œæ˜¯å¾€ **ä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³** å››ä¸ªæ–¹å‘ç§»åŠ¨ï¼Œè½¬å¿µä¸€æƒ³ï¼Œè¿™å·²ç»æ˜¯DPè§£å†³ä¸äº†çš„é—®é¢˜äº†ã€‚å› ä¸ºï¼Œä½ æ— æ³•ç¡®å®šéƒ½æœ‰å“ªäº›ä½ç½®èƒ½å¤Ÿåˆ°è¾¾ä½ å½“å‰çš„ä½ç½®ï¼Œä¹Ÿå°±æ˜¯æ— æ³•æ¨å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚

äº‹å®ä¸Šï¼Œå½“é¢˜ç›®å…è®¸å¾€ä»»æ„æ–¹å‘ç§»åŠ¨æ—¶ï¼Œè€ƒå¯Ÿçš„å¾€å¾€å°±ä¸æ˜¯DPäº†ï¼Œè€Œæ˜¯å›¾è®ºã€‚ä»æœ¬è´¨ä¸Šè¯´ï¼ŒDPé—®é¢˜æ˜¯ä¸€ç±»ç‰¹æ®Šçš„å›¾è®ºé—®é¢˜ã€‚é‚£ä¸ºä»€ä¹ˆæœ‰ä¸€äº›DPé¢˜ç›®ç®€å•ä¿®æ”¹æ¡ä»¶åï¼Œå°±åªèƒ½å½»åº•è½¬åŒ–ä¸ºå›¾è®ºé—®é¢˜æ¥è§£å†³å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºä¿®æ”¹æ¡ä»¶åï¼Œå¯¼è‡´æˆ‘ä»¬DPçŠ¶æ€å±•å¼€ä¸å†æ˜¯ä¸€ä¸ªæ‹“æ‰‘åºåˆ—ã€‚æ¢å¥è¯è¯´ï¼ŒDPé¢˜è™½ç„¶éƒ½å±äºå›¾è®ºèŒƒç•´ã€‚ä½†å¯¹äºä¸æ˜¯æ‹“æ‰‘å›¾çš„å›¾è®ºé—®é¢˜ï¼Œæˆ‘ä»¬æ— æ³•ä½¿ç”¨DPæ±‚è§£ã€‚è€Œæ­¤ç±»çœ‹ä¼¼DPï¼Œå®åˆ™å›¾è®ºçš„é—®é¢˜ï¼Œé€šå¸¸æ˜¯æœ€å°ç”Ÿæˆæ ‘æˆ–è€…æœ€çŸ­è·¯é—®é¢˜ã€‚

**Kruskal**

**å½“ä¸€é“é¢˜æˆ‘ä»¬å†³å®šå¾€å›¾è®ºæ–¹å‘æ€è€ƒæ—¶ï¼Œæˆ‘ä»¬çš„é‡ç‚¹åº”è¯¥æ”¾åœ¨å¦‚ä½•å»ºå›¾ä¸Šã€‚** å› ä¸ºè§£å†³ç‰¹å®šçš„å›¾è®ºé—®é¢˜æ—¶ï¼ˆæœ€çŸ­è·¯/æœ€å°ç”Ÿæˆæ ‘/äºŒåˆ†å›¾åŒ¹é…ï¼‰ï¼Œæˆ‘ä»¬éƒ½æ˜¯ä½¿ç”¨ç‰¹å®šçš„ç®—æ³•ã€‚ç”±äºä½¿ç”¨åˆ°çš„ç®—æ³•éƒ½æœ‰å›ºå®šçš„æ¨¡ç‰ˆï¼Œå› æ­¤ç¼–ç éš¾åº¦å¾ˆä½ï¼Œè€Œå¦‚ä½•å»ºå›¾çš„æ€ç»´éš¾åº¦åˆ™å¾ˆé«˜ã€‚å¯¹äºæœ¬é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§å¦‚ä¸‹åˆ†æè¿›è¡Œå»ºå›¾ï¼š

å› ä¸ºåœ¨ä»»æ„æ ¼å­å¯ä»¥å¾€ä»»æ„æ–¹å‘ç§»åŠ¨ï¼Œæ‰€ä»¥ç›¸é‚»çš„æ ¼å­ä¹‹é—´å­˜åœ¨ä¸€æ¡æ— å‘è¾¹ã€‚é¢˜ç›®è¦æ±‚æˆ‘ä»¬æ±‚çš„å°±æ˜¯ä»èµ·ç‚¹åˆ°ç»ˆç‚¹ï¼Œç»è¿‡è·¯å¾„ä¸­çš„æœ€å°æƒé‡çš„æœ€å¤§å€¼æ˜¯å¤šå°‘ã€‚æˆ‘ä»¬å¯ä»¥å…ˆéå†æ‰€æœ‰çš„æ ¼å­ï¼Œå°†æ‰€æœ‰çš„è¾¹åŠ å…¥é›†åˆã€‚å­˜å‚¨çš„æ ¼å¼ä¸ºæ•°ç»„ `[a,b,w]` ï¼Œä»£è¡¨ç¼–å·ä¸º `a` çš„ç‚¹å’Œç¼–å·ä¸º `b` çš„ç‚¹ä¹‹é—´çš„æƒé‡ä¸º `w` ã€‚æŒ‰ç…§é¢˜æ„ï¼Œ `w` ä¸ºä¸¤è€…çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ã€‚å¯¹é›†åˆè¿›è¡Œæ’åºï¼ŒæŒ‰ç…§ `w` è¿›è¡Œä»å°åˆ°å¤§æ’åº (Kruskal)å½“æˆ‘ä»¬æœ‰äº†æ’å¥½åºçš„å€™é€‰è¾¹é›†åˆä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥å¯¹è¾¹è¿›è¡Œä»å‰å¾€åå¤„ç†ï¼Œæ¯æ¬¡åŠ å…¥ä¸€æ¡è¾¹ä¹‹åï¼Œä½¿ç”¨å¹¶æŸ¥é›†æ¥æŸ¥è¯¢èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦è¿é€šã€‚

```c++
// å¹¶æŸ¥é›†æ¨¡æ¿
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    int n;
    // å½“å‰è¿é€šåˆ†é‡æ•°ç›®
    int setCount;
    
public:
    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }
    
    int findset(int x) {
        return parent[x] == x ? x : parent[x] = findset(parent[x]);
    }
    
    bool unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            swap(x, y);
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    bool connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
};

class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        vector<tuple<int, int, int>> edges;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int id = i * n + j;
                if (i > 0) {
                    edges.emplace_back(id - n, id, abs(heights[i][j] - heights[i - 1][j]));
                }
                if (j > 0) {
                    edges.emplace_back(id - 1, id, abs(heights[i][j] - heights[i][j - 1]));
                }
            }
        }
        sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {
            auto&& [x1, y1, v1] = e1;
            auto&& [x2, y2, v2] = e2;
            return v1 < v2;
        });

        UnionFind uf(m * n);
        int ans = 0;
        for (const auto [x, y, v]: edges) {
            uf.unite(x, y);
            if (uf.connected(0, m * n - 1)) {
                ans = v;
                break;
            }
        }
        return ans;
    }
};

```

#### 2415.åè½¬äºŒå‰æ ‘çš„å¥‡æ•°å±‚

æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢

æˆ‘ä»¬ç›´æ¥æŒ‰ç…§å±‚æ¬¡éå†è¯¥äºŒå‰æ ‘ï¼Œç„¶åå°†å¥‡æ•°å±‚ä¸­çš„å€¼è¿›è¡Œåè½¬ã€‚äºŒå‰æ ‘æŒ‰ç…§å±‚æ¬¡éå†æ˜¯ä¸€ä¸ªåŸºæœ¬çš„å¹¿åº¦ä¼˜å…ˆæœç´¢é—®é¢˜ï¼Œåœ¨éå†çš„åŒæ—¶ï¼Œå¯¹æ¯ä¸€å±‚è¿›è¡Œæ ‡è®°ï¼Œå¦‚æœå½“å‰è¯¥å±‚ä¸ºå¥‡æ•°å±‚ï¼Œåˆ™å°†è¯¥å±‚ä¸­çš„èŠ‚ç‚¹ç”¨æ•°ç»„ä¿å­˜èµ·æ¥ï¼Œç„¶åå°†è¯¥å±‚æ‰€æœ‰èŠ‚ç‚¹çš„å€¼è¿›è¡Œåè½¬å³å¯ã€‚

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* reverseOddLevels(TreeNode* root) {
        queue<TreeNode *> qu;
        qu.emplace(root);
        bool isOdd = false;
        while (!qu.empty())
        {
            int sz = qu.size();
            vector<TreeNode *> arr;
            for (int i = 0; i < sz; i++)
            {
                TreeNode *node = qu.front();
                qu.pop();
                if (isOdd) arr.emplace_back(node);
                if (node->left)
                {
                    qu.emplace(node->left);
                    qu.emplace(node->right);
                }
            }

            if (isOdd) 
            {
                for (int l = 0, r = sz - 1; l < r; l++, r--) swap(arr[l]->val, arr[r]->val);
            }
            isOdd ^= true;
        }
        return root;
    }
};
```





























