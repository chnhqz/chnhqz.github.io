{
    "version": "https://jsonfeed.org/version/1",
    "title": "刀刀博客",
    "description": "欢迎来到刀刀的笔记空间(^_^)",
    "home_page_url": "https://chnhqz.github.io",
    "items": [
        {
            "id": "https://chnhqz.github.io/2024/05/30/c/",
            "url": "https://chnhqz.github.io/2024/05/30/c/",
            "title": "c++",
            "date_published": "2024-05-30T03:07:19.000Z",
            "content_html": "\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/",
            "url": "https://chnhqz.github.io/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/",
            "title": "计算机网络",
            "date_published": "2024-05-23T14:03:39.000Z",
            "content_html": "<h2 id=\"概述\">概述</h2>\n<h2 id=\"osi的七层网络模型\">OSI的七层网络模型</h2>\n<p>分别为应用层、表示层、会话层、运输层、网络层、链路层和物理层。</p>\n<ul>\n<li>应用层（数据）：确定进程之间通信的性质、满足用户需要、提供网络和用户应用。为应用程序提供服务，DNS、HTTP、HTTPS、DHCP、FTP、POP3（Post\nOffice Protocol）、SMTP（Simple Mail Transfer Protocol）都是这层的协议。\n<ol type=\"1\">\n<li><strong>DNS (Domain Name System)</strong>\n<ul>\n<li><strong>概念</strong>：DNS是互联网的“电话簿”，它将用户友好的域名（如www.example.com）转换为计算机可以理解的IP地址（如192.0.2.1）。</li>\n<li><strong>技术细节</strong>：当用户在浏览器中输入一个域名时，DNS服务器会查找并返回该域名对应的IP地址。这通常涉及多个DNS服务器的查询，包括根服务器、顶级域名服务器（如.com、.org）和权威域名服务器。</li>\n</ul></li>\n<li><strong>HTTP (HyperText Transfer Protocol)</strong>\n<ul>\n<li><strong>概念</strong>：HTTP是一种用于传输网页数据的协议，它定义了客户端（如浏览器）和服务器之间的通信规则。</li>\n<li><strong>技术细节</strong>：HTTP是无状态的协议，意味着每个请求都是独立的。一个典型的HTTP请求包括请求行、请求头和请求体。服务器接收到请求后，返回一个包含状态行、响应头和响应体的响应。</li>\n</ul></li>\n<li><strong>HTTPS (HyperText Transfer Protocol Secure)</strong>\n<ul>\n<li><strong>概念</strong>：HTTPS是HTTP的安全版本，通过加密通信确保数据传输的机密性和完整性。</li>\n<li><strong>技术细节</strong>：HTTPS使用SSL/TLS协议对HTTP通信进行加密，防止数据在传输过程中被窃取或篡改。客户端和服务器之间首先建立一个安全连接（握手过程），然后在该连接上进行HTTP通信。</li>\n</ul></li>\n<li><strong>DHCP (Dynamic Host Configuration Protocol)</strong>\n<ul>\n<li><strong>概念</strong>：DHCP是一种自动分配IP地址和其他网络参数的协议，简化了网络设备的配置过程。</li>\n<li><strong>技术细节</strong>：当设备连接到网络时，它会发送一个DHCP发现消息，DHCP服务器响应并分配一个可用的IP地址，同时提供其他配置参数如子网掩码、默认网关和DNS服务器地址。</li>\n</ul></li>\n<li><strong>FTP (File Transfer Protocol)</strong>\n<ul>\n<li><strong>概念</strong>：FTP是一种用于在客户端和服务器之间传输文件的协议，支持文件上传和下载。</li>\n<li><strong>技术细节</strong>：FTP工作在应用层，通过控制连接和数据连接进行文件传输。用户可以通过FTP客户端连接到FTP服务器，浏览目录并传输文件。FTP有两种主要模式：主动模式和被动模式，分别影响数据连接的建立方式。</li>\n</ul></li>\n<li><strong>POP3 (Post Office Protocol version 3)</strong>\n<ul>\n<li><strong>概念</strong>：POP3是一种从邮件服务器下载电子邮件到本地客户端的协议，适用于离线邮件访问。</li>\n<li><strong>技术细节</strong>：POP3客户端连接到POP3服务器，验证用户身份后，下载邮件到本地并默认从服务器上删除这些邮件。POP3的简单性和离线访问特点使其适合个人邮件管理。</li>\n</ul></li>\n<li><strong>SMTP (Simple Mail Transfer Protocol)</strong>\n<ul>\n<li><strong>概念</strong>：SMTP是一种用于发送和转发电子邮件的协议，确保邮件从发件人传递到收件人。</li>\n<li><strong>技术细节</strong>：SMTP客户端将邮件发送到SMTP服务器，服务器根据收件人的地址将邮件传递给目标服务器或中继服务器。SMTP定义了邮件交换的标准格式和传输过程，包括发件人地址、收件人地址、主题和邮件内容。</li>\n</ul></li>\n</ol></li>\n<li>表示层（数据）：主要解决用户信息的语法表示问题，表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别，如数据转换，压缩、加密、解密。</li>\n<li>会话层（数据）：会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用层之间的服务请求和响应组成，比如服务器验证用户登录就是在会话层。</li>\n<li>传输层（数据段）：实现网络不同主机上的用户进程之间的数据通信，可靠与不可靠的传输、传输层的错误检测、流量控制、拥塞控制。TCP/UDP就在这层。向用户提供可靠的端到端服务，处理数据包错误、数据包次序，以及其它一些关键传输问题。传输层向高层屏蔽了下层数据通信的细节。</li>\n<li>网络层（数据包）：本层通过<code>IP寻址</code>\n来建立两个节点之间的连接，为源端的运输层送来的分组，通过路由选择算法为分组通过通信子网选择最适当的路径，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。<code>IP</code>在这层。</li>\n<li>数据链路层（数据帧）：将上层数据封装成帧，用<code>MAC</code>地址访问媒介，并有错误检测和修正。在物理层提供的服务基础上，在通信的实体间建立数据链路连接，传输的数据单位是“帧”，并采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。</li>\n<li>物理层（比特流）：是参考模型的最低层。该层是网络通信的数据传输介质，由连接不同结点的电缆与设备共同构成。主要跟功能是：利用传输介质为数据链路层提供物理连接，负责处理数据传输并监控数据出错率，以便数据流的透明传输。传输数据的单位是比特（Bits）</li>\n</ul>\n<p>举个例子🌰：</p>\n<blockquote>\n<p>小绿人通过电脑端向小鱼人发送“刀吗”。首先是在<code>应用层</code>通过系统程序界面（微信窗口）将“刀吗”输入到电脑微信软件。之后电脑在<code>表示层</code>将这句话转换为二进制，也可以进行安全加密、压缩等操作。然后小绿人找到小鱼人点击发送，这时候计算机需要找到小鱼人的计算机并和对方建立会话关系，这便是在<code>会话层</code>需要完成的动作。下一步是通过<code>传输层</code>实现同一个软件的两个端口进行数据传输。再接着是在<code>网络层</code>通过小鱼人的IP地址，选择最佳路径进行准确的数据传输。再下一步是将数据传输到<code>数据链路层</code>听过数据链路层的网卡，继续进行数据传输。最后数据到达<code>物理层</code>变成数字信号传输。</p>\n</blockquote>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/计算机网络/7541336-906a34d0af992f70.png\"\nalt=\"7541336-906a34d0af992f70.png\" />\n<figcaption aria-hidden=\"true\">7541336-906a34d0af992f70.png</figcaption>\n</figure>\n<h2 id=\"tcpudp\">TCP/UDP</h2>\n<h3 id=\"tcp报文结构\">TCP报文结构</h3>\n<p>TCP协议，<strong>传输控制协议</strong>\n一种面向连接的、可靠的、基于字节流通信协议。TCP把连接作为最基本的抽象单元，每条TCP连接有两个端点，TCP连接的端点即套接字。套接字\n<code>socket=(IP地址:端口号)</code>\nTCP连接=<code>&#123;socket1,socket2&#125;=&#123;(IP1:port1),(IP2:port2)&#125;</code> TCP\n提供全双工通信。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/计算机网络/image-20240524142449988.png\"\nalt=\"image-20240524142449988\" />\n<figcaption aria-hidden=\"true\">image-20240524142449988</figcaption>\n</figure>\n<ul>\n<li><strong>源端口</strong>：16位，标识报文的返回地址。</li>\n<li><strong>目的端口</strong>：16位，指明接收方计算机上的应用程序接口。</li>\n<li><strong>序列号</strong>：32位，在建立连接时由计算机生成的随机数作为其初始值，通过\nSYN\n包传给接收端主机，每发送一次数据，就<strong>累加</strong>一次该<strong>数据字节数</strong>的大小。用来解决网络包乱序问题。</li>\n<li><strong>确认号</strong>：32位，指下一次<strong>期望</strong>收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。</li>\n<li><strong>数据偏移／首部长度</strong>：4位，TCP首部可能含有可选项内容，所以TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示最大长度为60字节。首部长度也叫数据偏移，因为首部长度实际上指示了数据区在报文段中的起始偏移值。</li>\n<li><strong>保留</strong>：6位，为将来定义新的用途保留，现在一般置0。</li>\n<li><strong>校验和</strong>：16位，由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏，这个校验不仅包括TCP头部，也包括数据部分。<strong>这是TCP实现可靠传输的一个重要保障</strong>。</li>\n<li><strong>窗口</strong>：16位，是TCP流量控制的一个手段。通过窗口告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方可以控制发送数据的速度，从而达到流量控制。窗口大小为16bit字段，因而窗口大小最大为65535。</li>\n<li><strong>紧急指针</strong>：16位，只有当 URG 标志置 1\n时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。使用紧急指针是发送端向另一端发送紧急数据的一种方式。</li>\n<li><strong>选项和填充</strong>：TCP头部的最后一个选项字段是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节。\n最常见的可选字段是最长报文大小MSS，每个连接方通常都在通信的第一个报文段中指明这个选项，它表示本端所能接受的最大报文段的长度。</li>\n<li><strong>数据部分</strong>：TCP\n报文段中的数据部分是可选的。在连接建立或者终止时，双方交换的报文段仅有\nTCP\n首部；如果一方没有数据要发送，也会使用没有任何数据的首部来确认收到的数据；在处理超时的许多情况中，也会发送不带任何数据的报文段。</li>\n</ul>\n<p>还包括控制位：</p>\n<ul>\n<li><strong>URG</strong>：紧急指针标志，为1时表示紧急指针有效，<strong>该报文应该优先传送</strong>，为0则忽略紧急指针。</li>\n<li><strong>ACK</strong>：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息。携带ACK标识的TCP报文段被称为<strong>确认报文段</strong>。</li>\n<li><strong>RST</strong>：重置连接标志，<strong>用于重置由于主机崩溃或其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求</strong>。称携带RST标志的TCP报文段为复位报文段。</li>\n<li><strong>SYN</strong>：表示请求建立一个连接。称携带SYN标志的TCP报文段为同步报文段。</li>\n<li><strong>FIN</strong>：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。称携带FIN标志的TCP报文段为结束报文段。</li>\n<li><strong>PSH</strong>：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应优先将这个报文段交给应用程序，而不是在缓冲区排队。</li>\n</ul>\n<h3 id=\"tcp保证可靠传输\">TCP保证可靠传输</h3>\n<h4 id=\"校验和\">校验和</h4>\n<p>TCP是端到端的传输，由发送方计算校验和，接收方进行验证，目的是为了验证TCP首部和数据在发送过程中没有任何改动，一旦发现校验和有差错，直接丢弃TCP段并重新发送。</p>\n<h4 id=\"序列号确认应答\">序列号/确认应答</h4>\n<p>TCP传输时发送方对每一个发送的消息都会编号，也就是序列号seq。接收方在每次接收到消息后回复确认应答号ACK，不仅告诉接收到哪些数据，还包括下一次消息从哪里发送。只要发送方没有接收到确认应答号ACK，都会重新发送数据。</p>\n<h4 id=\"超时重传\">超时重传</h4>\n<p>发送方发送完数据后会等待一定的时间，如果在这个时间内没有接收到ACK，就会重传数据。如果是发送方发生了丢包，那么接收方在接收到数据后会回复ACK，如果是接收方回复的ACK丢失了导致的重传，那么根据校验和和序列号知道该数据已经接收，丢弃该数据并发送ACK。</p>\n<h4 id=\"连接管理\">连接管理</h4>\n<p>三次握手和四次挥手得以实现。</p>\n<h4 id=\"流量控制滑动窗口控制\">流量控制（滑动窗口控制）</h4>\n<p>发送方发送数据的快慢取决于接收方接收能力。TCP的报文信息中有一个16位字段来标识滑动窗口，窗口大小就是接收方剩余缓冲区大小，在回复ACK时，接收方将自己剩余缓冲区大小填入。发送方根据窗口大小来调整自己的发送速度，如果缓冲区大小为0，那么发送方会停止发送数据。并且发送方定期会发送探测报文，来获取缓冲区大小。</p>\n<h4 id=\"快速重传\">快速重传</h4>\n<p>当接收端收到比期望号大的seq时候，就会发送冗余ACK，在超时重传之前如果收到三个相同的冗余ACK，那么就知道哪段报文发生了丢包，重传该段报文即可，避免了超时重传。</p>\n<h4 id=\"拥塞控制\">拥塞控制</h4>\n<p>网络可能刚开始很拥塞，如果在网络传输过程中开始就发送大量数据的话，会发生丢包和超时重传，所以需要慢启动算法、拥塞避免算法、快速重传和快速恢复。</p>\n<p>慢启动算法</p>\n<p>一开始不发送大量数据，而是应该先发一小部分探测数据，然后由小到大逐渐增大发送窗口。通常在刚刚开始发送报文段时，先把拥塞窗口\ncwnd\n设置为1，每次接收到报文之后将窗口大小翻倍。如果指数增长到避免拥塞算法的门限ssthresh，则改用避免拥塞算法。</p>\n<ul>\n<li>初始化设置 cwnd = 1，并开始传输数据</li>\n<li>收到回馈的 ACK，会将 cwnd 加 1</li>\n<li>当发送端一个 RTT 后且未发现有丢包重传，就会将 cwnd = cwnd * 2</li>\n<li>当 cwnd &gt;= ssthresh\n或发生丢包重传时慢启动结束，进入拥塞避免状态</li>\n</ul>\n<h4 id=\"避免拥塞算法\">避免拥塞算法</h4>\n<p>每当收到一个 ACK 时，cwnd 增加\n1/cwnd，变为线性增长。一但发现丢包和超时重传，就进入拥塞处理状态。</p>\n<h5 id=\"拥塞发生\">拥塞发生</h5>\n<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传和快速重传。</p>\n<p>ssthresh 和 cwnd 的值会发生变化</p>\n<ul>\n<li>ssthresh 设为 cwnd/2</li>\n<li>cwnd 重置为 1</li>\n</ul>\n<p>发送三次前一个包的\nACK，于是发送端就会快速地重传，不必等待超时再重传。TCP\n认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd\n变化如下：</p>\n<ul>\n<li>cwnd = cwnd/2 ，也就是设置为原来的一半</li>\n<li>ssthresh = cwnd</li>\n<li>进入快速恢复算法</li>\n</ul>\n<h5 id=\"快速恢复\">快速恢复</h5>\n<ul>\n<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3\n个数据包被收到了）</li>\n<li>重传丢失的数据包</li>\n<li>如果再收到重复的 ACK，那么 cwnd 增加 1</li>\n<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh\n的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK\n时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态</li>\n</ul>\n<h3 id=\"tcp三次握手\">TCP三次握手</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/计算机网络/image-20240524221226071.png\"\nalt=\"image-20240524221226071\" />\n<figcaption aria-hidden=\"true\">image-20240524221226071</figcaption>\n</figure>\n<p><strong>第一次握手</strong> 客户端请求建立连接，将首部\n<code>SYN</code>\n标识位置为<code>1</code>，初始化序列号<code>seq=x</code>\n，发送给服务器。并进入<code>SYN_SENT</code>状态，等待服务器确认。</p>\n<p><strong>第二次握手</strong> 服务器收到 <code>SYN</code> 后，将首部的\n<code>SYN</code>和<code>ACK</code>标识位置为<code>1</code>，回复确认<code>ack</code>的值为客户端发送的序列号<code>x+1</code>，同时自己也要初始化一个<code>seq=y</code>，<code>ACK</code>和<code>SYN</code>一起发送客户端，进入<code>SYN_RECV</code>状态。</p>\n<p><strong>第三次握手</strong>\n客户端收到服务器的<code>SYN</code>和<code>ACK</code>包后，向服务器发送确认包\n<code>ack</code>，值为服务器的序列号<code>y+1</code>，并且自己的<code>seq</code>为<code>x+1</code>，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>（TCP连接成功）状态。</p>\n<blockquote>\n<p>1.TCP为什么要三次握手？</p>\n</blockquote>\n<p>只有三次握手才能证明服务端和客户端的收发能力都是正常的。</p>\n<p><strong>第一次握手</strong>：客户端发数据服务端接收，服务端可以知道客户端发消息的能力是正常的，自己接收消息的能力是正常的。</p>\n<p><strong>第二次握手</strong>：服务端发消息客户端收，客户端可以知道自己发送接收消息的能力和服务端发送接收消息的能力是正常的。</p>\n<p><strong>第三次握手</strong>：客户端再发送消息服务端接收，服务端可以知道自己发送消息的能力是正常的，客户端接收消息的能力是正常的。</p>\n<p>由此经过三次握手之后双方就可以都知道自己的发送和接收消息的能力是正常的。</p>\n<blockquote>\n<p>2.TCP的三次握手中间出现丢失？⚠️注意，在TCP通信连接过程中，ACK报文发生丢包是不会重传的，ACK丢失是由对方重传对应的报文。</p>\n</blockquote>\n<p><strong>第一次丢失</strong>：客户端发送的SYN报文会收不到服务端的响应，从而会触发超时重传，重传的SYN报文序列号和之前相同，重传最大重传次数由内核参数控制，一般是5。如果超过最大次数客户端仍没有收到回复就会断开连接。</p>\n<p><strong>第二次丢失</strong>：服务端在收到客户端的报文之后会回复SYN+ACK报文，如果第二次握手丢失了客户端会认为自己丢包了，触发超时重传，重新发送SYN报文，服务端因为收不到确认的ACK自身也会重传。</p>\n<p><strong>第三次丢失</strong>：客户端收到服务端的 SYN-ACK\n报文后会给服务端回一个 ACK 报文，此时客户端状态进入到\n<strong>ESTABLISH</strong>\n状态。如果发生了丢包，服务端收不到ACK会触发超时重传机制，重传 SYN-ACK\n报文，直到收到确认ACK或者达到最大重传次数。</p>\n<blockquote>\n<p>3.TCP为什么不是两次握手？</p>\n</blockquote>\n<p><strong>避免历史连接</strong>\n首要原因是为了防止旧的重复连接初始化造成混乱。如果使用的是两次握手建立连接，可能客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。之前滞留的那一次请求连接，因为网络通畅了，到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>\n<p><strong>同步双方初始序列号</strong>\n为了实现可靠数据传输，TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。\n三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。</p>\n<h3 id=\"tcp四次挥手\">TCP四次挥手</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/计算机网络/截屏2024-05-26%2022.17.01.png\"\nalt=\"截屏2024-05-26 22.17.01\" />\n<figcaption aria-hidden=\"true\">截屏2024-05-26 22.17.01</figcaption>\n</figure>\n<p><strong>第一次挥手</strong></p>\n<p>客户端发送释放报文，并停止发送数据，将首部的FIN标识位置为1，序列号seq=u发送给服务器，值等于前面已经传送过来的数据的最后一个字节的序号加1，此时客户端进入<strong>FIN_WAIT_1</strong>状态。即便FIN报文不携带数据，也要消耗一个序列号。</p>\n<p><strong>第二次挥手</strong></p>\n<p>服务器在收到释放报文后，发送确认报文，ACK标识位置为1，ack值为客户端发送的序列号u+1，并带上自己的序列号v，然后服务器进入<strong>CLOSE_WAIT关闭等待</strong>状态。这时服务器TCP通知高级应用进程，客户端向服务器的连接释放了，进入半关闭状态，但是服务器如果向客户端发送数据，客户端仍然可以接收，这个状态要持续一段时间，也就是<strong>CLOSE_WAIT关闭等待</strong>持续的时间。</p>\n<p>客户端收到服务器的确认请求后，进入<strong>FIN_WAIT_2</strong>状态，等待服务器发送释放报文。</p>\n<p><strong>第三次挥手</strong></p>\n<p>服务器数据处理完毕后，向客户端发送释放连接报文，FIN标识位置为1，ack的值为客户端的序列号u+1，由于在半关闭状态，服务器很可能又发送一些数据，假定此时序列号为w，服务器进入<strong>LAST_ACK</strong>状态，等待客户端确认。</p>\n<p><strong>第四次挥手</strong></p>\n<p>客户端在收到服务器的释放连接报文后，会发送确认报文，ACK标识位置为1，ack值为服务器发送的序列号w+1，</p>\n<p>自己的序列号是u+1，然后客户端就进入<strong>TIME_WAIT</strong>状态。此时TCP连接还没有释放，必须经过两个MSL时间（一个MSL指的是报文段最长寿命），当客户端撤销TCB，才进入<strong>CLOSED</strong>状态。</p>\n<p>服务器只要收到客户端发送的确认请求，立即进入<strong>CLOSED</strong>状态。同时会撤销TCB，TCP连接至此结束。</p>\n<blockquote>\n<p>1.TCP为什么要四次挥手？</p>\n</blockquote>\n<p>关闭连接时，客户端向服务端发送 <code>FIN</code>\n时，仅仅表示客户端不再发送数据了，但是还能接收数据。服务端收到客户端的\n<code>FIN</code> 报文时，先回一个 <code>ACK</code>\n应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送\n<code>FIN</code> 报文给客户端来表示同意现在关闭连接。</p>\n<blockquote>\n<p>2.在 FIN_WAIT_2 状态下，是如何处理收到的乱序到 FIN 报文，然后 TCP\n连接又是什么时候才进入到 TIME_WAIT 状态？</p>\n</blockquote>\n<p>在FIN_WAIT_2状态时，如果收到乱序的FIN报文会加入到乱序队列，并不会进入到TIME_WAIT状态。等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有FIN标志，如果发现有FIN标志，才会进入TIME_WAIT状态。</p>\n<blockquote>\n<p>3.TCP的四次挥手丢失？</p>\n</blockquote>\n<p><strong>第一次丢失</strong>：客户端发送的报文FIN报文收不到服务端的ACK响应，会触发超时重传，重传\nFIN 报文，重发次数由内核参数控制。</p>\n<p><strong>第二次丢失</strong>：服务端回复的ACK报文发生丢失，客户端会触发超时重传，重传\nFIN\n报文，直到收到服务端的ACK或者达到最大的重传次数。超过最大重传次数还没收到ACK会等待一段时间，再断开连接。</p>\n<p><strong>第三次丢失</strong>：服务端收到客户端的 FIN\n报文后内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态。服务端处于\nCLOSE_WAIT 状态时，调用了 close 函数，内核会发出 FIN 报文，同时连接进入\nLAST_ACK 状态，等待客户端返回 ACK\n来确认连接关闭。收不到ACK的话会重发FIN报文直到最大次数为止。</p>\n<p><strong>第四次丢失</strong>：最后一次的ACK发生了丢失，服务端没有收到\nACK 报文前是处于 LAST_ACK\n状态。超时之后服务端会重传FIN报文，客户端此时是在 TIME_WAIT\n状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN\n报文）后，会重置定时器，当等待 2MSL 时长后，客户端会断开连接。</p>\n<blockquote>\n<p>4.TCP的延迟应答和累积应答</p>\n</blockquote>\n<p><strong>延迟应答</strong>：TCP在接收到对端的报文后并不会立即发送ACK，而是等待一段时间发送ACK，以便将ACK和要发送的数据一块发送。延迟时间不能无限延长，否则对方端会认为丢包超时而造成超时重传。Linux采用动态调节算法来确定等待的时间。</p>\n<p><strong>累计应答</strong>：为了保证顺序性，每一个包都有一个<strong>ID</strong>（序号），在建立连接的时候，双方会商定起始的ID是多少，然后按照ID一个个发送。为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会<strong>应答某个之前的ID</strong>，该模式称为<strong>累计应答。</strong></p>\n<blockquote>\n<p>5.TCP会有三次挥手出现吗？</p>\n</blockquote>\n<p>当被动关闭方在TCP挥手过程中，<strong>没有数据要发送</strong>并且开启了<strong>延迟应答</strong>，第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>\n<blockquote>\n<p>6.TCP的MSL</p>\n</blockquote>\n<p>MSL是任何报文在网络中被丢弃前的最长存活时间，这个时间是有限的，因为TCP是以IP数据报的形式在网络中传输，IP有限制其生存的时间TTL，<strong>RFC793指出MSL为2分钟，现实中常用30秒或1分钟。</strong></p>\n<blockquote>\n<p>7.已经建立了连接，客户端突然出现故障了会怎样？</p>\n</blockquote>\n<p>TCP存在保活计时器，如果客户端故障，服务器不会一直等待。通常计时器设置为两小时，在每次收到客户端发来的报文都会重置计时器，超时之后客户端就会发送探测报文，每隔75S发送一次，如果连续10个探测报文都没有收到回复，服务器会认为客户端发生故障，中断此次连接。</p>\n<blockquote>\n<p>8.什么时候用长连接，短连接？</p>\n</blockquote>\n<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就可以，不用建立TCP连接。<strong>例如：数据库的连接用长连接</strong>。</p>\n<p><strong>WEB网站的HTTP服务一般都用短链接</strong>，因为长连接对于服务端来说会耗费一定的资源，而WEB网站成千上万客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，所以并发量大，用短链接可以快速释放资源。</p>\n<blockquote>\n<p>9.TCP的半连接队列和全连接队列？</p>\n</blockquote>\n<p><strong>半连接队列</strong>：也称 SYN 队列，服务端收到客户端发起的\nSYN\n请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端发SYN+ACK，</p>\n<p><strong>全连接队列</strong>：也称 accept 队列，服务端收到第三次握手的\nACK\n后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到全连接队列，等待进程调用\naccept 函数时把连接取出来。</strong></p>\n<blockquote>\n<p>10.什么是SYN攻击？如何避免？</p>\n</blockquote>\n<p>概念</p>\n<p>SYN攻击是指利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。如果向某个服务器端口发送大量的SYN报文，接收到客户端发来的SYN报文之后，服务端就需要为每个请求分配一个进程控制块TCB，并返回一个SYN-ACK报文，并立即转为SYN_RECV半开连接状态，收不到对端ACK回复的服务端还会重传SYN-ACK报文,\n系统会为此耗尽资源。</p>\n<p>避免方法</p>\n<p><strong>Cache</strong>：系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。</p>\n<p><strong>Cookie</strong>：利用算法，通过对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(最大报文段大小)、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence\nNumber-1）相同，从而决定是否分配TCB资源。</p>\n<p><strong>Proxy防火墙</strong>：设立中间层防火墙，防火墙在确认了连接的有效性后，才向内部的服务器发起SYN请求，所有的无效连接均无法到达内部的服务器。而防火墙采用的验证连接有效性的方法则可以是Cookie或Cathe等其他技术。</p>\n<p><strong>减少SYN+ACK重传次数</strong>：减少 SYN-ACK\n的重传次数，以加快处于 SYN_RECV 状态的 TCP 连接断开。</p>\n<p><strong>无效连接监视释放</strong>：不停监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，正常连接请求也会被这种方式误释放掉。</p>\n<p><strong>增大半连接队列</strong>：修改TCP的内核参数，增大全连接队列大小。</p>\n<p><strong>调大netdev_max_backlog</strong>：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包，可以调大队列大小。</p>\n<blockquote>\n<p>11.TIME_WAIT作用，过多如何解决？</p>\n</blockquote>\n<p><strong>TCP常用的三个状态是：</strong>ESTABLISHED<strong>表示正在通信，</strong>TIME_WAIT<strong>表示主动关闭，</strong>CLOSE_WAIT<strong>表示被动关闭</strong></p>\n<p>作用</p>\n<p><strong>实现全双工的可靠释放连接</strong></p>\n<p>假设发起主动关闭的一方最后发送的ACK在网络中丢失，由于TCP的重传机制，被动关闭的一方会重新发送FIN报文，在FIN在被主动关闭方接收之前，主动关闭方都需要维护这条连接状态，包括对应的IP地址和端口号。如果发送方不维护TIME_WAIT状态，那么当FIN到达主动关闭方的时候，主动关闭放会发送RST包来响应，被动关闭方就会认为有错误发生。</p>\n<p><strong>为使旧的数据包在网络因过期而消失</strong></p>\n<p>如果不存在TIME_WAIT状态，当前的一个TCP四元组因为某些原因关闭之后，假设有一个新的相同的四元组建立了TCP连接，因为TCP连接是由四元组唯一标识的，所以没法区分新旧连接。旧的已经关闭的TCP连接发送的数据到达接受方之后，会被当作正常数据而向上传输，从而导致数据错乱。有了TIME_WAIT状态之后，可以使旧TCP产生的数据包全部在网路中消亡。</p>\n<p><strong>危害</strong></p>\n<ul>\n<li>占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等</li>\n<li>占用端口资源，端口资源也是有限的，一般可以开启的端口为\n32768～61000，也可以通过 net.ipv4.ip_local_port_range参数指定范围</li>\n</ul>\n<p>避免方法</p>\n<ul>\n<li>修改短连接为长连接</li>\n<li>扩大可使用端口号的范围</li>\n<li>客户端机器打开tcp_tw_reuse和tcp_timestamps选项</li>\n</ul>\n<p>tcp_tw_reuse调用 connect() 函数时，内核会随机找一个 time_wait\n状态超过 1\n秒的连接给新的连接复。复用连接之后需要更新timestamps参数，当旧的TCP数据包到达时，根据时间戳判断是旧连接的数据可以舍弃。</p>\n<ul>\n<li>客户端机器打开tcp_tw_recycle和tcp_timestamps选项</li>\n</ul>\n<p>当开启之后内核会快速回收TIME_WAIT状态的连接，时间是一个RTO，远小于两个MSL。在启用该配置，当连接进入TIME_WAIT状态后，内核里会记录包括该连接对应五元组的一些统计数据，包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。</p>\n<ul>\n<li>缩小net.ipv4.tcp_max_tw_buckets</li>\n</ul>\n<p>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的\nTIME_WAIT 连接状态重置。</p>\n<ul>\n<li>程序中使用 SO_LINGER</li>\n</ul>\n<p>那么调用close后，会立该发送一个RST标志给对端，该 TCP\n连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。</p>\n<blockquote>\n<p>12.TIME_WAIT状态为什么需要经过2MSL？</p>\n</blockquote>\n<p>因为客户端最后一个发送的ACK有可能丢失。假如服务器没有收到客户端发送的最后一个ACK，就会重新发送FIN报文，为了确保服务器收到了FIN报文，客户端在TIME_WAIT状态需要经过2MSL，在这个期间客户端收到重发的FIN报文就会重新发送ACK并且重设计时器。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。第一个MSL是保证最后一次挥手客户端响应服务端的ACK到达了服务端。第二个MSL是保证服务端没有重发新的报文给客户端，没有超时重传。</p>\n<p>如果客户端直接关闭，然后向服务器建立新连接，如果新连接和老连接的端口是一样的。假设老连接还有一些数据，因为网络或者其他原因，一直滞留没有发送成功，新连接建立后，就直接发送到新连接里面去了，造成数据的紊乱，因此，需要等到2MSL，让滞留在网络中的报文失效，再去建立新的连接。</p>\n<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK\n开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK\n没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么\n<strong>2MSL 时间将重新计时</strong></p>\n<blockquote>\n<p>13.TCP和UDP的区别？</p>\n</blockquote>\n<ul>\n<li>TCP是面向连接的。在通信之前需要三次握手建立连接，通信之后断开连接时需要四次挥手；UDP不需要进行连接建立。</li>\n<li>TCP是可靠传输服务。通过TCP传输数据可以保证数据无差错、不丢失、不重复；UDP尽最大努力交付，不保证可靠交付。</li>\n<li>每个TCP对应的是点对点的连接；UDP支持一对一、一对多、多对一、多对多等多种方式的通讯。</li>\n<li>UDP对系统资源要求较少，通讯效率高，实时性好，应用于高速传输并且对实时性有要求的通信；TCP适合需要可靠连接，比如付费、加密数据等等方向都需要依靠TCP。</li>\n<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20\n个字节，如果使用了「选项」字段则会变长的；UDP 首部只有 8\n个字节，并且是固定不变的。</li>\n<li>TCP 是流式传输，没有边界，但保证顺序和可靠。UDP\n是一个包一个包的发送，是有边界的，可能会丢包和乱序。</li>\n<li>TCP 的数据大小如果大于 MSS\n大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP\n数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP\n的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP\n层组装完数据，接着再传给传输层。</li>\n<li>应用场景：TCP用于FTP文件传输，HTTP /\nHTTPS；UDP用于包总量较少的通信，如 DNS、SNMP\n等，视频、音频等多媒体通信，广播通信。</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2024/05/16/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/",
            "url": "https://chnhqz.github.io/2024/05/16/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/",
            "title": "英语六级作文",
            "date_published": "2024-05-16T10:50:39.000Z",
            "content_html": "<p>首段第一句话：提出核心论点。</p>\n<p>如今，越来越多的人...去...。</p>\n<blockquote>\n<p>Nowadays, more and more people ... to ...</p>\n</blockquote>\n<p>首段第二句话：引出下文观点：</p>\n<p>由于... 我们应该优先考虑本文中讨论的两个方面</p>\n<blockquote>\n<p>Since there are ... , priority should be given to two aspects as\ndiscussed in this essay.</p>\n</blockquote>\n<p>接下来是主要的议论佐证自己观点的两部分，每一部分接着使用三段式，第一句话提出自己的观点，第二句话提出应该进行的一些行动，第三句话总结前两句话。</p>\n<p>第一句话，首先，去做什么...是重要的在近些年。</p>\n<blockquote>\n<p>To begin with, it is essential to ... in recent years.</p>\n</blockquote>\n<p>第二句话，... 是不利于我们自身的发展。这意味着，...\n是可能很快就会过时 /变得很坏。我们需要不断...来保持竞争力</p>\n<blockquote>\n<p>... is not good for ourselves develop. This means that ... today may\nsoon be obsolete. We need to constantly ... to stay competitive.</p>\n</blockquote>\n<p>第三句话，因此，... 的最有效方法之一就是保持 ... 的能力。</p>\n<blockquote>\n<p>so, one of the most effective ways of ... is to keep the ability of\n...</p>\n</blockquote>\n<p>第</p>\n<blockquote>\n<p>四句话，此外，保持对... 的渴望 是 适应 ...\n的关键在不断变化的如今。</p>\n</blockquote>\n<blockquote>\n<p>Moreover, in today's constantly changing world.staying hungry for ...\nis the key to adapting to ... 。</p>\n</blockquote>\n<p>第五句话，如今，通过...获得...远不足以维持...</p>\n<blockquote>\n<p>Nowadays, ... by ... is far from sufficient to ...</p>\n</blockquote>\n<p>第六句话，因此，我们需要...，否则我们可能...在未来。</p>\n<blockquote>\n<p>so, we ought to maintain ... . Otherwise, we may not ... in the\nfuture.</p>\n</blockquote>\n<p>最后一段是结束部分。总而言之，... 是 让我们 ...\n做好准备的两个重要品质/方面。</p>\n<blockquote>\n<p>In conclusion, ... are two important qualities / ares that prepare us\nfor ...</p>\n</blockquote>\n<blockquote>\n<p>Nowadays, more and more people keep learning skills to adapt to a\nfast-changing world.</p>\n</blockquote>\n<h3 id=\"模版\">模版</h3>\n<p><strong>首段</strong>： 如今，越来越多的人...去...。</p>\n<blockquote>\n<p>Nowadays, more and more people ... to ... .</p>\n</blockquote>\n<p>由于... 我们应该优先考虑本文中讨论的两个方面。</p>\n<blockquote>\n<p>Given the ... , priority should be given to the two aspects discussed\nin this essay.</p>\n</blockquote>\n<p><strong>主体部分</strong>： 首先，去做什么...是重要的在近些年。</p>\n<blockquote>\n<p>To begin with, it is essential to ... in recent years.</p>\n</blockquote>\n<p>... 是不利于我们自身的发展。这意味着，...\n可能很快就会过时。我们需要不断...来保持竞争力。</p>\n<blockquote>\n<p>... is detrimental to our own development. This means that ... may\nsoon become obsolete. We need to constantly ... to stay competitive.</p>\n</blockquote>\n<p>因此，... 的最有效方法之一就是保持 ... 的能力。</p>\n<blockquote>\n<p>Therefore, one of the most effective ways to ... is to maintain the\nability to ...</p>\n</blockquote>\n<p>此外，保持对... 的渴望是适应不断变化的世界的关键。</p>\n<blockquote>\n<p>Moreover, in today's constantly changing world, staying hungry for\n... is key to adapting to ...</p>\n</blockquote>\n<p>如今，通过...获得...远不足以维持...</p>\n<blockquote>\n<p>Nowadays, obtaining ... through ... is far from sufficient to ...</p>\n</blockquote>\n<p>因此，我们需要...，否则我们可能在未来...</p>\n<blockquote>\n<p>Therefore, we need to ..., or we may ... in the future.</p>\n</blockquote>\n<p><strong>结尾</strong>： 总而言之，... 是让我们为...\n做好准备的两个重要方面。</p>\n<blockquote>\n<p>In conclusion, ... are two important aspects that prepare us for\n...</p>\n</blockquote>\n<hr />\n<h3 id=\"作文1\">作文1</h3>\n<p><strong>首段</strong>：</p>\n<p>如今，越来越多的人不断学习新技能以适应快速变化的世界。 &gt; Nowadays,\nmore and more people are continuously learning new skills to adapt to\nthe rapidly changing world.</p>\n<p>由于技术进步和全球化，我们应该优先考虑本文中讨论的两个方面。 &gt;\nGiven technological advancements and globalization, priority should be\ngiven to the two aspects discussed in this essay.</p>\n<p><strong>主体部分</strong>：</p>\n<p>首先，不断学习新技能在近些年变得尤为重要。 &gt; To begin with,\ncontinuously learning new skills has become especially important in\nrecent years.</p>\n<p>不学习新技能是不利于我们自身的发展。这意味着，今天有用的技能可能很快就会过时。我们需要不断学习新技能来保持竞争力。\n&gt; Not learning new skills is detrimental to our own development. This\nmeans that skills useful today may soon become obsolete. We need to\nconstantly learn new skills to stay competitive.</p>\n<p>因此，保持不断学习的能力是适应快速变化的最有效方法之一。 &gt;\nTherefore, one of the most effective ways to adapt to rapid changes is\nto maintain the ability to continually learn.</p>\n<p>此外，在不断变化的世界中，保持对新知识的渴望是关键。 &gt; Moreover,\nin today's constantly changing world, staying hungry for new knowledge\nis key to adapting to changes.</p>\n<p>如今，仅仅通过传统教育获得知识远不足以维持我们的职业发展。 &gt;\nNowadays, obtaining knowledge solely through traditional education is\nfar from sufficient to sustain our career development.</p>\n<p>因此，我们需要终身学习，否则我们可能在未来失去竞争力。 &gt;\nTherefore, we need lifelong learning, or we may lose our competitiveness\nin the future.</p>\n<p><strong>结尾</strong>：</p>\n<p>总而言之，不断学习新技能和保持对新知识的渴望是让我们为快速变化的世界做好准备的两个重要方面。\n&gt; In conclusion, continuously learning new skills and staying hungry\nfor new knowledge are two important aspects that prepare us for the\nrapidly changing world.</p>\n<hr />\n<h3 id=\"作文2\">作文2</h3>\n<p><strong>首段</strong>：</p>\n<p>如今，越来越多的人意识到拥有社会、集体和家庭责任感的重要性。 &gt;\nNowadays, more and more people realize the importance of having a sense\nof social, collective, and family responsibility.</p>\n<p>由于社会结构的变化和全球化的影响，我们应该优先考虑本文中讨论的两个方面。\n&gt; Given the changes in social structures and the impact of\nglobalization, priority should be given to the two aspects discussed in\nthis essay.</p>\n<p><strong>主体部分</strong>：</p>\n<p>首先，培养社会责任感在近些年变得尤为重要。 &gt; To begin with,\nfostering a sense of social responsibility has become especially\nimportant in recent years.</p>\n<p>缺乏社会责任感是不利于我们社会的和谐发展。这意味着，如果每个人只关注自己的利益，社会将变得混乱和不公正。我们需要培养社会责任感来促进共同的福祉。\n&gt; The lack of social responsibility is detrimental to the harmonious\ndevelopment of our society. This means that if everyone only focuses on\ntheir own interests, society will become chaotic and unjust. We need to\nfoster social responsibility to promote the common good.</p>\n<p>因此，培养社会责任感的最有效方法之一就是参与社区活动和志愿服务。 &gt;\nTherefore, one of the most effective ways of fostering social\nresponsibility is by participating in community activities and volunteer\nwork.</p>\n<p>此外，保持对集体责任感的重视是适应现代社会变化的关键。 &gt; Moreover,\nin today's rapidly changing society, emphasizing collective\nresponsibility is key to adapting to changes.</p>\n<p>如今，单靠个人的力量难以解决复杂的社会问题。我们需要集体的努力来应对这些挑战。\n&gt; Nowadays, relying solely on individual efforts is insufficient to\naddress complex social issues. We need collective efforts to tackle\nthese challenges.</p>\n<p>因此，我们需要培养团队合作精神和集体责任感，否则我们可能无法在未来应对各种社会问题。\n&gt; Therefore, we need to cultivate team spirit and a sense of\ncollective responsibility. Otherwise, we may not be able to address\nvarious social issues in the future.</p>\n<p><strong>结尾</strong>：</p>\n<p>总而言之，培养社会责任感和集体责任感是让我们为未来做好准备的两个重要方面。\n&gt; In conclusion, fostering a sense of social responsibility and\ncollective responsibility are two important aspects that prepare us for\nthe future.</p>\n<hr />\n<p>在美国，学院和大学应为太过于精英化和太昂贵而被批评，并且并没有为世界上的工作训练毕业生。这些评论忽视来这个事实，这些机构继续去培养学生在他们的工作中成功、在生活中思考得到、终身学习、理解世界和他们想要成为什么人。</p>\n<p>这些学院和大学必须做一些正确的事。申请人数创下纪录，并且他们的金融项目使得他们比起之前更容易进入。这种教育模式在创造机会、经济增长和持续创新发挥着巨大作用。</p>\n<p>然而，这种模式的价值近来受到质疑。最近的税收账单是一种提醒，由于一些政府我们的最有实力的院校受到影响。开始的目的将会使得教育对于许多通过税收的那些毕业生变得难以承受。幸而，这些举措将会从账单中消失。但是法律制定者坚持一个新税收在一些院校的收入投资上。</p>\n<p>然而这些攻击是在缺乏引导思想下执行的，我们需要一个更好的行动去解释为什么这些推断是错误的并且为什么我们做的事有价值的。我们不能够带走任何明显的奖励。</p>\n<p>经常谈起，精英院校不锻炼学生，尤其是那些学习文学艺术的。但是这可以通过学术研究推翻。数据事清晰的：一个文学艺术教育事巨大的职业经历准备，等同于精彩的生命获得和工作满足感。这是发展批判性思考、数据分析的能力。这项能力保持学生学习。事实上，文学艺术在想象领域尤其重要。</p>\n<p>通过在精英院校的学习现在在低中收入家庭中是越来越可以接受的。我们建立了通过校友和理解并接受我们思想的捐赠去提供通道和机会，并且成为金融项目的一个标志性部分。</p>\n<p>新的税收为那些不能够负担教育的人提供一个机会。经济背景的多样性加强了所有学生的教育和经历。</p>\n<h3 id=\"section\">1.</h3>\n<p>Today there is a growing awareness that mental well-being needs t be\ngiven as much attention as physical health. Mental well-being plays an\nimportant role in personal development in recent years.</p>\n<p>There is a public debate today over mental well-being. Some people\nbelieve the mental well-being can not only enhance self-confidence, but\nalso enhance personal abilities and make people pleasure. There is no\ndoubt that when you have a better mental well-being than other people.\nyou will feel more pleasure and joy than other people. other people\nclaim that physical health more important than mental health. As I see\nit, mental health and physical health both important to us to get a\nbetter life. We must learn to deal the problems that when we to keep\nmental health and physical health. In recent years, we will face many\ndifficult things in mental health and physical health. If we can learn\nhow to deal them, we will enjoy the pleasures and joy of real world.</p>\n<p>All in all, everyone must to keep mental well-being and physical\nhealth. In real world, The faster you learn how to keep mental health\nand physical health, the faster you enjoy real world.</p>\n<blockquote>\n<p>改正语法错误后的短文：</p>\n<p>Today, there is a growing awareness that mental well-being needs to\nbe given as much attention as physical health. Mental well-being has\nplayed an important role in personal development in recent years.</p>\n<p>There is a public debate today over mental well-being. Some people\nbelieve that mental well-being can not only enhance self-confidence but\nalso improve personal abilities and increase happiness. There is no\ndoubt that when you have better mental well-being than others, you will\nfeel more pleasure and joy. Other people claim that physical health is\nmore important than mental health. As I see it, mental health and\nphysical health are both important for us to have a better life. We must\nlearn to deal with the problems that arise when we strive to maintain\nboth mental and physical health. In recent years, we have faced many\nchallenges in maintaining mental and physical health. If we can learn\nhow to deal with them, we will enjoy the pleasures and joys of the real\nworld.</p>\n<p>All in all, everyone must maintain both mental well-being and\nphysical health. In the real world, the faster you learn how to maintain\nmental and physical health, the sooner you will enjoy life.</p>\n</blockquote>\n<p>润色后的作文</p>\n<p>Today, there is a growing awareness that mental well-being deserves\nas much attention as physical health. Mental well-being has played an\nincreasingly important role in personal development in recent years.</p>\n<p>There is a public debate today over the importance of mental\nwell-being. Some people believe that mental well-being can not only\nenhance self-confidence but also improve personal abilities and increase\nhappiness. There is no doubt that when you have better mental well-being\nthan others, you will experience more pleasure and joy. Others claim\nthat physical health is more important than mental health. In my view,\nboth mental and physical health are crucial for leading a better life.\nWe must learn to address the challenges that arise when striving to\nmaintain both mental and physical health. In recent years, we have\nencountered many challenges in preserving our mental and physical\nhealth. If we can learn how to manage these challenges, we will enjoy\nthe true pleasures and joys of life.</p>\n<p>All in all, everyone must maintain both mental well-being and\nphysical health. In the real world, the faster you learn how to maintain\nboth, the sooner you will enjoy a fulfilling life.</p>\n<p>主要润色点</p>\n<ol type=\"1\">\n<li><strong>增加连贯性</strong>：\n<ul>\n<li>\"deserves as much attention as\" 比 \"needs to be given as much\nattention as\" 更简洁和有力。</li>\n<li>\"Mental well-being has played an increasingly important role\" 增加了\n\"increasingly\" 更加突出了其重要性。</li>\n</ul></li>\n<li><strong>修正表达</strong>：\n<ul>\n<li>\"Some people believe that mental well-being can not only enhance\nself-confidence but also improve personal abilities and increase\nhappiness\" 结构清晰，语义明确。</li>\n<li>\"Others claim that physical health is more important than mental\nhealth\" 保留对立观点的简洁性。</li>\n</ul></li>\n<li><strong>个人观点</strong>：\n<ul>\n<li>\"In my view\" 比 \"As I see it\" 更正式。</li>\n<li>\"address the challenges\" 比 \"deal with the problems\" 更准确。</li>\n</ul></li>\n<li><strong>总结段</strong>：\n<ul>\n<li>\"preserving our mental and physical health\" 比 \"maintaining mental\nand physical health\" 更具保护性。</li>\n<li>\"a fulfilling life\" 比 \"life\" 更能传达丰富和满足感。</li>\n</ul></li>\n</ol>\n<h3 id=\"section-1\">2.</h3>\n<p>In an era of information explosion, it is vitally import to develop\nthe ability to think critically and make rational choices. The ability\nto think critically and make rational choices has played an important\nrole in personal development in recent years.</p>\n<p>There is no doubt that when you have the ability to think critically\nand make rational choices. you will always make the right choices in\nyour life.Some people believe the ability to think critically and make\nrational choices can not only enhance self-confidence but also enhance\npersonal abilities.Other people claim that to develop the ability to\nthink critically and make rational choices is too difficult for many\npeople. As I see it,although it is difficult to practice this ability\nconsistently, we still need to try our best to learn how to do it.We\nmust learn to deal with the problems that arise when we begin to\npractice this ability. In recent years, if we can try our best to think\ncritically and make rational choices, we will enjoy the pleasures and\njoys of the real world.</p>\n<p>All in all, everyone must to prsactice this ability.In the real\nworld, the faster you learn how to get this ability, the sooner you will\nenjoy life.</p>\n<blockquote>\n<p>In an era of information explosion, it is vitally important to\ndevelop the ability to think critically and make rational choices. The\nability to think critically and make rational choices has played an\nimportant role in personal development in recent years.</p>\n<p>There is no doubt that when you have the ability to think critically\nand make rational choices, you will always make the right decisions in\nyour life. Some people believe that the ability to think critically and\nmake rational choices can not only enhance self-confidence but also\nimprove personal abilities. Other people claim that developing the\nability to think critically and make rational choices is too difficult\nfor many people. As I see it, although it is difficult to practice this\nability consistently, we still need to try our best to learn how to do\nit. We must learn to deal with the problems that arise when we begin to\npractice this ability. In recent years, if we can try our best to think\ncritically and make rational choices, we will enjoy the pleasures and\njoys of the real world.</p>\n<p>All in all, everyone must practice this ability. In the real world,\nthe faster you learn how to develop this ability, the sooner you will\nenjoy life.</p>\n<hr />\n</blockquote>\n<p>In an era marked by an explosion of information, developing the\nability to think critically and make rational choices is vitally\nimportant. This ability has played an increasingly important role in\npersonal development in recent years.</p>\n<p>There is no doubt that possessing the ability to think critically and\nmake rational choices enables you to consistently make the right\ndecisions in life. Some believe that this ability can not only enhance\nself-confidence but also improve personal capabilities and increase\nhappiness. Others claim that developing this ability is too challenging\nfor many people. In my view, although consistently practicing this\nability is difficult, it is crucial that we strive to learn it. We must\nlearn to address the problems that arise as we begin to practice this\nskill. In recent years, if we strive to think critically and make\nrational choices, we will experience the true pleasures and joys of the\nreal world.</p>\n<p>In conclusion, everyone must practice this ability. In the real\nworld, the faster you learn to develop this skill, the sooner you will\nenjoy life.</p>\n<h3 id=\"section-2\">3.</h3>\n<p>People are now increasingly aware of the danger of 'appearance\nanxiety' or being obsessed with one's looks.This is a good thing.To be\nself-confidence has played an important role in personal development in\nrecent years.</p>\n<p>There is a public debate today over appearance anxiety.Some people\nbelieve that too much appearance anxiety can not only destroy\nself-confidence but also reduce personal abilities and increase\nunhappiness.There is no doubt that when you put too much attention on\nappearance anxiety, you will always be tense in life.Other people claim\nthat some appearance anxiety can help people to be better in life.As I\nsee it, refuse appearance anxiety is important for us to have a better\nlife.We must learn to deal with the problems that arise when we face the\nappearance anxiety.In recent years, we have faced many challenges in\nappearance anxiety.If we can learn how to deal with them, we will enjoy\nthe pleasures and joys of the real world.</p>\n<p>All in all, everyone must to refuse appearance anxiety.In the real\nworld, the faster you learn how to refuse appearance anxiety, the sooner\nyou will enjoy life.</p>\n<blockquote>\n<h3 id=\"原文中的语法错误及改正\">原文中的语法错误及改正</h3>\n<ol type=\"1\">\n<li><strong>句子结构和动词形式</strong>：\n<ul>\n<li>\"To be self-confidence\" 应改为 \"Being self-confident\"。</li>\n<li>\"We must learn to deal with the problems that arise when we face the\nappearance anxiety.\" 应改为 \"We must learn to deal with the problems\nthat arise when we face appearance anxiety.\"</li>\n<li>\"All in all, everyone must to refuse appearance anxiety.\" 应改为\n\"All in all, everyone must refuse appearance anxiety.\"</li>\n</ul></li>\n<li><strong>单词拼写和使用</strong>：\n<ul>\n<li>\"self-confidence\" 应改为 \"self-confident\"。</li>\n<li>\"refuse\" 在某些上下文中应改为 \"reject\" 或 \"avoid\" 更合适。</li>\n</ul></li>\n<li><strong>一致性和连贯性</strong>：\n<ul>\n<li>\"In the real world, the faster you learn how to refuse appearance\nanxiety, the sooner you will enjoy life.\" 可以改为 \"In the real world,\nthe sooner you learn how to reject appearance anxiety, the sooner you\nwill enjoy life.\"</li>\n</ul></li>\n</ol>\n<h3 id=\"改正后的作文\">改正后的作文</h3>\n<p>People are now increasingly aware of the danger of 'appearance\nanxiety' or being obsessed with one's looks. This is a good thing. Being\nself-confident has played an important role in personal development in\nrecent years.</p>\n<p>There is a public debate today over appearance anxiety. Some people\nbelieve that too much appearance anxiety can not only destroy\nself-confidence but also reduce personal abilities and increase\nunhappiness. There is no doubt that when you put too much attention on\nappearance anxiety, you will always be tense in life. Other people claim\nthat some appearance anxiety can help people to be better in life. As I\nsee it, rejecting appearance anxiety is important for us to have a\nbetter life. We must learn to deal with the problems that arise when we\nface appearance anxiety. In recent years, we have faced many challenges\nin appearance anxiety. If we can learn how to deal with them, we will\nenjoy the pleasures and joys of the real world.</p>\n<p>All in all, everyone must reject appearance anxiety. In the real\nworld, the sooner you learn how to reject appearance anxiety, the sooner\nyou will enjoy life.</p>\n</blockquote>\n<p>People are now increasingly aware of the danger of 'appearance\nanxiety' or being obsessed with one's looks. This awareness is a\npositive development. Being self-confident has played an important role\nin personal development in recent years.</p>\n<p>There is a public debate today over appearance anxiety. Some believe\nthat excessive appearance anxiety can not only destroy self-confidence\nbut also reduce personal abilities and increase unhappiness. There is no\ndoubt that when you focus too much on appearance anxiety, you will\nalways be tense in life. Others claim that some degree of appearance\nanxiety can motivate people to improve themselves. In my view, rejecting\nappearance anxiety is crucial for leading a better life. We must learn\nto address the problems that arise when we face appearance anxiety. In\nrecent years, we have encountered many challenges related to appearance\nanxiety. If we can learn how to handle them, we will experience the true\npleasures and joys of the real world.</p>\n<p>In conclusion, everyone must reject appearance anxiety. In the real\nworld, the sooner you learn to reject appearance anxiety, the sooner you\nwill enjoy life.</p>\n<h3 id=\"section-3\">4.</h3>\n<p>Today more and more people begin to realize the pleasures and joy of\nreal-world social interaction.The ability of real-world social\ninteraction has played an important role in personal development in\nrecent years.</p>\n<p>There is a public debate today over social interaction .Some people\nbelieve social interation in the real world can ont only enhance\nself-confidence but also enhance personal abilities.There is no doubt\nthat when you communicate face-to-face with others, you will feel\npleasure and joy from the conversation.Other claim that too much real\nworld social interaction maybe bring the unpleasure and unhappy.As I see\nit, real world social interaction give rise to a number of problems.But\nit is something that we must learn to deal.In the recent life, we will\nface many unhappy things in the real world. If we can learn how to deal\nit or how to communicate with others, we will enjoy the pleasures and\njoy of real world.</p>\n<p>All in all, everyone must to communicate with other in the real\nworld. The faster you learn how to communicate with others, the faster\nyou enjoy real world social pleasure.</p>\n<blockquote>\n<h3 id=\"原文中的语法错误及改正-1\">原文中的语法错误及改正</h3>\n<ol type=\"1\">\n<li><strong>句子结构和动词形式</strong>：\n<ul>\n<li>\"The ability of real-world social interaction\" 应改为 \"The ability\nto engage in real-world social interaction\"。</li>\n<li>\"social interation\" 应改为 \"social interaction\"。</li>\n<li>\"ont only\" 应改为 \"not only\"。</li>\n<li>\"Other claim\" 应改为 \"Others claim\"。</li>\n<li>\"maybe bring the unpleasure and unhappy\" 应改为 \"may bring\nunpleasantness and unhappiness\"。</li>\n<li>\"real world social interaction give rise to a number of problems\"\n应改为 \"real-world social interaction gives rise to a number of\nproblems\"。</li>\n<li>\"But it is something that we must learn to deal\" 应改为 \"But it is\nsomething that we must learn to deal with\"。</li>\n<li>\"If we can learn how to deal it\" 应改为 \"If we can learn how to deal\nwith it\"。</li>\n<li>\"everyone must to communicate with other in the real world\" 应改为\n\"everyone must communicate with others in the real world\"。</li>\n</ul></li>\n<li><strong>单词拼写和使用</strong>：\n<ul>\n<li>\"unpleasure\" 应改为 \"unpleasantness\"。</li>\n<li>\"in the recent life\" 应改为 \"in recent life\"。</li>\n</ul></li>\n<li><strong>一致性和连贯性</strong>：\n<ul>\n<li>\"we will enjoy the pleasures and joy of real world\" 应改为 \"we will\nenjoy the pleasures and joys of the real world\"。</li>\n<li>\"The faster you learn how to communicate with others, the faster you\nenjoy real world social pleasure.\" 可以改为 \"The faster you learn how to\ncommunicate with others, the sooner you will enjoy the pleasures of\nreal-world social interaction.\"</li>\n</ul></li>\n</ol>\n<h3 id=\"改正后的作文-1\">改正后的作文</h3>\n<p>Today more and more people begin to realize the pleasures and joy of\nreal-world social interaction. The ability to engage in real-world\nsocial interaction has played an important role in personal development\nin recent years.</p>\n<p>There is a public debate today over social interaction. Some people\nbelieve social interaction in the real world can not only enhance\nself-confidence but also enhance personal abilities. There is no doubt\nthat when you communicate face-to-face with others, you will feel\npleasure and joy from the conversation. Others claim that too much\nreal-world social interaction may bring unpleasantness and unhappiness.\nAs I see it, real-world social interaction gives rise to a number of\nproblems. But it is something that we must learn to deal with. In recent\nlife, we will face many unhappy things in the real world. If we can\nlearn how to deal with them or how to communicate with others, we will\nenjoy the pleasures and joys of the real world.</p>\n<p>All in all, everyone must communicate with others in the real world.\nThe faster you learn how to communicate with others, the sooner you will\nenjoy the pleasures of real-world social interaction.</p>\n</blockquote>\n<p>Today, more and more people are beginning to realize the pleasures\nand joys of real-world social interaction. The ability to engage in such\ninteraction has played an important role in personal development in\nrecent years.</p>\n<p>There is a public debate today over social interaction. Some believe\nthat social interaction in the real world can not only enhance\nself-confidence but also improve personal abilities. There is no doubt\nthat face-to-face communication with others brings pleasure and joy from\nthe conversation. Others claim that excessive real-world social\ninteraction may lead to unpleasantness and unhappiness. In my view,\nwhile real-world social interaction presents certain challenges, it is\nessential that we learn to navigate them. In our recent experiences, we\nhave faced many difficulties in the real world. If we can learn how to\nhandle these challenges and communicate effectively with others, we will\nenjoy the true pleasures and joys of the real world.</p>\n<p>In conclusion, everyone must engage in real-world social interaction.\nThe faster you learn how to communicate with others, the sooner you will\nenjoy the pleasures of real-world social interaction.</p>\n<h3 id=\"section-4\">5.</h3>\n<p>Nowadays more and more people take delight in offering help to needy.\nBut giving a hand to the people who need help has played an important\nrole in personal development.</p>\n<p>There is a public debate today over offering help to the needy. Some\npeople think everyone should offer help to the needy in the world and\nthe believe the help can not only enhance self-confidence but also\nenhance personal abilities. There is no doubt that when you offer help\nto the needy, you will feel pleasure and joy from the process. Other\nclaim that usually offer help maybe bring the unpleasure and unhappy. As\nI see it, although always offer help to the needy give rise to a number\nof problems, it is something that we should learn to how to balance. In\nthe real world, if everyone both to offer help to the needy. I believe\nthe world will be beautiful.</p>\n<p>All in all, everyone should offer help to the needy in the real\nworld. The more help you offer, the more beautiful the world will\nbe.</p>\n<blockquote>\n<h3 id=\"改正后的作文-2\">改正后的作文</h3>\n<p>Nowadays, more and more people take delight in offering help to those\nin need. Helping people who need assistance has played an important role\nin personal development.</p>\n<p>There is a public debate today over offering help to the needy. Some\npeople think everyone should offer help to those in need in the world\nand believe that such help can not only enhance self-confidence but also\nenhance personal abilities. There is no doubt that when you offer help\nto the needy, you will feel pleasure and joy from the process. Others\nclaim that frequently offering help may bring unpleasantness and\nunhappiness. As I see it, although always offering help to the needy\ngives rise to a number of problems, it is something that we should learn\nhow to balance. In the real world, if everyone offers help to the needy,\nI believe the world will be beautiful.</p>\n<p>All in all, everyone should offer help to those in need in the real\nworld. The more help you offer, the more beautiful the world will\nbe.</p>\n<h3 id=\"主要改正点\">主要改正点</h3>\n<ol type=\"1\">\n<li><strong>文章开头</strong>：\n<ul>\n<li>\"giving a hand to the people who need help\" 改为 \"helping people who\nneed assistance\" 更加简洁和正式。</li>\n</ul></li>\n<li><strong>一致性和动词形式</strong>：\n<ul>\n<li>\"everyone should offer help to the needy in the world\" 改为\n\"everyone should offer help to those in need in the world\"\n使句子更加流畅。</li>\n<li>\"the believe the help\" 改为 \"believe that such help\"\n修正了定冠词和从句连接问题。</li>\n</ul></li>\n<li><strong>拼写和语法</strong>：\n<ul>\n<li>\"Other claim\" 改为 \"Others claim\" 。</li>\n<li>\"usually offer help maybe bring the unpleasure and unhappy\" 改为\n\"frequently offering help may bring unpleasantness and\nunhappiness\"。</li>\n<li>\"always offer help to the needy give rise to a number of problems\"\n改为 \"always offering help to the needy gives rise to a number of\nproblems\"。</li>\n<li>\"learn to how to balance\" 改为 \"learn how to balance\"。</li>\n<li>\"if everyone both to offer help to the needy\" 改为 \"if everyone\noffers help to the needy\"。</li>\n</ul></li>\n<li><strong>总结段</strong>：\n<ul>\n<li>\"everyone should offer help to the needy in the real world\" 改为\n\"everyone should offer help to those in need in the real world\"。</li>\n<li>\"the more beautiful the world will be\" 改为 \"the more beautiful the\nworld will be\" 保持一致性。</li>\n</ul></li>\n</ol>\n<p>通过这些改正，文章变得更加连贯、简洁和正式，表达更清晰明确。</p>\n</blockquote>\n<p>Nowadays, more and more people take delight in offering help to those\nin need. Helping people who need assistance plays an important role in\npersonal development.</p>\n<p>There is a public debate today over offering help to the needy. Some\npeople think everyone should offer help to those in need and believe\nthat such help can not only enhance self-confidence but also improve\npersonal abilities. There is no doubt that when you offer help to the\nneedy, you will feel pleasure and joy from the process. Others claim\nthat frequently offering help may bring unpleasantness and unhappiness.\nAs I see it, although always offering help to the needy gives rise to a\nnumber of problems, it is something that we should learn how to balance.\nIn the real world, if everyone offers help to the needy, I believe the\nworld will be beautiful.</p>\n<p>All in all, everyone should offer help to those in need. The more\nhelp you offer, the more beautiful the world will be.</p>\n<h3 id=\"section-5\">6.</h3>\n<p>Nowadays more and more people keep learning new skills to adapt to a\nfast-changing world. As we know, keep learning new skills has played an\nimportant role in the fast-changing world.</p>\n<p>There is a public debate today over new skills the people will learn\nin the fast-changing world. Some people believe the new skills can not\nonly enhance self-confidence in the fast-changing world but also enhance\npersonal abilities to adapt the real world. There is no doubt that when\nyou always learn new skills to keep yourself to adapt to a fast-changing\nworld,you will fell pleasure and joy from this process.Other claim that\nmany people may feel unpleasure and failure from the process that learn\nnew skills.As I see it, learning new skills give rise to a number of\nproblems. But it is something that we must learn to deal in the\nfast-changing world. If we learn how to deal with it or how to learn new\nskills fastly, we will enjoy the pleasure and joy from the fast-changing\nworld.</p>\n<p>All in all, everyone must to learn new skills in the fast-changing\nworld. The faster you learn how to keep learning new skills, the faster\nyou develop your enablement.</p>\n<blockquote>\n<h3 id=\"改正后的作文-3\">改正后的作文</h3>\n<p>Nowadays, more and more people keep learning new skills to adapt to a\nfast-changing world. As we know, continuously learning new skills has\nplayed an important role in personal development in this fast-changing\nworld.</p>\n<p>There is a public debate today over the new skills people need to\nlearn to keep up with the fast-changing world. Some people believe that\nnew skills can not only enhance self-confidence but also improve\npersonal abilities to adapt to the real world. There is no doubt that\nwhen you consistently learn new skills to adapt to a fast-changing\nworld, you will feel pleasure and joy from this process. Others claim\nthat many people may feel frustration and failure from the process of\nlearning new skills. As I see it, learning new skills gives rise to a\nnumber of challenges. However, it is something that we must learn to\ndeal with in the fast-changing world. If we learn how to handle these\nchallenges and how to learn new skills quickly, we will enjoy the\npleasure and joy from adapting to the fast-changing world.</p>\n<p>All in all, everyone must learn new skills in the fast-changing\nworld. The faster you learn how to keep acquiring new skills, the faster\nyou will develop your capabilities.</p>\n<h3 id=\"主要改正点-1\">主要改正点</h3>\n<ol type=\"1\">\n<li><strong>文章开头</strong>：\n<ul>\n<li>\"keep learning new skills\" 改为 \"continuously learning new skills\"\n更加正式和准确。</li>\n<li>\"played an important role in the fast-changing world\" 改为 \"played\nan important role in personal development in this fast-changing world\"\n增加了句子的完整性。</li>\n</ul></li>\n<li><strong>一致性和动词形式</strong>：\n<ul>\n<li>\"new skills the people will learn\" 改为 \"the new skills people need\nto learn\" 使句子更连贯。</li>\n<li>\"enhance personal abilities to adapt the real world\" 改为 \"improve\npersonal abilities to adapt to the real world\" 修正了介词使用错误。</li>\n</ul></li>\n<li><strong>拼写和语法</strong>：\n<ul>\n<li>\"to keep yourself to adapt to a fast-changing world\" 改为 \"to adapt\nto a fast-changing world\" 删除冗余部分。</li>\n<li>\"fell pleasure and joy\" 改为 \"feel pleasure and joy\"\n修正拼写错误。</li>\n<li>\"Other claim\" 改为 \"Others claim\"。</li>\n<li>\"unpleasure and failure\" 改为 \"frustration and failure\"\n使用更合适的词汇。</li>\n<li>\"learning new skills give rise to\" 改为 \"learning new skills gives\nrise to\" 修正动词和主语一致性。</li>\n<li>\"learn to deal in the fast-changing world\" 改为 \"learn to deal with\nin the fast-changing world\"。</li>\n<li>\"learn new skills fastly\" 改为 \"learn new skills quickly\"\n修正副词使用错误。</li>\n</ul></li>\n<li><strong>总结段</strong>：\n<ul>\n<li>\"must to learn\" 改为 \"must learn\" 删除多余的 \"to\"。</li>\n<li>\"keep learning new skills\" 改为 \"keep acquiring new skills\"\n使用更合适的动词。</li>\n<li>\"develop your enablement\" 改为 \"develop your capabilities\"\n使用更合适的词汇。</li>\n</ul></li>\n</ol>\n<p>通过这些改正，文章变得更加连贯、简洁和正式，表达更清晰明确。</p>\n</blockquote>\n<p>Nowadays, more and more people keep learning new skills to adapt to a\nfast-changing world. As we know, continuously learning new skills plays\nan important role in personal development in this dynamic\nenvironment.</p>\n<p>There is a public debate today over the new skills people need to\nlearn to keep up with this fast-changing world. Some people believe that\nacquiring new skills can not only enhance self-confidence but also\nimprove personal abilities to adapt to the real world. There is no doubt\nthat when you consistently learn new skills to adapt to a fast-changing\nworld, you will feel pleasure and joy from this process. Others claim\nthat many people may feel frustration and failure during the process of\nlearning new skills. As I see it, learning new skills presents a number\nof challenges. However, it is something that we must learn to deal with\nin this fast-changing world. If we learn how to handle these challenges\nand how to acquire new skills quickly, we will enjoy the pleasure and\njoy of adapting to the fast-changing world.</p>\n<p>All in all, everyone must learn new skills in the fast-changing\nworld. The faster you learn how to keep acquiring new skills, the faster\nyou will develop your capabilities.</p>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2024/05/06/%E5%8A%9B%E6%89%A3/",
            "url": "https://chnhqz.github.io/2024/05/06/%E5%8A%9B%E6%89%A3/",
            "title": "力扣",
            "date_published": "2024-05-06T02:20:46.000Z",
            "content_html": "<h2 id=\"哈希\">1.哈希</h2>\n<h4 id=\"两数之和\">1.两数之和</h4>\n<p>如果直接暴力很简单，但是时间复杂度为 <span\nclass=\"math inline\">\\(O(n)\\)</span>\n。这里其实时间的复杂度主要来自于内层循环的复杂度，外层循环，的 <span\nclass=\"math inline\">\\(O(n)\\)</span> 时间复杂度是不可避免的，对于 <span\nclass=\"math inline\">\\(nums[i]\\)</span> 来说，我们在数组中找到一个数等于\n<span class=\"math inline\">\\(target - nums[i]\\)</span>\n。只是循环的话，还是 <span class=\"math inline\">\\(O(n)\\)</span>\n的时间复杂度，我们可以使用哈希的方法，直接用 <span\nclass=\"math inline\">\\(O(1)\\)</span> 的时间复杂度找到 <span\nclass=\"math inline\">\\(target - nums[i]\\)</span> 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 找一个键值为 target - nums[i] 的索引</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it  = mp.<span class=\"built_in\">find</span>(target - nums[i]);</span><br><span class=\"line\">            <span class=\"comment\">// 如果找到了键值为 target - nums[i] 的索引，那么返回答案</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it != mp.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mp[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字母异位词分组\">49.字母异位词分组</h4>\n<p>我们可以选择将排序后的字符串作为键，无序的字符串作为键值\n<code>unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</code>\n这样遍历一边字符串，就可以筛选出所有的答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string&gt;&gt; <span class=\"built_in\">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class=\"line\">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (string&amp; str : strs) &#123;</span><br><span class=\"line\">            string key = str;</span><br><span class=\"line\">            <span class=\"built_in\">sort</span>(key.<span class=\"built_in\">begin</span>(), key.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            mp[key].<span class=\"built_in\">emplace_back</span>(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = mp.<span class=\"built_in\">begin</span>(); it != mp.<span class=\"built_in\">end</span>(); it++) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">emplace_back</span>(it-&gt;second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最长连续序列\">128.最长连续序列</h4>\n<p>首先我们考虑枚举数组中的每个数 <span class=\"math inline\">\\(x\\)</span>\n。考虑不断尝试 <span class=\"math inline\">\\(x+1,x+2,x+3,...\\)</span>\n是否存在。对于匹配的过程，直接的方法是 <span\nclass=\"math inline\">\\(O(n)\\)</span>\n遍历数组去看是否存在这个数，但是我们可以使用更高效的方法，用一个哈希表存储数组中的数，这样查看一个数是否存在能优化至\n<span class=\"math inline\">\\(O(1)\\)</span> 的时间复杂度。</p>\n<p>但是仅仅这样，我们的算法时间复杂度最坏情况还是会达到 <span\nclass=\"math inline\">\\(O(n^2)\\)</span> （即外层需要枚举 <span\nclass=\"math inline\">\\(n\\)</span> 个数，内层也需要暴力匹配 <span\nclass=\"math inline\">\\(n\\)</span> 次）。这样无法满足题目时间复杂度 <span\nclass=\"math inline\">\\(O(n)\\)</span>\n的要求。但是我们仔细分析这个枚举的过程，我们会发现其实我们进行了很多不必要的枚举，如果已知有一个\n<span class=\"math inline\">\\(x, x+1, x+2, ..., x+y\\)</span>\n的连续序列，而我们在下一个数字 <span class=\"math inline\">\\(x+ 2\\)</span>\n的时候仍然一个一个的枚举，这样得到的结果是一定不会优于以 <span\nclass=\"math inline\">\\(x\\)</span>\n为起点的的答案的。所以我们需要在外层判断 <code>x - 1</code>\n是否在数组中存在，如果存在，那么他就是已经判断过的，不需要在判断，直接跳过即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">int</span>&gt; num_set;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : nums) &#123;</span><br><span class=\"line\">            num_set.<span class=\"built_in\">insert</span>(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> longestStreak = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : num_set) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!num_set.<span class=\"built_in\">count</span>(num - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> currentNum = num;</span><br><span class=\"line\">                <span class=\"type\">int</span> currentStreak = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (num_set.<span class=\"built_in\">count</span>(currentNum + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    currentNum += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    currentStreak += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                longestStreak = <span class=\"built_in\">max</span>(longestStreak, currentStreak);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestStreak;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双指针\">2.双指针</h2>\n<h4 id=\"移动零\">283.移动零</h4>\n<p>双指针，<code>left</code> 和 <code>right</code> 当<code>left</code>\n为0时，<code>right</code>找到<code>left</code>后边第一个不为零的数字进行交换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">1</span>; left &lt; right &amp;&amp; right &lt; nums.<span class=\"built_in\">size</span>(); ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[left] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (right &lt; nums.<span class=\"built_in\">size</span>() &amp;&amp; nums[right] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    right ++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == nums.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                nums[left] = nums[right];</span><br><span class=\"line\">                nums[right] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left ++;</span><br><span class=\"line\">            right ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"盛最多水的容器\">11.盛最多水的容器</h4>\n<p>这道题目，观察数据的规模，如果采用暴力的双层<code>for</code>循环进行枚举，那么时间复杂度一定超标。这里我们观察，是解决两条线之间的面积最大的问题，那么自然而然想到可以使用双指针来解决，我们接下来注意如何解决指针的移动，首先在<code>height[0]</code>\n和 <code>height[8]</code>之间指针如何移动呢？此时指针\n<code>height[0] &lt; height[8]</code> 那就是说我们此时找到比\n<code>height[0]</code>大的值即可。可以照样理解，我们此时在数组中寻找只要比\n<code>height[8]</code>小的值，那么面积一定比此时面积小，所以我们选择移动两个数值之间较小的数字，这样才有可能出现比现在大的面积。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, <span class=\"built_in\">min</span>(height[left], height[right]) * (right - left));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &gt; height[right]) right --;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> left ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三数之和\">15.三数之和</h4>\n<p>利用双指针进行时间复杂度的压缩，首先我们对数组进行排序，这样可以方便后续进行左右指针的移动。排序后，我们要对数组中一样的数字进行去重，<code>if (i - 1 &gt;= 0 &amp;&amp; nums[i] == nums[i - 1]) continue</code>\n这句代码就是进行去重的代码。之后我们定义左指针指向<code>nums[i]</code>\n的下一个数字，右指针指向最后一个数字。定义 <code>target</code>\n为目标数字，这样我们就可以用二分查找的方法进行时间复杂度的压缩，我们将三数之和问题转化为两个数字的和等于\n<code>-nums[i]</code> 。我们计算这个和<code>sum</code>。如果这个和\n<code>sum &gt; 0</code> <code>right--</code> 否则 <code>left++</code>\n。但是这里有个问题，就是会有一样的数字造成答案数组重复。所以我们要进行一样的数字跳过的操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">threeSum</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> left = i + <span class=\"number\">1</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> target = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> sum = target + nums[left] + nums[right];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">0</span>) right--;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) left++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(&#123;target, nums[left], nums[right]&#125;);</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (left ++; left &lt; right &amp;&amp; nums[left] == nums[left - <span class=\"number\">1</span>]; left++);</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (right--; left &lt; right &amp;&amp; nums[right] == nums[right + <span class=\"number\">1</span>]; right--);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"接雨水\">42.接雨水</h4>\n<figure>\n<img loading=\"lazy\" data-src=\"截屏2024-05-06%2010.21.59.png\"\nalt=\"截屏2024-05-06 10.21.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-05-06 10.21.59</figcaption>\n</figure>\n<p>这里我们将每一块区域都视为一个底边长度为<code>1</code>\n的木桶，这是木桶的容水量为\n<code>min(左边最高的木板，右边最高的木板)- height[i]</code>\n那么如何求对于一个位置的左边最高木板和右边最高木板呢？这里我们用到前后缀的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0 1 1 2 2 2 2 3 3 3 3 3</span></span><br><span class=\"line\"><span class=\"comment\">// 3 3 3 3 3 3 3 3 2 2 2 1</span></span><br><span class=\"line\"><span class=\"comment\">// 0 0 1 0 1 2 1 0 0 1 0 0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">trap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">pre_max</span><span class=\"params\">(height.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">suf_max</span><span class=\"params\">(height.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        pre_max[<span class=\"number\">0</span>] = height[<span class=\"number\">0</span>];</span><br><span class=\"line\">        suf_max[height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>] = height[height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; height.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            pre_max[i] = <span class=\"built_in\">max</span>(pre_max[i - <span class=\"number\">1</span>], height[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = height.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            suf_max[i] = <span class=\"built_in\">max</span>(suf_max[i + <span class=\"number\">1</span>], height[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; height.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            res += <span class=\"built_in\">min</span>(pre_max[i], suf_max[i]) - height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>相向双指针的做法</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">trap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>, right = height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, pre_max = <span class=\"number\">0</span>, suf_max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            pre_max = <span class=\"built_in\">max</span>(pre_max, height[left]);</span><br><span class=\"line\">            suf_max = <span class=\"built_in\">max</span>(suf_max, height[right]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre_max &lt; suf_max) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 左边木桶的容量就知道了</span></span><br><span class=\"line\">                res += pre_max - height[left];</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res += suf_max - height[right];</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"滑动窗口\">3.滑动窗口</h2>\n<h4 id=\"无重复字符的最长字串\">3.无重复字符的最长字串</h4>\n<p>滑动窗口，利用集合维护一个没有重复字符的字符串，不断枚举右指针指向的字符，并在集合中判断它在所维护的字符串中是否出现过，如果出现过，就不断移动所维护的字符串的左边界，使得所维护的字符串中没有与此时右指针指向的字符串重复的字符。然后插入右指针指向的字符，更新答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">char</span>&gt; st;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> right = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>; right &lt; s.<span class=\"built_in\">size</span>(); right++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不断滑动右指针，直到当前右指针指向的字符没有重复</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (st.<span class=\"built_in\">count</span>(s[right])) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前右指针指向的字符在st中有重复的，所以不断滑动左指针，并擦去st中的左指针字符</span></span><br><span class=\"line\">                st.<span class=\"built_in\">erase</span>(s[left++]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 当滑动完成，此时右指针指向的字符在st中没有重复的，插入右指针的字符 更新答案</span></span><br><span class=\"line\">            st.<span class=\"built_in\">insert</span>(s[right]);</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"找到字符串中所有字母异位词\">438.找到字符串中所有字母异位词</h4>\n<p>首先我想到的是暴力解法，利用每次在<code>s</code>中截取一段长度等于<code>p</code>的子字符串。然后比较两个字符串是否是异位字符串。这种方法比较直接，实现起来也没有难度。我用的是字典来比较字符串是否是异位字符串，但是时间复杂度很高。不出意料的超时了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">findAnagrams</span><span class=\"params\">(string s, string p)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map &lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; mp_1;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; p.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            mp_1[p[i]] ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector &lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        unordered_map &lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; mp_2;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = p.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; right &lt; s.<span class=\"built_in\">size</span>();left++, right++) &#123;</span><br><span class=\"line\">            mp_2.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class=\"line\">                mp_2[s[i]]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> mp_1_ : mp_1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mp_2[mp_1_.first] != mp_1_.second) &#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>接着想，这个解法中可以优化的点在哪里？首先分析时间复杂度，一个最外层的循环，内部是有两个循环，一个循环记录当前的子字符串的字典集合，另外一个循环进行比较两个字符串。最坏的情况就是\n<span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>此时其实有一个可以优化的点，就是不需要每次重复循环计算<code>mp_2</code>，我们只需要减去上次的左端点，在加上这次的右端点即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">findAnagrams</span><span class=\"params\">(string s, string p)</span> </span>&#123;</span><br><span class=\"line\">        vector &lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.<span class=\"built_in\">size</span>() &lt; p.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        unordered_map &lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; mp_1;</span><br><span class=\"line\">        unordered_map &lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; mp_2;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; p.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            mp_1[p[i]] ++;</span><br><span class=\"line\">            mp_2[s[i]] ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = p.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; right &lt; s.<span class=\"built_in\">size</span>();left++, right++) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                mp_2[s[left - <span class=\"number\">1</span>]] --;</span><br><span class=\"line\">                mp_2[s[right]] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> mp_1_ : mp_1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mp_2[mp_1_.first] != mp_1_.second) &#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>经过这次优化，就通过了。</p>\n<h2 id=\"子串\">子串</h2>\n<h4 id=\"和为k的子数组\">560.和为k的子数组</h4>\n<p>首先想到暴力解决的方法，我们遍历整个数组，依次计算从 <code>i</code>\n到<code>j</code> 之间的和，然后与 <code>k</code> 进行大小的比较。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cla_nums_i_j</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class=\"line\">            res += nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;<span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt;= j) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">cla_nums_i_j</span>(nums, i, j); </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dp[i][j] == k) &#123;  </span><br><span class=\"line\">                        res ++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>很明显，这样的时间复杂度至少为 <span\nclass=\"math inline\">\\(O(n^2)\\)</span>\n（没有计算<code>cla_nums_i_j</code>的时间复杂度）。所以这样是一定会超时的，我们需要进行优化。首先我们有必要逐个计算<code>dp[i][j]</code>\n吗？我们能否只计算其他的值，然后用这些值把所有的值推算出来？例如<code>dp[i][j] = dp[0][j] - dp[0][i]</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cla_nums_i_j</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class=\"line\">            res += nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">cla_nums_i_j</span>(nums, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[i] == k) &#123;</span><br><span class=\"line\">                res ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[j] - dp[i - <span class=\"number\">1</span>] == k) &#123;</span><br><span class=\"line\">                    res ++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这次进行了简单的优化，但是仍然使用了双层循环来进行<code>i~j</code>\n之间的元素和的判断。这次通过了<code>87/93</code>\n个样例。仍然是时间复杂度过高。还有优化的空间，我在计算<code>dp[i]</code>时每次都调用了<code>cla_nums_i_j</code>\n这里每次都有重复计算。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            tmp += nums[i];</span><br><span class=\"line\">            dp[i] = tmp;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[i] == k) &#123;</span><br><span class=\"line\">                res ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[j] - dp[i - <span class=\"number\">1</span>] == k) &#123;</span><br><span class=\"line\">                    res ++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这次通过了，但是时间复杂度仍然很高*_*!。</p>\n<h2 id=\"动态规划\">动态规划</h2>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/image-20240624100453657.png\"\nalt=\"image-20240624100453657\" />\n<figcaption aria-hidden=\"true\">image-20240624100453657</figcaption>\n</figure>\n<p><strong>完全背包理论</strong></p>\n<p>有 <span class=\"math inline\">\\(N\\)</span> 件物品和一个最多能背重量为\n<span class=\"math inline\">\\(W\\)</span> 的背包。第 <span\nclass=\"math inline\">\\(i\\)</span> 件物品的重量是 <span\nclass=\"math inline\">\\(weight[i]\\)</span> ，得到的价值是 <span\nclass=\"math inline\">\\(value[i]\\)</span>\n。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。<strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>\n<p><strong>01背包遍历顺序的核心思路</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\"> \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\"> \t\tdp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内层的循环，从大到小遍历，为了保证每个物品仅被添加一次。</p>\n<p><strong>完全背包核心思路</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先遍历物品，再遍历背包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\"> \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = weight[i]; j &lt; bagWeight ; j++) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\"> \t\tdp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"零钱兑换ii\">518.零钱兑换II</h4>\n<p><code>vector&lt;int&gt;dp(amount + 1, 0);</code> <code>dp[i]</code>\n表示当前 <code>amount</code> 为 <code>i</code> ，有 <code>dp[i]</code>\n种方法可以凑成 <code>i</code>\n。由于每种硬币可以使用无限次。所以这是一个完全背包题目。先进行物品的遍历，之后进行背包容量的遍历。</p>\n<p><strong>递推公式</strong></p>\n<blockquote>\n<p><code>dp[j]</code> （考虑<code>coins[i]</code>的组合总和）就是所有的\n<code>dp[j - coins[i]]</code> 相加</p>\n<p>例如在考虑第一层循环时\n<code>dp[5] = dp[0] + dp[1] + dp[2] + d[3] + dp[4]</code></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, vector&lt;<span class=\"type\">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;<span class=\"built_in\">dp</span>(amount + <span class=\"number\">1</span>, <span class=\"number\">0</span>); <span class=\"comment\">// dp[j]表示当前amount为j，有dp[j]种方法可以凑成j。</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; coins.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class=\"line\">                dp[j] += dp[j - coins[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里外层循环只能是物品，因为如果外层是背包容量的话，我们计算的是排列数。</p>\n<h4 id=\"组合总合iv\">377.组合总合IV</h4>\n<p>这道题目跟前一个题目（518.零钱兑换II）不一样的点在于，这个题目的顺序不同的序列被视为不同的组合。这道题目我们将背包容量放到外层循环。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">combinationSum4</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">unsigned</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(target + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= target; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - nums[i] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dp[j] += dp[j - nums[i]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这道题目还有一种 <code>DFS</code> 的解法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp;nums, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> target, <span class=\"type\">int</span> end, <span class=\"type\">int</span> *res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt;= target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">                (*res)++;</span><br><span class=\"line\">                cout &lt;&lt; *res &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; end; i++) &#123;</span><br><span class=\"line\">            sum += nums[i];</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(nums, sum, target, end, res);</span><br><span class=\"line\">            sum -= nums[i];</span><br><span class=\"line\">            cout &lt;&lt; nums[i] &lt;&lt; <span class=\"string\">&quot;|&quot;</span>&lt;&lt; sum &lt;&lt;<span class=\"string\">&quot;|&quot;</span>&lt;&lt;*res &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">combinationSum4</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">DFS</span>(nums, sum, target, nums.<span class=\"built_in\">size</span>(), &amp;res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"单词拆分\">139.单词拆分</h4>\n<p><code>dp[i]</code> 代表字符串<code>i</code>\n前边的字符串能够被拼接出来。只有当 <code>dp[j]</code> 为真，且\n在字符串列表内能够找到 <code>s[j, i - j]</code> 的字符时\n<code>dp[i]</code> 才为真。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">wordBreak</span><span class=\"params\">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> wordDictSet = unordered_set &lt;string&gt; ();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> word : wordDict) wordDictSet.<span class=\"built_in\">insert</span>(word);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> dp = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(s.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= s.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[j] &amp;&amp; wordDictSet.<span class=\"built_in\">find</span>(s.<span class=\"built_in\">substr</span>(j ,i - j)) != wordDictSet.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    dp[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编辑距离\">72.编辑距离</h4>\n<p>给出两个单词<code>word1</code>和<code>word2</code>，返回将\n<code>word1</code> 转换为 <code>word2</code>\n所使用的最小操作次数。这里单词之间的转换有三种方式</p>\n<ol type=\"1\">\n<li>删除</li>\n<li>插入</li>\n<li>替换</li>\n</ol>\n<p><code>dp[i][j]</code>代表 <code>word1[0 ~ i]</code> 转换为\n<code>word[0 ~ j]</code> 所用的最少操作数</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>0</th>\n<th>r - 1</th>\n<th>o - 2</th>\n<th>s - 3</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>h - 1</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr class=\"even\">\n<td>o - 2</td>\n<td>2</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr class=\"odd\">\n<td>r - 3</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr class=\"even\">\n<td>s - 4</td>\n<td>3</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr class=\"odd\">\n<td>e - 5</td>\n<td>4</td>\n<td>4</td>\n<td><strong>3</strong></td>\n</tr>\n</tbody>\n</table>\n<p>根据这个图可以明显看出，当 <code>word1[i] == word2[j]</code>\n时，<code>dp[i][j] = dp[i - 1][j - 1]</code>\n这也就是说我们可以确定一个状态转换 <span class=\"math display\">\\[\ndp[i][j] = dp[i - 1][j - 1] \\qquad word1[i] == word2[j]\n\\]</span> 接下来我们需要判断当 <code>word1[i] != word2[j]</code>\n时的情况，我们很容易写出 <span class=\"math display\">\\[\ndp[i][j] = \\min (dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\\qquad word1[i] != word2[j]\n\\]</span> 但是，这其中代表什么意思？<code>dp[i - 1][j]</code>\n从表格中可以看出，是 <code>h -&gt; ros</code> 的次数，而它的下一步变换\n<code>ho -&gt; ros</code> 。如果 <code>ho - &gt; ros</code> 的状态可以从\n<code>h - &gt; ros</code> 转化，那么也就是说不需要使用 <code>o</code>\n。也就是删除了 <code>o</code> 。所以这个\n<code>dp[i][j] = dp[i - 1][j]</code> 代表删除。同理\n<code>hor -&gt; ros = hor -&gt; ro</code> 代表插入<code>r</code>\n。<code>hor -&gt; ros = ho -&gt; ro</code> 代表替换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(string word1, string word2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> len_word1 = word1.<span class=\"built_in\">size</span>(), len_word2 = word2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len_word1 == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> len_word2;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 代表 word1[0 ~ i] 转换为 word[0 ~ j] 所用的最少操作数</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;<span class=\"built_in\">dp</span>(len_word1 + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(len_word2 + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; dp.size() &lt;&lt; &quot; &quot; &lt;&lt; dp[0].size() &lt;&lt; endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= len_word1; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= len_word2; j++) &#123;</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][j] = j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (word1[i - <span class=\"number\">1</span>] == word2[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    cout &lt;&lt; <span class=\"string\">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;j:&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">min</span>(<span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]), dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_word1][len_word2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"区间dp\">区间DP</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26%2015.46.24.png\"\nalt=\"截屏2024-06-26 15.46.24\" />\n<figcaption aria-hidden=\"true\">截屏2024-06-26 15.46.24</figcaption>\n</figure>\n<h4 id=\"最长回文子序列\">516.最长回文子序列</h4>\n<p><strong>思路一：</strong></p>\n<p>求 <code>s</code> 和反转后的 <code>s</code> 的 <code>LCS</code></p>\n<h4 id=\"lcs\">1143.LCS</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(string text1, string text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> text1Len = text1.<span class=\"built_in\">size</span>(), text2Len = text2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> dp[text1Len + <span class=\"number\">1</span>][text2Len + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= text1Len; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= text2Len; j++) dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; text1Len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; text2Len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text1[i] == text2[j]) dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i][j + <span class=\"number\">1</span>], dp[i + <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[text1Len][text2Len];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(string&amp; text1, string&amp; text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> len_text1 = text1.<span class=\"built_in\">size</span>(), len_text2 = text2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 定义 dp[i][j] 代表 text1[0, i - 1] 和 text2[0, j - 1] 之间的最长公共子序列长度</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(len_text1 + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(len_text2 + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; len_text1; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; len_text2; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text1[i] == text2[j]) &#123;</span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i + <span class=\"number\">1</span>][j], dp[i][j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len_text1][len_text2];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestPalindromeSubseq</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string s1 = s;</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(s1.<span class=\"built_in\">begin</span>(),s1.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">longestCommonSubsequence</span>(s, s1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>思路二：</strong></p>\n<p>【选或不选】从两侧向内缩小问题规模</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26%2015.49.28.png\"\nalt=\"截屏2024-06-26 15.49.28\" />\n<figcaption aria-hidden=\"true\">截屏2024-06-26 15.49.28</figcaption>\n</figure>\n<p>（类似LCS）定义 <code>dfs(i,j)</code> 表示从 <code>s[i]</code> 到\n<code>s[j]</code> 的最长回文子序列的长度</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-06-26 15.51.46.png\" alt=\"截屏2024-06-26 15.51.46\" style=\"zoom:50%;\" /></p>\n<p>递归边界 ： <span class=\"math display\">\\[\ndfs(i,i) = 1 \\\\\ndfs(i + 1, i) = 0\n\\]</span> 递归入口：<span class=\"math inline\">\\(dfs(0, n -\n1)\\)</span></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> begin, <span class=\"type\">int</span> end, string&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (begin == end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (begin &gt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[begin] == s[end]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(begin + <span class=\"number\">1</span>, end - <span class=\"number\">1</span>, s) + <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">dfs</span>(begin + <span class=\"number\">1</span>, end, s), <span class=\"built_in\">dfs</span>(begin, end - <span class=\"number\">1</span>, s));</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestPalindromeSubseq</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>循环的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestPalindromeSubseq</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 代表从 i 到 j 之间的最大回文子序列长度</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(s.<span class=\"built_in\">size</span>(), <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(s.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; s.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] == s[j]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">max</span>(dp[i + <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestPalindromeSubseq</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> len = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> dp[len + <span class=\"number\">1</span>][len + <span class=\"number\">1</span>];   <span class=\"comment\">// dp[i][j] 为 i 到 j 之间最长回文子序列的长度</span></span><br><span class=\"line\">        <span class=\"comment\">// 递推公式 ：if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2</span></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= len; i++) </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == j) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = len - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] == s[j]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">max</span>(dp[i + <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][len - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"lcr-回文子串\">020.LCR 回文子串</h4>\n<p>也是同样的方法，<code>dp[i][j]</code> 表示 <code>[i,j]</code>\n之间的字符串是不是回文字符串。如果是，或者<code>j - i == 1</code>就是指两个只相差一个字符，那么\n此时回文子串的数量就加一。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(s.<span class=\"built_in\">size</span>(), <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(s.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; s.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] == s[j] &amp;&amp; (j - i == <span class=\"number\">1</span> || dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] == <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    res ++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res + s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"每日一题\">每日一题</h2>\n<h4 id=\"轮转数组\">189.轮转数组</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pair;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> second = nums[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> first = (i + k) % nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"comment\">// pair.insert(&#123;first, second&#125;);</span></span><br><span class=\"line\">            pair[first] = second;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cout &lt;&lt; pair.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> pair_ : pair) &#123;</span><br><span class=\"line\">            nums[pair_.first] = pair_.second;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"合并区间\">56.合并区间</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">merge</span>(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(), intervals.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp;a, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp;b) &#123;<span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] &lt; b[<span class=\"number\">0</span>]; &#125;);</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res_tmp;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; intervals.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            res_tmp.<span class=\"built_in\">push_back</span>(intervals[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;intervals[i][0]:&quot;</span> &lt;&lt; intervals[i][<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"type\">int</span> end = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            cnt = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (cnt; cnt &lt; intervals.<span class=\"built_in\">size</span>(); cnt ++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (end &gt;= intervals[cnt][<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (end &lt;= intervals[cnt][<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        end = intervals[cnt][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res_tmp.<span class=\"built_in\">push_back</span>(end);</span><br><span class=\"line\">            i = cnt - <span class=\"number\">1</span>;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(res_tmp);</span><br><span class=\"line\">            res_tmp.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4\nid=\"年5月24日-1673.找出最具竞争力的子序列\">2024年5月24日-1673.找出最具竞争力的子序列</h4>\n<p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>\n，返回长度为 <code>k</code> 且最具 <strong>竞争力</strong> 的\n<code>nums</code> 子序列。</p>\n<p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p>\n<p>在子序列 <code>a</code> 和子序列 <code>b</code>\n第一个不相同的位置上，如果 <code>a</code> 中的数字小于 <code>b</code>\n中对应的数字，那么我们称子序列 <code>a</code> 比子序列\n<code>b</code>（相同长度下）更具 <strong>竞争力</strong> 。\n例如，<code>[1,3,4]</code> 比 <code>[1,3,5]</code>\n更具竞争力，在第一个不相同的位置，也就是最后一个位置上， <code>4</code>\n小于 <code>5</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,5,2,6], k = 2</span><br><span class=\"line\">输出：[2,6]</span><br><span class=\"line\">解释：在所有可能的子序列集合 &#123;[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]&#125; 中，[2,6] 最具竞争力。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,4,3,3,5,4,9,6], k = 4</span><br><span class=\"line\">输出：[2,3,3,4]</span><br></pre></td></tr></table></figure>\n<p>能够想到使用单调栈来进行单调递增数组的维护。比如<code>nums = [3, 5, 2, 6]</code>\n可以计算出此时对于这个数组的单调递增数组序列为<code>[2, 6]</code>\n。同理此时 <code>nums = [2, 4, 3, 3, 5, 4, 9, 6]</code>\n可以计算出单调递增数组序列为<code>[2, 3, 3, 4, 6]</code> 。然后截取前\n<code>k</code>个数字。由此可以知道，单调栈其实是符合这道题目的思想的。但是题目中有要求返回的数组的长度必须是\n<code>k</code>。这就造成这种解法的局限性，比如<code>nums = [2, 4, 3, 3, 5, 4, 9, 6, 1]</code>\n这种情况就无法解出正确答案，我们需要在每次维护单调栈的时候加入判断条件，就是栈顶元素出栈的时候，此时栈内元素数量加上数组<code>nums</code>\n剩余元素的数量是否大于<code>k</code>。如果比<code>k</code>小，那么此时就不能出栈。</p>\n<p>我们在实现的时候可以直接用<code>vector</code>进行栈操作的模拟。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">mostCompetitive</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.<span class=\"built_in\">size</span>() == k) <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">        </span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> x = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!res.<span class=\"built_in\">empty</span>() &amp;&amp; x &lt; res.<span class=\"built_in\">back</span>() &amp;&amp; res.<span class=\"built_in\">size</span>() + nums.<span class=\"built_in\">size</span>() - i &gt; k) &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res.<span class=\"built_in\">size</span>() &lt; k) &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态规划-1\">1.动态规划</h3>\n<h5 id=\"回文串判定\">回文串判定</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">longestPalindrome</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> begin = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n));</span><br><span class=\"line\">        <span class=\"comment\">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 递推开始</span></span><br><span class=\"line\">        <span class=\"comment\">// 先枚举子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> L = <span class=\"number\">2</span>; L &lt;= n; L++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class=\"line\">                <span class=\"type\">int</span> j = L + i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果右边界越界，就可以退出当前循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt;= n) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] != s[j]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j - i &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; maxLen) &#123;</span><br><span class=\"line\">                    maxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    begin = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.<span class=\"built_in\">substr</span>(begin, maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> * <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(<span class=\"type\">char</span> * s)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> maxLen = <span class=\"number\">1</span>, start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> dp[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];                             <span class=\"comment\">//用来记录字串是否是回文串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1005</span>; i++)</span><br><span class=\"line\">        dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> L = <span class=\"number\">2</span>; L &lt;= len; L++) &#123;            <span class=\"comment\">//枚举字串长度</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;          <span class=\"comment\">//枚举左边界</span></span><br><span class=\"line\">                <span class=\"type\">int</span> j = L + i - <span class=\"number\">1</span>;                  <span class=\"comment\">//生成右边界</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt;= len) <span class=\"keyword\">break</span>;                <span class=\"comment\">//如果右边界越界则循环退出</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] != s[j]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"number\">0</span>;                   <span class=\"comment\">//此时s[i][j]字串不是回文串</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j - i &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; (j - i + <span class=\"number\">1</span>) &gt; maxLen) &#123;</span><br><span class=\"line\">                    start = i;</span><br><span class=\"line\">                    maxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s[maxLen + start] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;s[start];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"字符串中的额外字符\">2707.字符串中的额外字符</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-09%2020.36.45.png\"\nalt=\"截屏2024-01-09 20.36.45\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-09 20.36.45</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minExtraChar</span><span class=\"params\">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 动态规划 dp[i] 为 s[0:i] 中剩余字符最小</span></span><br><span class=\"line\">        <span class=\"comment\">// 正常情况下：dp[i + 1] = dp[i] + 1</span></span><br><span class=\"line\">        <span class=\"comment\">// 当出现子串：dp[i + 1] = min(dp[i + 1], dp[j])(遍历 0 - i 之间的子串)</span></span><br><span class=\"line\">        <span class=\"function\">unordered_set&lt;string&gt; <span class=\"title\">dict</span><span class=\"params\">(dictionary.begin(), dictionary.end())</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            dp[i + <span class=\"number\">1</span>] = dp[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= i; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dict.<span class=\"built_in\">count</span>(s.<span class=\"built_in\">substr</span>(j, i - j + <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>] = <span class=\"built_in\">min</span>(dp[i + <span class=\"number\">1</span>], dp[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"最长公共子串\">1143.最长公共子串</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-02-18%2022.37.52.png\"\nalt=\"截屏2024-02-18 22.37.52\" />\n<figcaption aria-hidden=\"true\">截屏2024-02-18 22.37.52</figcaption>\n</figure>\n<p>定义：<code>dp[i][j]:=s1...si和t1...tj</code>\n对应的LCS的长度。由此，<code>s1...si+1和t1...tj+1</code>\n对应的公共子列可能是：</p>\n<ul>\n<li>当 <code>si+1 = tj+1</code> 时， 在 <code>s1...si 和 t1...tj</code>\n的公共子列末尾追加上 <code>si+1</code></li>\n<li><code>s1...si+1 和 t1...tj</code> 的公共子序列</li>\n<li><code>s1...si 和 t1...tj+1</code> 的公共子序列</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(string text1, string text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> text1Len = text1.<span class=\"built_in\">size</span>(), text2Len = text2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> dp[text1Len + <span class=\"number\">1</span>][text2Len + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= text1Len; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= text2Len; j++) dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; text1Len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; text2Len; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text1[i] == text2[j]) dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i][j + <span class=\"number\">1</span>], dp[i + <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[text1Len][text2Len];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"单词拆分-1\">139.单词拆分</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">wordBreak</span><span class=\"params\">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> wordDictSet = unordered_set &lt;string&gt; ();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> word : wordDict) wordDictSet.<span class=\"built_in\">insert</span>(word);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> dp = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(s.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= s.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[j] &amp;&amp; wordDictSet.<span class=\"built_in\">find</span>(s.<span class=\"built_in\">substr</span>(j ,i - j)) != wordDictSet.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    dp[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相向双指针\">2.相向双指针</h3>\n<h4 id=\"盛最多水的容器-1\">11.盛最多水的容器</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-19 23.00.57.png\" alt=\"截屏2023-12-19 23.00.57\" style=\"zoom:50%;\" /></p>\n<p>使用相向双指针，<code>left</code>\n和<code>right</code>。回到这个题目，你会发现，对于最后一根线，在中间任何比他矮的线替换他都无法使得当前的面积大于现在的面积。也就是说，我们要想获得可能（因为更换后还是可能小于当前面积的）大于当前面积的情况，我们只能选择较小的<code>left</code>\n和 <code>right</code> 来进行替换。举个🌰，对于<code>height[0]</code> 和\n<code>height[8]</code>\n来说，当前的面积是<code>7</code>。要想获得大于当前面积的选择，我们只能选择<code>height[0]</code>和<code>height[8]</code>\n之间较小的值进行替换才有可能获得大于当前的面积。也就是说，我们此时选择<code>left++</code>\n，得到 <code>height[1]</code> ，此时的面积是<code>49</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, <span class=\"built_in\">min</span>(height[left], height[right]) * (right - left));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &lt; height[right]) left++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(1)</p>\n<h3 id=\"同向双指针\">3.同向双指针</h3>\n<h4\nid=\"统计最大元素出现至少k次的子数组\">100137.统计最大元素出现至少K次的子数组</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 14.15.07.png\" alt=\"截屏2023-12-10 14.15.07\" style=\"zoom:50%;\" /></p>\n<p><strong>同向双指针+滑动窗口</strong></p>\n<p>在子数组子串问题中，经常会用到双指针这一技巧 。举个例子：给定一个含有\n<code>n</code> 个正整数的数组和一个正整数 <code>target</code>\n。找出该数组中满足其和 <code>&gt;=target</code>的长度最小的\n<strong>连续子数组</strong> <code>nums</code>\n，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> .</p>\n<p>例如209题目。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minLen = nums.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; right &lt; nums.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum += nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((sum - nums[left]) &gt;= target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sum -= nums[left];</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt;= target) minLen = <span class=\"built_in\">min</span>(minLen, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minLen &lt;= nums.<span class=\"built_in\">size</span>() ? minLen : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>再比如<strong>713.乘积小于K的子数组</strong> 给定一个整数数组\n<code>nums</code> 和一个整数 <code>k</code>\n，返回子数组内所有元素的乘积严格小于 <code>k</code>\n的连续子数组的数目。万变不离其宗，元素都是正数，方法和上一题一样，对于\n<code>[10, 5, 2, 6]</code> 比如枚举到 <code>2</code> 的时候，就把\n<code>2</code> 接到上一次计算的结果后面。那如果元素的乘积\n<code>&gt;=k</code> 就把左端点右移，缩小子数组的长度，直到乘积小于\n<code>k</code>\n为止。那么问题的关键，也是与上题不同的点，<strong>子数组的数目要怎么算</strong>\n这里，我们枚举到 <code>2</code> ，需要算的就是以 <code>2</code>\n为右端点的满足要求的子数组的个数。<code>[5, 2]</code>算是一个，\n<code>[2]</code>\n单独算一个。用代码来计算，就需要推导出来一个公式，假设此时左端点为\n<code>l</code>，右端点为<code>r</code> 。那么我们现在需要计算的就是以\n<code>r</code> 为右端点的子数组的个数。注意右端点是固定的，如果从\n<code>l</code> 到 <code>r</code> 的这一段的乘积是小于 <code>k</code>\n的。那么从 <code>l+1</code> 到 <code>r</code> 的这一段也是小于\n<code>k</code> 的。一直到 <code>[r, r]</code>\n这些子数组都是满足要求的。那么子数组的个数其实就是从 <code>l</code> 到\n<code>r</code> 的元素个数。那么就是 <code>r-l+1</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numSubarrayProductLessThanK</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxNums = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; right &lt; nums.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum *= nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum  &gt;= k)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sum /= nums[left];</span><br><span class=\"line\">                left ++;  </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxNums += right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxNums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>接着还有 <strong>3.无重复字符的最长子串</strong> 给定一个字符串\n<code>s</code> ,找出其中不含重复字符的 <strong>最长子串</strong>\n的长度。由于如果出现的重复字符的唯一情况就是刚刚加入的字符与之前的字符发生重复，所以我们只需要使用哈希的方法，统计一下刚加入的字符是否出现重复即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (right; right &lt; s.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mp[s[right]] ++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (mp[s[right]] &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[s[left]] --;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxLen = <span class=\"built_in\">max</span>(maxLen, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>回到这个题目，首先找到数组中的最大数，设 <span\nclass=\"math inline\">\\(mx=max(nums)\\)</span> 右端点 <span\nclass=\"math inline\">\\(right\\)</span> 从左到右遍历 <span\nclass=\"math inline\">\\(nums\\)</span> 。遍历到元素<span\nclass=\"math inline\">\\(x=nums[right]\\)</span> 如果 <span\nclass=\"math inline\">\\(x=mx\\)</span> ，就把计数器 <span\nclass=\"math inline\">\\(cntMx\\)</span> 加一。如果此时 <span\nclass=\"math inline\">\\(cntMx = k\\)</span> 则不断右移左指针 <span\nclass=\"math inline\">\\(left\\)</span> ，直到窗内的 <span\nclass=\"math inline\">\\(mx\\)</span> 的出现次数 <strong>小于</strong> <span\nclass=\"math inline\">\\(k\\)</span> 为止。此时，对于右端点为 <span\nclass=\"math inline\">\\(right\\)</span> 且左端点小于 <span\nclass=\"math inline\">\\(left\\)</span> 的子数组，<span\nclass=\"math inline\">\\(mx\\)</span> 的出现次数都至少为 <span\nclass=\"math inline\">\\(k\\)</span> ，把答案增加 <span\nclass=\"math inline\">\\(left\\)</span> 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">countSubarrays</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) maxVal = <span class=\"built_in\">max</span>(maxVal, nums[i]);</span><br><span class=\"line\">        <span class=\"type\">int</span> maxValCnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (right; right &lt; nums.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[right] == maxVal) maxValCnt ++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (maxValCnt == k)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[left] == maxVal) maxValCnt --;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum += left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二分查找法-红蓝染色法\">4.二分查找法 红蓝染色法</h3>\n<h4\nid=\"在排序数组中查找元素的第一个元素和最后一个位置\">34.在排序数组中查找元素的第一个元素和最后一个位置</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.05.14.png\" alt=\"截屏2023-12-20 22.05.14\" style=\"zoom:50%;\" /></p>\n<p>暴力做法，从左到右依次遍历，但是暴力做法没有利用到数组是有序的这一性质。但是我们要如何利用到数组是有序的这一性质呢？我们可以利用两个指针<code>L</code>和<code>R</code>。我们把这两个指针初始化<code>L=0, R=n-1</code>，即分别指向数组的最左边元素和最右边元素。表示我们现在需要知道这个闭区间内的每个数和8的大小关系。即现在闭区间内的颜色都是不确定的。比如目前<code>M</code>这个位置，它比8小，由于数组是有序的，那么它左边的数一定比8小。如果它大于等于8，它右边的数也是大于等于8的。现在是<code>M</code>的取值问题，如果<code>M</code>取在中间，那么我们立刻就知道数组中一半的数与8的大小关系。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.12.15.png\" alt=\"截屏2023-12-20 22.12.15\" style=\"zoom:50%;\" /></p>\n<p>我们用红色表示小于8的数，用蓝色表示大于8的数。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.20.02.png\" alt=\"截屏2023-12-20 22.20.02\" style=\"zoom:50%;\" /></p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.21.44.png\" alt=\"截屏2023-12-20 22.21.44\" style=\"zoom:50%;\" /></p>\n<p>注意⚠️这里<code>L</code>更新为<code>M+1</code>，如果<code>L</code>更新为<code>M</code>。那么考虑只有一个元素的情况，这时候就是死循环。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-20 22.24.25.png\" alt=\"截屏2023-12-20 22.24.25\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// lower_bound 返回最小的满足 nums[i] &gt;= target 的 i</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果数组为空，或者所有数都 &lt; target，则返回 nums.size()</span></span><br><span class=\"line\">    <span class=\"comment\">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 闭区间写法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = (<span class=\"type\">int</span>) nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; <span class=\"comment\">// 闭区间 [left, right]</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123; <span class=\"comment\">// 区间不为空</span></span><br><span class=\"line\">            <span class=\"comment\">// 循环不变量：</span></span><br><span class=\"line\">            <span class=\"comment\">// nums[left-1] &lt; target</span></span><br><span class=\"line\">            <span class=\"comment\">// nums[right+1] &gt;= target</span></span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 范围缩小到 [mid+1, right]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>; <span class=\"comment\">// 范围缩小到 [left, mid-1]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left; <span class=\"comment\">// 或者 right+1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 左闭右开区间写法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound2</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 左闭右开区间 [left, right)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123; <span class=\"comment\">// 区间不为空</span></span><br><span class=\"line\">            <span class=\"comment\">// 循环不变量：</span></span><br><span class=\"line\">            <span class=\"comment\">// nums[left-1] &lt; target</span></span><br><span class=\"line\">            <span class=\"comment\">// nums[right] &gt;= target</span></span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>; <span class=\"comment\">// 范围缩小到 [mid+1, right)</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid; <span class=\"comment\">// 范围缩小到 [left, mid)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left; <span class=\"comment\">// 或者 right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开区间写法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound3</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">-1</span>, right = nums.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 开区间 (left, right)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left + <span class=\"number\">1</span> &lt; right) &#123; <span class=\"comment\">// 区间不为空</span></span><br><span class=\"line\">            <span class=\"comment\">// 循环不变量：</span></span><br><span class=\"line\">            <span class=\"comment\">// nums[left] &lt; target</span></span><br><span class=\"line\">            <span class=\"comment\">// nums[right] &gt;= target</span></span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid; <span class=\"comment\">// 范围缩小到 (mid, right)</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid; <span class=\"comment\">// 范围缩小到 (left, mid)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right; <span class=\"comment\">// 或者 left+1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"built_in\">lower_bound</span>(nums, target); <span class=\"comment\">// 使用其中一种写法即可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == nums.<span class=\"built_in\">size</span>() || nums[start] != target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 start 存在，那么 end 必定存在</span></span><br><span class=\"line\">        <span class=\"type\">int</span> end = <span class=\"built_in\">lower_bound</span>(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;start, end&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"寻找峰值\">162.寻找峰值</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01%2020.48.21.png\"\nalt=\"截屏2024-01-01 20.48.21\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 20.48.21</figcaption>\n</figure>\n<p>对于这道题目，主要的点在于要求时间复杂度必须在 <span\nclass=\"math inline\">\\(O(\\log\nn)\\)</span>。这就要求我们不能够考虑暴力解答的方法。而对于一个数组，从中查找数字时，一般反应是用到二分查找的方法。但是二分查找只适用于有序数组中。这里其实我们也是可以用二分的，跟之前的二分查找方法是一样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; nums[mid + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; nums[mid + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"寻找旋转排序数组中的最小值\">153.寻找旋转排序数组中的最小值</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01%2022.18.01.png\"\nalt=\"截屏2024-01-01 22.18.01\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 22.18.01</figcaption>\n</figure>\n<p>找到小于左右的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> minNum = nums[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; minNum) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; minNum) &#123;</span><br><span class=\"line\">                minNum = nums[mid];</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"搜索旋转排序数组\">33.搜索旋转排序数组</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-01%2022.33.46.png\"\nalt=\"截屏2024-01-01 22.33.46\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 22.33.46</figcaption>\n</figure>\n<p>两次二分的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> minNum = nums[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; minNum) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; minNum) &#123;</span><br><span class=\"line\">                minNum = nums[mid];</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target == minNum) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &gt; nums[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            right = left;</span><br><span class=\"line\">            left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &lt;= nums[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>一次二分法：我们分3种情况讨论，什么时候，<code>nums[mid]</code>在<code>target</code>及其右侧，那么都染成蓝色。</p>\n<ol type=\"1\">\n<li>如果<code>nums[mid]</code>比最后一个数大，说明<code>nums[mid]</code>在左边这段，如果此时<code>target</code>也大于最后一个数。那么<code>target</code>跟<code>nums[mid]</code>在同一段。并且如果这个时候<code>nums[mid]</code>大于等于<code>target</code>。（说明<code>nums[mid]</code>在<code>target</code>及其右侧）那么<code>mid</code>及其右侧就染成蓝色。</li>\n<li>就是<code>nums[mid]</code>小于等于最后一个数，那么在右边这段。如果此时<code>target</code>还是大于最后一个数，那么<code>target</code>在左边这段，（直接就说明）<code>mid</code>及其右侧也染成蓝色。</li>\n<li>情况二不成立，<code>target</code>在第二段，<code>nums[mid]</code>大于等于<code>target</code>，那么也是蓝色。</li>\n<li>其余情况都是红色。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">is_blue</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> i, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> end = nums[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> target &gt; end &amp;&amp; nums[i] &gt;= target;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> target &gt; end || nums[i] &gt;= target;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">-1</span>, right = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left + <span class=\"number\">1</span> &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (right + left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">is_blue</span>(nums, mid, target)) &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == nums.<span class=\"built_in\">size</span>() || nums[right] != target) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"单调栈\">5.单调栈</h3>\n<p>单调栈分为单调递增栈和单调递减栈。对于一组数，从左到右依次入栈，如果栈为空或入栈元素小于栈顶元素，则入栈，否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。这是单调递增栈，单调递减栈相反。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\"><span class=\"comment\">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (遍历这个数组)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t入栈;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t栈顶元素出栈;</span><br><span class=\"line\">\t\t\t更新结果;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t当前数据入栈;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"队列中可以看到的人数\">1944.队列中可以看到的人数</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-05%2014.21.34.png\"\nalt=\"截屏2024-01-05 14.21.34\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-05 14.21.34</figcaption>\n</figure>\n<p>倒过来看问题，这个问题从左向右看问题会很复杂，但是从右向左看就很好维护一个单调递减的单调栈。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">canSeePersonsCount</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> heightsLen = heights.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(heightsLen, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heightsLen == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = heightsLen - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>() &amp;&amp; s.<span class=\"built_in\">top</span>() &lt; heights[i]) &#123;</span><br><span class=\"line\">                res[i]++;</span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                res[i] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(heights[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"美丽塔\">2866.美丽塔</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-21 13.13.15.png\" alt=\"截屏2023-12-21 13.13.15\" style=\"zoom:50%;\" /></p>\n<p>根据题意可以知道，假设数组长度为 <span\nclass=\"math inline\">\\(n\\)</span> ，对于 <strong>山状数组</strong> <span\nclass=\"math inline\">\\(heights\\)</span> 定义如下：</p>\n<ul>\n<li>假设 <span class=\"math inline\">\\(heights[i]\\)</span>\n为数组中的最大值，则 <span class=\"math inline\">\\(i\\)</span>\n左边的值均小于等于 <span class=\"math inline\">\\(heigjts[i]\\)</span>\n，<span class=\"math inline\">\\(i\\)</span> 右边的值均小于等于 <span\nclass=\"math inline\">\\(heights[i]\\)</span> 。</li>\n<li><span class=\"math inline\">\\(i\\)</span> 的左侧，从 <span\nclass=\"math inline\">\\(0\\)</span> 开始到 <span\nclass=\"math inline\">\\(i\\)</span> 为 <strong>非递减</strong> 关系，即\n<span class=\"math inline\">\\(j\\in [1,i]\\)</span> 时，均满足 <span\nclass=\"math inline\">\\(heights[j-1] \\leq heights[j]\\)</span></li>\n<li><span class=\"math inline\">\\(i\\)</span> 的右侧，从 <span\nclass=\"math inline\">\\(i\\)</span> 开始到 <span\nclass=\"math inline\">\\(n-1\\)</span> 为 <strong>非递增</strong> 关系，即\n<span class=\"math inline\">\\(j\\in[i,n-2]\\)</span> 时，均满足 <span\nclass=\"math inline\">\\(heights[j+1] \\leq heights[j]\\)</span></li>\n</ul>\n<p>题目给出了 <strong>山状数组</strong> 中每个元素的上限，即 <span\nclass=\"math inline\">\\(heights[i]\\leq\nmaxHeights[i]\\)</span>，题目要求返回山状数组所有元素之和的最大值。</p>\n<ul>\n<li>对于 <span class=\"math inline\">\\(j\\in[0, i - 1]\\)</span> 时，此时\n<span class=\"math inline\">\\(\\max(heights[j])=\\min(heights[j+1],\nmaxHeights[j])\\)</span></li>\n<li>对于 <span class=\"math inline\">\\(j\\in [i + 1, n - 1]\\)</span>\n时，此时 <span\nclass=\"math inline\">\\(\\max(heights[j])=\\min(heights[j-1],maxHeights[j])\\)</span></li>\n<li>假设此时山状数组的山顶为 <span\nclass=\"math inline\">\\(heights[i]\\)</span>\n，此时整个山状数组的所有元素的最大值即可确定，此时数组元素和的最大值也可确定</li>\n<li>对于数组中的每个元素尽可能取最大值使得整个数组元素之和最大</li>\n</ul>\n<p>根据以上分析，我们依次枚举以 <span\nclass=\"math inline\">\\(maxHeights[i]\\)</span>\n为山顶的山状数组元素之和即可求出最大的高度和。最直接的办法是两层循环，但是此时需要的时间复杂度为\n<span class=\"math inline\">\\(O(n^2)\\)</span> ，会超时。</p>\n<p>此时需要优化，对于每个索引 <span class=\"math inline\">\\(i\\)</span>\n可以将数组分为两部分处理，即保证数组的左侧构成非递减，右侧构成非递增。为了使得数组元素尽可能大，此时\n<span class=\"math inline\">\\(heights[i]\\)</span> 应取值为 <span\nclass=\"math inline\">\\(maxHeigths[i]\\)</span>，设区间 <span\nclass=\"math inline\">\\([0,i]\\)</span> 构成的非递减数组元素和的最大值为\n<span class=\"math inline\">\\(prefix[i]\\)</span> ，区间 <span\nclass=\"math inline\">\\([i,n-1]\\)</span> 构成的非递增数组元素和最大值为\n<span class=\"math inline\">\\(suffix[i]\\)</span>\n，此时构成的山状数组的元素之和为 <span\nclass=\"math inline\">\\(prefix[i]+suffix[i]-maxHeights[i]\\)</span> 。</p>\n<p>如何使得数组成为递增或递减，此时我们想到 <code>单调栈</code>\n，它可以保证栈中数据的单调性，利用单调栈将连续子数组变为非递减或非递增。</p>\n<ul>\n<li>对于左侧的非递减：将 <span class=\"math inline\">\\(maxHeights\\)</span>\n依次入栈，对于第 <span class=\"math inline\">\\(i\\)</span>\n个元素来说，不断从栈顶弹出元素，直到栈顶元素小于等于 <span\nclass=\"math inline\">\\(maxHeights[i]\\)</span> 。假设此时栈顶元素为 <span\nclass=\"math inline\">\\(maxHeights[j]\\)</span> ，则区间 <span\nclass=\"math inline\">\\([j+1,i-1]\\)</span> 中的元素最多只能取到 <span\nclass=\"math inline\">\\(maxHeights[i]\\)</span> ，则 <span\nclass=\"math inline\">\\(prefix[i]=prefix[j]+(i-j)\\times\nmaxHeights[i]\\)</span></li>\n<li>对于右侧的非递减：将 <span class=\"math inline\">\\(maxHeights\\)</span>\n依次入栈，对于第 <span class=\"math inline\">\\(i\\)</span>\n个元素来说，不断从栈顶弹出元素，直到栈顶元素 直到栈顶元素小于等于 <span\nclass=\"math inline\">\\(maxHeights[i]\\)</span> 。假设此时栈顶元素为 <span\nclass=\"math inline\">\\(maxHeights[j]\\)</span> ，则区间 <span\nclass=\"math inline\">\\([i+1,j-1]\\)</span> 中的元素最多只能取到 <span\nclass=\"math inline\">\\(maxHeights[i]\\)</span> ，则 <span\nclass=\"math inline\">\\(suffix[i]=suffix[j]+(j-i)\\times\nmaxHeights[i]\\)</span></li>\n</ul>\n<p>我们按照上述规则枚举每个位置 <span class=\"math inline\">\\(i\\)</span>\n，并计算出以 <span class=\"math inline\">\\(i\\)</span>\n为山顶的数组之和，此时山状数组的最大值即为 <span\nclass=\"math inline\">\\(\\max(prefix[i]+suffix[i]-maxHeights[i])\\)</span></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">maximumSumOfHeights</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; maxHeights)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = maxHeights.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt; <span class=\"title\">prefix</span><span class=\"params\">(n)</span>, <span class=\"title\">suffix</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; stack1, stack2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack1.<span class=\"built_in\">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stack1.<span class=\"built_in\">top</span>()]) &#123;</span><br><span class=\"line\">                stack1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stack1.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                prefix[i] = (<span class=\"type\">long</span> <span class=\"type\">long</span>) (i + <span class=\"number\">1</span>) * maxHeights[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                prefix[i] = prefix[stack1.<span class=\"built_in\">top</span>()] + (<span class=\"type\">long</span> <span class=\"type\">long</span>) (i - stack1.<span class=\"built_in\">top</span>()) * maxHeights[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack1.<span class=\"built_in\">emplace</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack2.<span class=\"built_in\">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stack2.<span class=\"built_in\">top</span>()]) &#123;</span><br><span class=\"line\">                stack2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stack2.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                suffix[i] = (<span class=\"type\">long</span> <span class=\"type\">long</span>) (n - i) * maxHeights[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                suffix[i] = suffix[stack2.<span class=\"built_in\">top</span>()] + (<span class=\"type\">long</span> <span class=\"type\">long</span>) (stack2.<span class=\"built_in\">top</span>() - i) * maxHeights[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack2.<span class=\"built_in\">emplace</span>(i);</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, prefix[i] + suffix[i] - maxHeights[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"枚举\">枚举</h3>\n<h4 id=\"二进制枚举\">二进制枚举</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;istream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; res;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for (int i = 0; i &lt; 4; i++) res.push_back(i);</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>); i++) <span class=\"comment\">//从0～2^n-1个状态</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++) <span class=\"comment\">//遍历二进制的每一位</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &amp; (<span class=\"number\">1</span> &lt;&lt; j))<span class=\"comment\">//判断二进制第j位是否存在</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,j);<span class=\"comment\">//如果存在输出第j个元素</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在这种情况下，输出的值为</span></span><br><span class=\"line\"><span class=\"comment\">0 =&gt; 1000</span></span><br><span class=\"line\"><span class=\"comment\">1 =&gt; 0100</span></span><br><span class=\"line\"><span class=\"comment\">0 1 =&gt; 1100</span></span><br><span class=\"line\"><span class=\"comment\">2 =&gt; 0010</span></span><br><span class=\"line\"><span class=\"comment\">0 2 =&gt; 1010</span></span><br><span class=\"line\"><span class=\"comment\">1 2 =&gt; 0110</span></span><br><span class=\"line\"><span class=\"comment\">0 1 2 =&gt; 1110</span></span><br><span class=\"line\"><span class=\"comment\">3 =&gt; 1=0001</span></span><br><span class=\"line\"><span class=\"comment\">0 3 =&gt; 1001</span></span><br><span class=\"line\"><span class=\"comment\">1 3 =&gt; 0101</span></span><br><span class=\"line\"><span class=\"comment\">0 1 3 =&gt; 1101</span></span><br><span class=\"line\"><span class=\"comment\">2 3 =&gt; 0011</span></span><br><span class=\"line\"><span class=\"comment\">0 2 3 =&gt; 1011</span></span><br><span class=\"line\"><span class=\"comment\">1 2 3 =&gt; 0111</span></span><br><span class=\"line\"><span class=\"comment\">0 1 2 3 =&gt; 1111</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"被列覆盖的最多行数\"><a\nhref=\"https://leetcode.cn/problems/maximum-rows-covered-by-columns/\">2397.\n被列覆盖的最多行数</a></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;istream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bitset&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximumRows</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; matrix, <span class=\"type\">int</span> numSelect)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = matrix.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> n = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">mask</span><span class=\"params\">(m, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                mask[i] += matrix[i][j] &lt;&lt; (n - j - <span class=\"number\">1</span>); <span class=\"comment\">// 计算每一行的十进制值 0, 5, 3, 1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;mask:&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; mask.<span class=\"built_in\">size</span>(); i++) cout &lt;&lt; mask[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> limit = (<span class=\"number\">1</span> &lt;&lt; n); <span class=\"comment\">// 进行二进制枚举，共有 2^n 种情况，就是1 左移 3 位的值</span></span><br><span class=\"line\">        cout  &lt;&lt; <span class=\"string\">&quot;limit: &quot;</span> &lt;&lt; limit &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((++cur) &lt; limit) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;cur: &quot;</span> &lt;&lt; cur &lt;&lt; <span class=\"string\">&quot; cur的二进制：&quot;</span> &lt;&lt; <span class=\"built_in\">bitset</span>&lt;<span class=\"number\">3</span>&gt;(cur) &lt;&lt; <span class=\"string\">&quot; __builtin_popcount(cur): &quot;</span> &lt;&lt; __builtin_popcount(cur) &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__builtin_popcount(cur) != numSelect) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((mask[j] &amp; cur) == mask[j]) &#123; <span class=\"comment\">// 与运算，如果两位都为1结果才是1，</span></span><br><span class=\"line\">                    ++t;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Solution s;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; matrix&#123;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = s.<span class=\"built_in\">maximumRows</span>(matrix, <span class=\"number\">2</span>);</span><br><span class=\"line\">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"移除栅栏得到的正方形田地的最大面积\">100169.<a\nhref=\"https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/\">移除栅栏得到的正方形田地的最大面积</a></h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-24 12.28.03.png\" alt=\"截屏2023-12-24 12.28.03\" style=\"zoom:50%;\" /></p>\n<p>相当于给顶一些横线竖线，找出这些横线竖线之间可能构造出来的最大正方形。正方形两条边边长一样，因此找到的横线的横坐标之差需要等于找到的竖线的纵坐标之差。由于横线竖线数量相对不多，我们可以直接枚举所有情况，看其中是否有公共元素，找出最大的公共元素算平方即可。这只需要通过哈希表记录判断即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximizeSquareArea</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n, vector&lt;<span class=\"type\">int</span>&gt;&amp; hFences, vector&lt;<span class=\"type\">int</span>&gt;&amp; vFences)</span> </span>&#123;</span><br><span class=\"line\">        hFences.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        hFences.<span class=\"built_in\">push_back</span>(m);</span><br><span class=\"line\">        vFences.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        vFences.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(hFences.<span class=\"built_in\">begin</span>(), hFences.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(vFences.<span class=\"built_in\">begin</span>(), vFences.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> hFencesLen = hFences.<span class=\"built_in\">size</span>(), vFencesLen = vFences.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; hFencesLen; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                mp[<span class=\"built_in\">abs</span>(hFences[i] - hFences[j])]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; vFencesLen; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mp[<span class=\"built_in\">abs</span>(vFences[i] - vFences[j])]) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> a = <span class=\"built_in\">abs</span>(vFences[i] - vFences[j]);</span><br><span class=\"line\">                    res = <span class=\"built_in\">max</span>(res, a);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res == <span class=\"number\">-1</span> ? <span class=\"number\">-1</span> : ((<span class=\"type\">long</span>)res * (<span class=\"type\">long</span>)res) % MOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4\nid=\"找出出现至少三次的最长特殊子字符串-i\">找出出现至少三次的最长特殊子字符串\nI</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-31%2012.09.55.png\"\nalt=\"截屏2023-12-31 12.09.55\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-31 12.09.55</figcaption>\n</figure>\n<p>长度为 <span class=\"math inline\">\\(x\\)</span>\n的特殊字符串里包含几个长度为 <span class=\"math inline\">\\(y\\)</span>\n的子串？答案是 <span class=\"math inline\">\\((x - y + 1)\\)</span> 个。</p>\n<p>设原串中，最长的特殊子串长度为 <span class=\"math inline\">\\(m\\)</span>\n，那么长度为 <span class=\"math inline\">\\((m - 2)\\)</span>\n的子串在该串中至少出现 <span class=\"math inline\">\\(m - (m - 2) + 1 =\n3\\)</span> 次，因此答案至少是 <span\nclass=\"math inline\">\\((m-2)\\)</span>，至多是 <span\nclass=\"math inline\">\\(m\\)</span> 。</p>\n<p>因此直接从 <span class=\"math inline\">\\(m\\)</span> 到 <span\nclass=\"math inline\">\\((m - 2)\\)</span>\n枚举答案，并计算这个长度的特殊子串有几个即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximumLength</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sLen = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; vec[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> len = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">char</span> last = s[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; sLen; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] != last) &#123;</span><br><span class=\"line\">                vec[last - <span class=\"string\">&#x27;a&#x27;</span>].<span class=\"built_in\">push_back</span>(len);</span><br><span class=\"line\">                last = s[i];</span><br><span class=\"line\">                len = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            len++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vec[last - <span class=\"string\">&#x27;a&#x27;</span>].<span class=\"built_in\">push_back</span>(len);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : vec[i]) &#123;</span><br><span class=\"line\">                mx = <span class=\"built_in\">max</span>(mx, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> ans = mx; ans &gt;= mx - <span class=\"number\">2</span> &amp;&amp; ans ; ans--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : vec[i]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (v &gt;= ans) cnt += (v - ans) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cnt &gt;= <span class=\"number\">3</span>) <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建图-floyd\">建图-floyd</h3>\n<h4 id=\"转换字符串的最小成本-i\"><a\nhref=\"https://leetcode.cn/problems/minimum-cost-to-convert-string-i/\">100156.\n转换字符串的最小成本 I</a></h4>\n<p>建图，从 <span class=\"math inline\">\\(original[i]\\)</span> 向 <span\nclass=\"math inline\">\\(changed[i]\\)</span> 连边，边权为 <span\nclass=\"math inline\">\\(cost[i]\\)</span>\n。然后用Floyd算法求图中任意两点最短路，得到 <span\nclass=\"math inline\">\\(dis\\)</span> 矩阵，最后累加所有的 <span\nclass=\"math inline\">\\(dis[original[i]][changed[i]]\\)</span>\n，即为答案，如果答案为无穷啊，返回-1.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">minimumCost</span><span class=\"params\">(string source, string target, vector&lt;<span class=\"type\">char</span>&gt;&amp; original, vector&lt;<span class=\"type\">char</span>&gt;&amp; changed, vector&lt;<span class=\"type\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = original.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(<span class=\"number\">26</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">26</span>, <span class=\"number\">10000001</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) g[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> o = original[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> c = changed[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            g[o][c] = <span class=\"built_in\">min</span>(g[o][c], cost[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Floyd</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">26</span>; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt; <span class=\"number\">26</span>; x++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt; <span class=\"number\">26</span>; y++) &#123;</span><br><span class=\"line\">                    g[x][y] = <span class=\"built_in\">min</span>(g[x][y], g[x][k] + g[k][y]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> m = source.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> cur = g[source[j] - <span class=\"string\">&#x27;a&#x27;</span>][target[j] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur &gt;= <span class=\"number\">10000001</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">            ans += cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"收集巧克力\"><a\nhref=\"https://leetcode.cn/problems/collecting-chocolates/\">2735.\n收集巧克力</a></h4>\n<p><strong>巧妙枚举</strong></p>\n<ul>\n<li>枚举操作次数，从操作<code>0</code>次枚举到操作<code>n-1</code>次</li>\n<li>如果不操作，第 <span class=\"math inline\">\\(i\\)</span>\n个巧克力必须花费 <span class=\"math inline\">\\(nums[i]\\)</span>\n收集，总花费为所有 <span class=\"math inline\">\\(nums[i]\\)</span>\n之和。如果只操作一次，第 <span class=\"math inline\">\\(i\\)</span>\n个巧克力可以在操作前购买，取最小值，即 <span\nclass=\"math inline\">\\(\\min(nums[i], num[(i + 1) \\mod n])\\)</span>\n.如果操作两次，购买第 <span class=\"math inline\">\\(i\\)</span>\n个巧克力的花费为 <span class=\"math inline\">\\(\\min(nums[i], nums[(i + 1)\n\\mod n], nums[(i + 2) \\mod\nn])\\)</span>。例如示例1，我们可以操作两次，这样每块巧克力都只需要1的花费，总成本为\n<span class=\"math inline\">\\(2x+1+1+1=13\\)</span>。</li>\n<li>如果暴力枚举操作次数，再枚举每个巧克力，再计算购买这个巧克力的最小花费，总的时间复杂度是\n<span class=\"math inline\">\\(O(n^3)\\)</span>。一个初步的优化是，用 <span\nclass=\"math inline\">\\(O(n^2)\\)</span>\n的时间预处理所有子数组的最小值，保存到一个二维数组中。这样做需要 <span\nclass=\"math inline\">\\(O(n^2)\\)</span> 的时间和空间。但其实不需要与处理：\n<ol type=\"1\">\n<li>用一个长为 <span class=\"math inline\">\\(n\\)</span> 的数组 <span\nclass=\"math inline\">\\(s\\)</span> 统计不同操作次数下的总成本。</li>\n<li>写一个二重循环，枚举子数组的左端点 <span\nclass=\"math inline\">\\(i\\)</span> 和右端点 <span\nclass=\"math inline\">\\(j\\)</span>。</li>\n<li>在枚举右端点的同时，维护从 <span\nclass=\"math inline\">\\(nums[i]\\)</span> 到 <span\nclass=\"math inline\">\\(nums[j]\\)</span> 的最小值 <span\nclass=\"math inline\">\\(mn\\)</span> 。</li>\n<li>把 <span class=\"math inline\">\\(mn\\)</span> 加到 <span\nclass=\"math inline\">\\(s[j - i]\\)</span> 中，这是因为长为 <span\nclass=\"math inline\">\\(j - i + 1\\)</span> 的子数组恰好对应着操作 <span\nclass=\"math inline\">\\(j-i\\)</span> 次时要计算的子数组。</li>\n<li>最后输出 <span class=\"math inline\">\\(\\min(s)\\)</span> 。</li>\n</ol></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">minCost</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt; <span class=\"title\">s</span><span class=\"params\">(n)</span></span>;  <span class=\"comment\">// s[k] 统计操作 k 次的总成本</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            s[i] = (<span class=\"type\">long</span> <span class=\"type\">long</span>) i * x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mn = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n + i; j++) &#123; <span class=\"comment\">// 子数组右端点（把数组视为环形的） </span></span><br><span class=\"line\">                mn = <span class=\"built_in\">min</span>(mn, nums[j % n]);  <span class=\"comment\">// 维护从 nums[i] 到 nums[j] 的最小值</span></span><br><span class=\"line\">                s[j - i] += mn;  <span class=\"comment\">// 累加操作 j - i 次的花费</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"built_in\">min_element</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"链表\">链表</h4>\n<h5 id=\"反转链表\">206反转链表</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2022.42.44.png\"\nalt=\"截屏2024-01-02 22.42.44\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-02 22.42.44</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur) &#123;</span><br><span class=\"line\">            ListNode* next = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"反转链表-1\">92.反转链表</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2022.58.03.png\"\nalt=\"截屏2024-01-02 22.58.03\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-02 22.58.03</figcaption>\n</figure>\n<p>从上题可以知道，反转结束后，从原来的链表上看： <span\nclass=\"math inline\">\\(pre\\)</span> 指向反转这一段的末尾，<span\nclass=\"math inline\">\\(cur\\)</span> 指向反转这一段后续的下一个节点。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2023.26.25.png\"\nalt=\"截屏2024-01-02 23.26.25\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-02 23.26.25</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseBetween</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        dummy-&gt;next = head;</span><br><span class=\"line\">        ListNode* p0 = dummy;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; left - <span class=\"number\">1</span>; i++) p0 = p0-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* cur = p0-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; right - left + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            ListNode* next = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        p0-&gt;next-&gt;next = cur;</span><br><span class=\"line\">        p0-&gt;next = pre;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"k个一组反转链表\">25.K个一组反转链表</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2023.50.11.png\"\nalt=\"截屏2024-01-02 23.50.11\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-02 23.50.11</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-02%2023.46.44.png\"\nalt=\"截屏2024-01-02 23.46.44\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-02 23.46.44</figcaption>\n</figure>\n<p>跟上边的题目类似，不过这里主要是注意，<span\nclass=\"math inline\">\\(p0\\)</span>的变化，在一次反转之后，我们把 <span\nclass=\"math inline\">\\(next\\)</span> 改为 <span\nclass=\"math inline\">\\(p0\\to next\\)</span>\n，即1位置，其实这也是经过反转后的下一个 <span\nclass=\"math inline\">\\(p0\\)</span>的起始位置。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ListNodeLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode* cur = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur) &#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">            ListNodeLen ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        dummy-&gt;next = head;</span><br><span class=\"line\">        ListNode* p0 = dummy;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ListNodeLen &gt;= k) &#123;</span><br><span class=\"line\">            ListNodeLen -= k;</span><br><span class=\"line\">            ListNode* pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            cur = p0-&gt;next;</span><br><span class=\"line\">            ListNode* next = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">                next = cur-&gt;next;</span><br><span class=\"line\">                cur-&gt;next = pre;</span><br><span class=\"line\">                pre = cur;</span><br><span class=\"line\">                cur = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next = p0-&gt;next;</span><br><span class=\"line\">            p0-&gt;next-&gt;next = cur;</span><br><span class=\"line\">            p0-&gt;next = pre;</span><br><span class=\"line\">            p0 = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"从链表中移除节点\">2487.从链表中移除节点</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2017.15.59.png\"\nalt=\"截屏2024-01-03 17.15.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-03 17.15.59</figcaption>\n</figure>\n<p>反过来遍历，每次保存遍历中的最大值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNodes</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将链表反转</span></span><br><span class=\"line\">        ListNode* pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur) &#123;</span><br><span class=\"line\">            ListNode* next = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;ListNode*&gt; vec;</span><br><span class=\"line\">        <span class=\"type\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pre) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre-&gt;val &gt;= max) &#123;</span><br><span class=\"line\">                vec.<span class=\"built_in\">push_back</span>(pre);</span><br><span class=\"line\">                max = pre-&gt;val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre = pre-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* res = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        res = vec[vec.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = vec.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            vec[i]-&gt;next = vec[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vec[<span class=\"number\">0</span>]-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"链表的中间结点\">876.链表的中间结点</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.22.21.png\"\nalt=\"截屏2024-01-03 22.22.21\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-03 22.22.21</figcaption>\n</figure>\n<p>使用快慢指针，我们可以用两个指针，一个叫做慢指针，一个叫做快指针。每次循环，慢指针走一步，快指针走两步。我们可以通过数学归纳法，证明长度为奇数的时候，如果快指针在最后一个节点，那么慢指针一定在中间结点。对于偶数长度也是一样的。\n如果快指针指向空，那么慢指针一定在中间结点上。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.28.44.png\"\nalt=\"截屏2024-01-03 22.28.44\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-03 22.28.44</figcaption>\n</figure>\n<p>综合这两种情况，当快指针指向空，或者他的下一个节点指向空，这个时候就退出循环，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">middleNode</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* node1 = head;</span><br><span class=\"line\">        ListNode* node2 = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node1 &amp;&amp; node1-&gt;next) &#123;</span><br><span class=\"line\">            node1 = node1-&gt;next;</span><br><span class=\"line\">            node1 = node1-&gt;next;</span><br><span class=\"line\">            node2 = node2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"环形链表\">141.环形链表</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.35.14.png\"\nalt=\"截屏2024-01-03 22.35.14\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-03 22.35.14</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* node1 = head;</span><br><span class=\"line\">        ListNode* node2 = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node1 &amp;&amp; node1-&gt;next) &#123;</span><br><span class=\"line\">            node1 = node1-&gt;next;</span><br><span class=\"line\">            node1 = node1-&gt;next;</span><br><span class=\"line\">            node2 = node2-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node1 == node2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"环形列表2\">142.环形列表2</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.40.21.png\"\nalt=\"截屏2024-01-03 22.40.21\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-03 22.40.21</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.40.50.png\"\nalt=\"截屏2024-01-03 22.40.50\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-03 22.40.50</figcaption>\n</figure>\n<p>快指针移动距离是慢指针的两倍， <span class=\"math display\">\\[\n2(a+b)=a+b+k(b+c)\\\\\n2a+2b=a+b+b+c+(k-1)(b+c)\\\\\na-c=(k-1)(b+c)\n\\]</span> <img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.43.28.png\"\nalt=\"截屏2024-01-03 22.43.28\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* node1 = head;</span><br><span class=\"line\">        ListNode* node2 = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node1 &amp;&amp; node1-&gt;next) &#123;</span><br><span class=\"line\">            node1 = node1-&gt;next;</span><br><span class=\"line\">            node1 = node1-&gt;next;</span><br><span class=\"line\">            node2 = node2-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node1 == node2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (node2 != head) &#123;</span><br><span class=\"line\">                    node2 = node2-&gt;next;</span><br><span class=\"line\">                    head = head-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"重排链表\">重排链表</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-03%2022.59.08.png\"\nalt=\"截屏2024-01-03 22.59.08\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-03 22.59.08</figcaption>\n</figure>\n<p>找到中间结点，然后将中间结点之后的结点全部反转，之后再进行两个链表的交错排列即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reorderList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* fast = head;</span><br><span class=\"line\">        ListNode* slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将链表反转</span></span><br><span class=\"line\">        ListNode* pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* cur = slow;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur) &#123;</span><br><span class=\"line\">            ListNode* next = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// head2 为当前反转链表的头节点。</span></span><br><span class=\"line\">        ListNode* head1 = head;</span><br><span class=\"line\">        ListNode* head2 = pre;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != slow &amp;&amp; head2-&gt;next) &#123;</span><br><span class=\"line\">            ListNode* next1 = head1-&gt;next;</span><br><span class=\"line\">            ListNode* next2 = head2-&gt;next;</span><br><span class=\"line\">            head1-&gt;next = head2;</span><br><span class=\"line\">            head2-&gt;next = next1;</span><br><span class=\"line\">            head1 = next1;</span><br><span class=\"line\">            head2 = next2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"在链表中插入最大公约数\">2807.在链表中插入最大公约数</h5>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-06%2020.21.08.png\"\nalt=\"截屏2024-01-06 20.21.08\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-06 20.21.08</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> temp = m % n;</span><br><span class=\"line\">            m = n;</span><br><span class=\"line\">            n = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">insertGreatestCommonDivisors</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* pre = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ListNode* next = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pre = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pre &amp;&amp; pre-&gt;next) &#123;</span><br><span class=\"line\">            next = pre-&gt;next;</span><br><span class=\"line\">            <span class=\"type\">int</span> tmp = <span class=\"built_in\">gcd</span>(pre-&gt;val, next-&gt;val);</span><br><span class=\"line\">            ListNode* cur = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">            cur-&gt;val = tmp;</span><br><span class=\"line\">            cur-&gt;next = pre-&gt;next;</span><br><span class=\"line\">            pre-&gt;next = cur;</span><br><span class=\"line\">            pre = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除链表重复节点\">237.删除链表重复节点</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode* node)</span> </span>&#123;</span><br><span class=\"line\">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class=\"line\">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除链表的倒数第n个节点\">19.删除链表的倒数第N个节点</h5>\n<p>首先，在之前的反转链表的题目，有些题目用到了哨兵节点这个技巧，那么什么时候需要哨兵节点，什么时候不需要哨兵节点？对于删除节点来说，一般来说需要删除头节点的话，需要哨兵节点。</p>\n<p>对于这个题目来说，我们可以先让一个指针走完整个链表，求出链表长度，再结合n求出倒数第N个节点在链表哪个位置。</p>\n<p>我们也可以初始化左右指针，当右指针走到第n个位置的时候，我们让左指针开始移动，这样左右指针中间相差n个位置。当右指针走到底的时候，左指针就是答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ListNode* left = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ListNode* right = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        dummy-&gt;next = head;</span><br><span class=\"line\">        left = dummy;</span><br><span class=\"line\">        right = dummy;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &amp;&amp; right-&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &gt;= n) &#123;</span><br><span class=\"line\">                left = left-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            right = right-&gt;next;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        left-&gt;next = left-&gt;next-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除排序链表中的重复元素\">83.删除排序链表中的重复元素</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ListNode* next = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        dummy = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!head || !head-&gt;next ) <span class=\"keyword\">return</span> dummy;</span><br><span class=\"line\">        next = head-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head-&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head-&gt;val == head-&gt;next-&gt;val) &#123;</span><br><span class=\"line\">                head-&gt;next = head-&gt;next-&gt;next;  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除排序链表中的重复元素2\">82.删除排序链表中的重复元素2</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        dummy-&gt;next = head;</span><br><span class=\"line\">        ListNode* cur = dummy;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> val = cur-&gt;next-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur-&gt;next-&gt;next-&gt;val == val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == val) &#123;</span><br><span class=\"line\">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur = cur-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树与递归\">二叉树与递归</h3>\n<p>如何计算二叉树的深度，不要一开始就陷入细节，而是思考整棵树与其左右子树的关系。整棵树的深度=max（左子树的最大深度，右子树的最大深度）+1.。这样思考后，你会发现，原问题：计算整棵树的最大深度，子问题：计算左/右子树的最大深度。子问题与原问题是相似的。类比循环，执行的代码也应该是相同的，但子问题需要把计算结果返给上一级问题，这更适合用递归实现。由于子问题的规模比原问题小，不断递归下去，总会有个尽头，即递归的边界条件（base\ncase）。直接返回它的答案（归）。</p>\n<h4 id=\"二叉树的最大深度\">104.二叉树的最大深度</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2015.22.07.png\"\nalt=\"截屏2024-01-19 15.22.07\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-19 15.22.07</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deep</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l_d = <span class=\"built_in\">deep</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> l_r = <span class=\"built_in\">deep</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(l_d, l_r) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">deep</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"相同的树\">100.相同的树</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2016.13.09.png\"\nalt=\"截屏2024-01-19 16.13.09\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-19 16.13.09</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!p || !q) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p == q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class=\"built_in\">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class=\"built_in\">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"对称二叉树\">101.对称二叉树</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2016.18.30.png\"\nalt=\"截屏2024-01-19 16.18.30\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-19 16.18.30</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!p || !q) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p == q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class=\"built_in\">isSameTree</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class=\"built_in\">isSameTree</span>(p-&gt;right, q-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">isSameTree</span>(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deep</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">deep</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">deep</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r == <span class=\"number\">-1</span> || <span class=\"built_in\">abs</span>(r - l) &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(l, r) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">deep</span>(root) == <span class=\"number\">-1</span> ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树的右视图\">199.二叉树的右视图</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-19%2016.39.27.png\"\nalt=\"截屏2024-01-19 16.39.27\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-19 16.39.27</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(TreeNode* node, <span class=\"type\">int</span> depth)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!node) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (depth == ans.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(node-&gt;val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">f</span>(node-&gt;right, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">f</span>(node-&gt;left, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">rightSideView</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">f</span>(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"周赛\">周赛</h3>\n<h4 id=\"section\">380-2024-1-14</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-14 18.46.28.png\" alt=\"截屏2024-01-14 18.46.28\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxFrequencyElements</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> numsLen = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">105</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> max_nums = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numsLen; i++) &#123;</span><br><span class=\"line\">            cnt[nums[i]] ++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt[nums[i]] &gt; max_nums) &#123;</span><br><span class=\"line\">                max_nums = cnt[nums[i]];</span><br><span class=\"line\">                res = max_nums;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cnt[nums[i]] == max_nums) &#123;</span><br><span class=\"line\">                res += max_nums;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2024-01-14%2018.47.10.png\"\nalt=\"截屏2024-01-14 18.47.10\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-14 18.47.10</figcaption>\n</figure>\n<p>一开始想的是直接暴力，结果就是超时。WAWA！</p>\n<p>两种解法：</p>\n<ol type=\"1\">\n<li>二分+数位DP</li>\n<li>二分+枚举数位</li>\n</ol>\n<p>要用到二分，就要考虑是否有单调性，对于这道题目，我们观察到<code>num</code>\n越大 其价值和越大，这就是题目包含的单调性。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-14 18.58.33.png\" alt=\"截屏2024-01-14 18.58.33\" style=\"zoom:50%;\" /></p>\n<p>我们需要找到一个小于等于<code>k</code>\n的最大的一个包含num的ans。这样就变成了，给定 <code>num</code> 统计\n<code>1~num</code> 的价值和，判断价值和是否 <code>&lt;=k</code>\n。二分相当于多花费 <code>log</code> 的时间，额外增加一个条件。</p>\n<p><strong>数位DP模版</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">findMaximumNumber</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> k, <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"type\">long</span> <span class=\"type\">long</span> num) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = <span class=\"number\">64</span> - __builtin_clzll(num);  <span class=\"comment\">//确定一个整数的二进制表示中有多少位</span></span><br><span class=\"line\">            vector&lt;vector&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt;&gt; <span class=\"built_in\">memo</span>(m, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt;(m + <span class=\"number\">1</span>, <span class=\"number\">-1</span>));</span><br><span class=\"line\">            function&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>(<span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">bool</span>)&gt;dfs = [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> cnt1, <span class=\"type\">bool</span> is_limit) -&gt; <span class=\"type\">long</span> <span class=\"type\">long</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> cnt1;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!is_limit &amp;&amp; memo[i][cnt1] &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> memo[i][cnt1];</span><br><span class=\"line\">                <span class=\"type\">int</span> up = is_limit ? num &gt;&gt; i &amp; <span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"type\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> d = <span class=\"number\">0</span>; d &lt;= up; d++) &#123;</span><br><span class=\"line\">                    res += <span class=\"built_in\">dfs</span>(i - <span class=\"number\">1</span>, cnt1 + (d == <span class=\"number\">1</span> &amp;&amp; (i + <span class=\"number\">1</span>) % x == <span class=\"number\">0</span>), is_limit &amp;&amp; d == up);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!is_limit) memo[i][cnt1] = res;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(m - <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span>) &lt;= k;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> left = <span class=\"number\">0</span>, right = (k + <span class=\"number\">1</span>) &lt;&lt; x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left + <span class=\"number\">1</span> &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            (<span class=\"built_in\">check</span>(mid) ? left : right) = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"杂乱题目\">杂乱题目</h3>\n<h4 id=\"年5月\">2023年5月</h4>\n<h5\nid=\"填充每个节点的下一个右侧节点指针\">填充每个节点的下一个右侧节点指针</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-12 21.28.37.png\" alt=\"截屏2023-05-12 21.28.37\" style=\"zoom:50%;\" /></p>\n<p>对于二叉树问题，首先要想到几种遍历方法：</p>\n<ol type=\"1\">\n<li><p>前序遍历</p></li>\n<li><p>中序遍历</p></li>\n<li><p>后序遍历</p></li>\n<li><p>深度优先搜索DFS</p></li>\n<li><p>宽度优先搜索BFS</p>\n<p>这道题目要求的是把每一行都串联起来，那么BFS按层遍历就很合适。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">public:</span></span><br><span class=\"line\"><span class=\"comment\">    int val;</span></span><br><span class=\"line\"><span class=\"comment\">    Node* left;</span></span><br><span class=\"line\"><span class=\"comment\">    Node* right;</span></span><br><span class=\"line\"><span class=\"comment\">    Node* next;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class=\"line\"><span class=\"comment\">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 这是一个BFS模版</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">levelOrder</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">      q.<span class=\"built_in\">push</span>(root);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 把节点添加到队列尾部</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        TreeNode* node = q.<span class=\"built_in\">front</span>();\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 出队列</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">          \tq.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">          \tq.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 具体解题代码</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        queue&lt;Node*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> len_level = q.<span class=\"built_in\">size</span>();                   <span class=\"comment\">// 代表每一层节点的数量</span></span><br><span class=\"line\">            Node* pre = <span class=\"literal\">nullptr</span>;                        <span class=\"comment\">// 前一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i != len_level; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Node* node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pre != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                    pre-&gt;next = node;</span><br><span class=\"line\">                pre = node;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node-&gt;left)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node-&gt;right)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"二叉搜索树中第k小的元素\">二叉搜索树中第K小的元素</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-13 21.48.17.png\" alt=\"截屏2023-05-13 21.48.17\" style=\"zoom:50%;\" /></p>\n<p>可以吧整个树都遍历一遍，然后吧结果存储到vector中，在进行排序找到第K小的元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; vec;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode* node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            vec.<span class=\"built_in\">push_back</span>(node-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node-&gt;left) q.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node-&gt;right) q.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vec[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>------------------2023年5月13日-----------</p>\n<h5 id=\"岛屿数量\">岛屿数量</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-13 21.56.03.png\" alt=\"截屏2023-05-13 21.56.03\" style=\"zoom:50%;\" /></p>\n<p>题目思路：DFS解决，</p>\n<p>这题让求的是岛屿的数量，二维数组中值是1的都是岛屿，如果多个1是连着的，那么他们只能算一个岛屿。最简单的一种方式是遍历数组中的每一个数值，如果是1就说明是岛屿，然后把它置为0或者其他的字符都可以，然后再遍历他的上下左右4个位置。如果是1，就说明这两个岛屿是连着的，只能算是一个岛屿。我们还要把它置为0，然后以它为中心遍历它的上下左右4个位置。如果是0，就说明不是岛屿，就不在往它的上下左右4个位置遍历了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 把当前格子以及他邻近为1的格子都置为1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt;&amp; grid, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>|| i &gt;= grid.<span class=\"built_in\">size</span>() || j &lt; <span class=\"number\">0</span> || j &gt;= grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>() || grid[i][j] == <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 把当前格子置为0，然后遍历他的上下左右4个方向</span></span><br><span class=\"line\">        grid[i][j] = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(grid, i - <span class=\"number\">1</span>, j);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(grid, i + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(grid, i, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(grid, i, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grid.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> lands_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i != grid.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j != grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>(); j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    lands_cnt ++;</span><br><span class=\"line\">                    <span class=\"built_in\">dfs</span>(grid, i, j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lands_cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是显然，这种方法效率很差，单从两个嵌套的for循环来说，这里就已经是\n<span class=\"math display\">\\[\nO(n^2)\n\\]</span> 2023年5月16日22:22</p>\n<hr />\n<h5 id=\"电话号码的字母组合\">电话号码的字母组合</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-21 21.14.39.png\" alt=\"截屏2023-05-21 21.14.39\" style=\"zoom:50%;\" /></p>\n<p>可以使用BFS来进行搜索，将整个过程视为n叉树。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-22 22.23.41.png\" alt=\"截屏2023-05-22 22.23.41\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;curl/curl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::string digits = <span class=\"string\">&quot;23&quot;</span>;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digits.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i != res.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">            std::cout &lt;&lt; res[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;std::vector&lt;<span class=\"type\">char</span>&gt;&gt; tab = &#123;&#123;<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;g&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>&#125;,</span><br><span class=\"line\">                                &#123;<span class=\"string\">&#x27;j&#x27;</span>, <span class=\"string\">&#x27;k&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;m&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;p&#x27;</span>, <span class=\"string\">&#x27;q&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;s&#x27;</span>&#125;,</span><br><span class=\"line\">                                &#123;<span class=\"string\">&#x27;t&#x27;</span>, <span class=\"string\">&#x27;u&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;w&#x27;</span>, <span class=\"string\">&#x27;x&#x27;</span>, <span class=\"string\">&#x27;y&#x27;</span>, <span class=\"string\">&#x27;z&#x27;</span>&#125;</span><br><span class=\"line\">                                &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i != tab.<span class=\"built_in\">size</span>(); i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j != tab[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>(); j ++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; tab[i][j] &lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::queue&lt;std::string&gt; que;</span><br><span class=\"line\">    que.<span class=\"built_in\">push</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(que.<span class=\"built_in\">front</span>().<span class=\"built_in\">size</span>() != digits.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::string remove = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">char</span>&gt; chars = tab[digits[remove.<span class=\"built_in\">size</span>()] - <span class=\"string\">&#x27;2&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; chars.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(remove + chars[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::string str = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(str);</span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; digits &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-22 23.12.09.png\" alt=\"截屏2023-05-22 23.12.09\" style=\"zoom:50%;\" /></p>\n<h5 id=\"有效括号生成\">有效括号生成</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-26 22.46.13.png\" alt=\"截屏2023-05-26 22.46.13\" style=\"zoom:50%;\" /></p>\n<p>通过观察我们可以发现，生成的任何括号组合中都有两个规律：</p>\n<ol type=\"1\">\n<li>括号组合中左括号的数量等于右括号的数量</li>\n<li>括号组合中任何位置左括号的数量都是大于等于右括号的数量</li>\n</ol>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-26 22.47.16.png\" alt=\"截屏2023-05-26 22.47.16\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;string&gt; &amp;res, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right, string cur_str)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"number\">0</span> &amp;&amp; right == <span class=\"number\">0</span>) <span class=\"comment\">// 左右括号都不剩余了，说明找到了有效的括号</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(cur_str);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左括号只有剩余的时候才可以选，如果左括号的数量已经选完了，是不能再选左括号</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果选完了左括号我们还是可以选择右括号的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果右括号剩余数量小于左括号的剩余数量，说明之前选择的无效</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; left) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(res, left - <span class=\"number\">1</span>, right, cur_str + <span class=\"string\">&#x27;(&#x27;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(res, left, right - <span class=\"number\">1</span>, cur_str + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;string&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(res, n, n, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5\nid=\"全排列\">全排列<img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-27 21.40.35.png\" alt=\"截屏2023-05-27 21.40.35\" style=\"zoom:50%;\" /></h5>\n<p>首先根据数学定义：全排列的总个数为 <span\nclass=\"math inline\">\\(n!\\)</span>个。根据之前的思路，可以从搜索的方法入手。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Downloads/IMG_6219E6E27471-1.jpeg\" alt=\"IMG_6219E6E27471-1\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回溯模版</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(参数)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (终止条件) &#123;</span><br><span class=\"line\">        存放结果;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class=\"line\">        处理节点;</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(路径，选择列表); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">        回溯，撤销处理结果</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; result;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backTrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> first, <span class=\"type\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.<span class=\"built_in\">emplace_back</span>(nums);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = first; i &lt; len; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[i], nums[first]);</span><br><span class=\"line\">            <span class=\"built_in\">backTrack</span>(nums, first + <span class=\"number\">1</span>, len);</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[i], nums[first]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">permute</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">backTrack</span>(nums, <span class=\"number\">0</span>, nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"单词搜索\">单词搜索</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-05-31 21.29.08.png\" alt=\"截屏2023-05-31 21.29.08\" style=\"zoom:50%;\" /></p>\n<p>首先反应就是之前遇到过的岛屿问题，进行DFS搜索，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt;&amp; board, string word, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 边界判断，如果越界直接返回false, index表示的是查找到字符串word的第几个字符</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果这个字符不等于board[i][j], 说明这个坐标路径是走不通的, 直接返回false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= board.<span class=\"built_in\">size</span>() || i &lt; <span class=\"number\">0</span> || j &gt;= board[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>() || j &lt; <span class=\"number\">0</span> || board[i][j] != word[index])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果word的每个字符都查找完了，直接返回truetrue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == word.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 把当前的坐标值保存下来，为了在最后复原</span></span><br><span class=\"line\">        <span class=\"type\">char</span> tmp = board[i][j];</span><br><span class=\"line\">        <span class=\"comment\">// 然后修改当前坐标的值</span></span><br><span class=\"line\">        board[i][j] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 走递归, 沿着当前坐标的上下左右4各方向查找</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> res = <span class=\"built_in\">dfs</span>(board, word, i + <span class=\"number\">1</span>, j, index + <span class=\"number\">1</span>) || <span class=\"built_in\">dfs</span>(board, word, i - <span class=\"number\">1</span>, j, index + <span class=\"number\">1</span>) || <span class=\"built_in\">dfs</span>(board, word, i, j + <span class=\"number\">1</span>, index + <span class=\"number\">1</span>) || <span class=\"built_in\">dfs</span>(board, word, i, j - <span class=\"number\">1</span>, index + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 递归之后再把当前的坐标复原</span></span><br><span class=\"line\">        board[i][j] = tmp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">exist</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; board.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>(); j ++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(board, word, i, j, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"年6月\">2023年6月</h4>\n<h5 id=\"颜色分类\">1、颜色分类</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-06-05 21.14.20.png\" alt=\"截屏2023-06-05 21.14.20\" style=\"zoom:50%;\" /></p>\n<p>感觉可以使用冒泡排序啊，原地进行排序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i != nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j != nums.<span class=\"built_in\">size</span>(); j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> tmp = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] &gt;= nums[j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    nums[i] = nums[j];</span><br><span class=\"line\">                    nums[j] = tmp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>嘿嘿，果然一个冒泡排序就可以解决。但是效率太差了。这里还有一个三指针的做法，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> right, <span class=\"type\">int</span> left)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> tmp = nums[right];</span><br><span class=\"line\">        nums[right] = nums[left];</span><br><span class=\"line\">        nums[left] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 0的右边界</span></span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2的左边界</span></span><br><span class=\"line\">        <span class=\"type\">int</span> left = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 指向当前数字</span></span><br><span class=\"line\">        <span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index &lt;= left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[index] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums, right++, index++);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[index] == <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums, left--, index);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[index] == <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                index ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr />\n<p>2023年6月5日21:28</p>\n<h4 id=\"week1\">2023-7-10（WEEK1）</h4>\n<p>😮‍💨最近这一个月太堕落了，一个月都没有做力扣题目QAQ！要好好补一下。</p>\n<p><strong>认识复杂度和简单排序算法</strong></p>\n<p>评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/选择排序</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">selectionSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr == <span class=\"literal\">NULL</span> || arr.<span class=\"built_in\">size</span>() &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; arr.<span class=\"built_in\">size</span>(); j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr, i, minIndex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> tmp = arr[i];</span><br><span class=\"line\">  arr[i] = arr[j];</span><br><span class=\"line\">  arr[j] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 冒泡排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>  <span class=\"title\">swap</span><span class=\"params\">(std::vector&lt;<span class=\"type\">int</span>&gt; &amp; arr; <span class=\"type\">int</span> i; <span class=\"type\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">arr[i] = arr[i] ^ arr[j];</span><br><span class=\"line\">arr[j] = arr[i] ^ arr[j];</span><br><span class=\"line\">arr[i] = arr[i] ^ arr[j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(std::vector&lt;<span class=\"type\">int</span>&gt; &amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.<span class=\"built_in\">size</span>() &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> e = arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; e &gt; <span class=\"number\">0</span>; e --)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; e; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &gt; arr[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(arr, i, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"section-1\">2023-10-8</h4>\n<p>周赛错题记录：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 12.09.20.png\" alt=\"截屏2023-10-08 12.09.20\" style=\"zoom:50%;\" /></p>\n<p>考虑两个数 <span class=\"math inline\">\\(a\\)</span>和 <span\nclass=\"math inline\">\\(b\\)</span>的二进制表示，讨论二进制第 <span\nclass=\"math inline\">\\(i\\)</span>位在 <span\nclass=\"math inline\">\\(a\\)</span>和 <span\nclass=\"math inline\">\\(b\\)</span>中是否为1的情况：</p>\n<ul>\n<li>若a和b的第i位都是0，那么<code>a AND b</code>\n和<code>a OR b</code>的第i位也都是0.</li>\n<li>若a和b的第i位恰有一个1，那么<code>a AND b</code>\n的第i位是0，<code>a OR b</code>的第i位是1.</li>\n<li>若 <em>a</em> 和 <em>b</em> 的第 i<em>i</em> 位都是 1，那么\n<code>a AND b</code> 和 <code>a OR b</code> 的第 i 位也都是 1。</li>\n</ul>\n<p>令<code>f(a)</code>表示<code>a</code>的二进制表示中有几个1，不难发现<code>f(a) + f(b) = f(a AND b) + f(a OR b)</code>。只不过所有的1首先都被\n<code>a OR b</code>抢了，剩下的1才会留给\n<code>a AND b</code>。也就是说，每个二进制位中，1的总数不变。只不过我们可以通过任意次操作，把1都集中在某个数里。为了选择<span\nclass=\"math inline\">\\(k\\)</span>个元素使得平方和最大，我们首先 要让<span\nclass=\"math inline\">\\(k\\)</span>个元素尽可能大。在 <span\nclass=\"math inline\">\\(k\\)</span>个元素的总和相同的情况下，我们还要让最大值尽可能大（证明可以考虑\n<span class=\"math inline\">\\(y=x^2+(c-x)^2\\)</span>的函数图像） 我们把 1\n都集中在某个数里，完美符合这两条性质。</p>\n<p>因此做法就是统计每个二进制位里有多少个1，然后用这些1拼出尽可能大的数。</p>\n<blockquote>\n<h3 id=\"按位与运算符\">按位与<a\nhref=\"https://so.csdn.net/so/search?q=运算符&amp;spm=1001.2101.3001.7020\">运算符</a>（&amp;）</h3>\n<p>参加运算的两个数据，按<strong>二进制位</strong>进行“与”运算。\n运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;\n即：<strong>两位同时为“1”，结果才为“1”，否则为0</strong></p>\n<h3 id=\"按位或运算符\">按位或运算符（|）</h3>\n<p>参加运算的两个对象，按二进制位进行“或”运算。 运算规则：0|0=0；\n0|1=1； 1|0=1； 1|1=1； 即\n：<strong>参加运算的两个对象只要有一个为1，其值为1</strong>。</p>\n<h3 id=\"异或运算符\">异或运算符（^）</h3>\n<p>参加运算的两个数据，按二进制位进行“异或”运算。 运算规则：0^0=0；\n0^1=1； 1^0=1； 1^1=0；\n即：<strong>参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</strong></p>\n<h3 id=\"按位取反运算符\">按位取反运算符（~）</h3>\n<p>按位取反运算符（~）是指将整数的各个二进制位都取反，即1变为0，0变为1。</p>\n<h3 id=\"按位左移运算符\">按位左移运算符（&lt;&lt;）</h3>\n<p>左移运算符是用来将一个数的各二进制位左移若干位，移动的位数由右操作数指定（右操作数必须是非负值），其右边空出的位用0填补，高位左移溢出则舍弃该高位。</p>\n<p>在高位没有1的情况下，左移1位相当于该数乘以2，左移2位相当于该数乘以2*2＝4,15＜＜2=60，即乘了４。\n但此结论只适用于该数左移时被溢出舍弃的高位中不包含1的情况。</p>\n<h3 id=\"按位右移运算符\">按位右移运算符（&gt;&gt;）</h3>\n<p>右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负值），移到右端的低位被舍弃，对于无符号数，高位补0。对于有符号数，某些机器将对左边空出的部分用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">int</span> MAXP = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"comment\">// cnt[i]表示第i个二进制位有几个1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> cnt[<span class=\"number\">35</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : nums)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= MAXP; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cnt[i] += x &gt;&gt; i &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// x 右移 i 位 第i位与1进行与运算。判断该位是否是1.</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 拼出尽可能大的k个数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = MAXP; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cnt[i])</span><br><span class=\"line\">                    <span class=\"comment\">// 表示 第i位为1 把第i位拼进now中。</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    now |= <span class=\"number\">1</span> &lt;&lt; i;</span><br><span class=\"line\">                    cnt[i]--;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = (ans + <span class=\"number\">1LL</span> * now * now) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 12.41.46.png\" alt=\"截屏2023-10-08 12.41.46\" style=\"zoom:50%;\" /></p>\n<p>什么时候返回-1？</p>\n<p>注意到，反转两个字符：</p>\n<ul>\n<li>如果都是0或者1，那么反转后1的个数会加2或者减2；</li>\n<li>如果一个是0另一个是1，那么反转后1的个数不变。</li>\n<li>所以，无论是那种操作，都不会改变字符串中的1的个数的奇偶性。</li>\n</ul>\n<p>故，只要两个字符串中的1的个数的奇偶性不同，就直接返回-1.</p>\n<p>然后，先考虑DP，在考虑贪心。毕竟DP就是对暴力搜索的优化。</p>\n<p>考虑 <span class=\"math inline\">\\(s_1\\)</span>和 <span\nclass=\"math inline\">\\(s_2\\)</span>的最后一对字符（也可以考虑第一对字符）：</p>\n<p>如果相同，那么无需修改。</p>\n<p>如果不同：</p>\n<p>选择第一种操作，相当于后面可以免费反转一个字符。</p>\n<p>选择第二种操作，那么下个字符要把0看作1，把1看作0.</p>\n<p>所以除了知道当前下标i，还需要知道免费反转次数j，以及上一个字符是否选择了第二种操作preRew.</p>\n<p>定义<span\nclass=\"math inline\">\\(dfs（i,j,preRew)\\)</span>，参数含义如下，返回值是在这种状态下的最小操作代价之和。</p>\n<p>分类讨论：</p>\n<p>如果<code>(s1[i] == s2[i]) == (not pre_rev)</code>表示s1[i]和s2[i]是相等的，无需操作，返回\n<span class=\"math inline\">\\(dfs(i - 1, j, false)\\)</span>。</p>\n<p>否则：</p>\n<p>选择第一种操作： <span class=\"math inline\">\\(dfs(i - 1, j + 1, false)\n+ x\\)</span>。</p>\n<p>选择第二种操作：<span class=\"math inline\">\\(dfs(i - 1, j, true) +\n1\\)</span></p>\n<p>如果 <span class=\"math inline\">\\(j &gt; 0\\)</span>免费反转一次：\n<span class=\"math inline\">\\(dfs(i - 1, j - 1, false)\\)</span>。</p>\n<p>这三种情况取最小值。</p>\n<p>递归边界，当 <span class=\"math inline\">\\(i &lt; 0\\)</span>时：</p>\n<p>如果 <span class=\"math inline\">\\(j &gt; 0\\)</span>或者 <span\nclass=\"math inline\">\\(preRew\\)</span>为真，那么不合法，返回 无穷大</p>\n<p>否则返回0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(string s1, string s2, <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 算出我们要处理的字符串</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; vec;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) vec.<span class=\"built_in\">push_back</span>(s1[i] == s2[i] ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">int</span> INF = <span class=\"number\">1e9</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> f[n + <span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span>; j++) <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">2</span>; k++) f[i][j][k] = INF;</span><br><span class=\"line\">        <span class=\"comment\">// 初值</span></span><br><span class=\"line\">        f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// dp</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span>; j++) <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">2</span>; k++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt = vec[i] ^ j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nxt) &#123;</span><br><span class=\"line\">                f[i + <span class=\"number\">1</span>][<span class=\"number\">1</span>][k] = <span class=\"built_in\">min</span>(f[i + <span class=\"number\">1</span>][<span class=\"number\">1</span>][k], f[i][j][k] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span>) f[i + <span class=\"number\">1</span>][<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"built_in\">min</span>(f[i + <span class=\"number\">1</span>][<span class=\"number\">0</span>][<span class=\"number\">1</span>], f[i][j][k] + x);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> f[i + <span class=\"number\">1</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"built_in\">min</span>(f[i + <span class=\"number\">1</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>], f[i][j][k]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                f[i + <span class=\"number\">1</span>][<span class=\"number\">0</span>][k] = <span class=\"built_in\">min</span>(f[i + <span class=\"number\">1</span>][<span class=\"number\">0</span>][k], f[i][j][k]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[n][<span class=\"number\">0</span>][<span class=\"number\">0</span>] &lt; INF ? f[n][<span class=\"number\">0</span>][<span class=\"number\">0</span>] : <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-10-08 20.54.56.png\" alt=\"截屏2023-10-08 20.54.56\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSetSize</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mp[arr[i]] ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; x: mp) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(x.second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = res.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum += res[i];</span><br><span class=\"line\">            cnt ++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt;= arr.<span class=\"built_in\">size</span>() / <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"子数组的最小值之和\">907.子数组的最小值之和</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-11-27 20.16.44.png\" alt=\"截屏2023-11-27 20.16.44\" style=\"zoom:50%;\" /></p>\n<p>一般来说，计算每个子数组的最小值之和，先是枚举每个子数组，在求出每个子数组的最小值，最后累加最小值。但是枚举每个子数组需要\n<span\nclass=\"math inline\">\\(O(n^2)\\)</span>的时间，而顺序扫描子数组并计算子数组的最小值，又需要\n<span\nclass=\"math inline\">\\(O(n)\\)</span>的时间，也就是说，对于正向思维来说，算法的时间复杂度为\n<span class=\"math inline\">\\(O(n^3)\\)</span>，这对于 <span\nclass=\"math inline\">\\(1 &lt;= n &lt; 3 *\n10^4\\)</span>的数据规模来说，是不可接受的，</p>\n<p>一种优化方向是 逆向思维。</p>\n<p>正向思维是枚举所有子数组，计算每个子数组的最小值，那么逆向思维是枚举数组中每个元素\n<span class=\"math inline\">\\(arr[i]\\)</span>作为最小值，然后统计以 <span\nclass=\"math inline\">\\(arr[i]\\)</span>为最小值的子数组个数。</p>\n<p>首先，枚举数组中每个元素 <span\nclass=\"math inline\">\\(arr[i]\\)</span>作为最小值，这个很简单，只需要\n<span class=\"math inline\">\\(O(n)\\)</span>时间，接下来，如何统计以 <span\nclass=\"math inline\">\\(arr[i]\\)</span>为最小值的子数组个数，这是解决问题的关键。</p>\n<p>枚举元素 <span class=\"math inline\">\\(arr[i]\\)</span>，计算以 <span\nclass=\"math inline\">\\(arr[i]\\)</span>为最小值的子数组个数，我们希望这个子问题能够在\n<span class=\"math inline\">\\(O(1)\\)</span>的时间内解决，或者至少在 <span\nclass=\"math inline\">\\(O（log n）\\)</span>时间内解决，因为如果是 <span\nclass=\"math inline\">\\(O(n)\\)</span>的话，算法整体时间复杂度为 <span\nclass=\"math inline\">\\(O(n^2)\\)</span>，这也是不行的。</p>\n<p>那么，问题就变成，如何在 <span\nclass=\"math inline\">\\(O(1)\\)</span>时间内统计以 <span\nclass=\"math inline\">\\(arr[i]\\)</span>为最小值的子数组个数，<code>在线计算</code>\n显然不可能，唯一可行的是，<code>离线</code>\n对数组进行预处理，而我们离线预处理信息，能够帮助我们在 <code>O(1)</code>\n时间内统计以 <code>arr[i]</code> 为最小值的子数组个数。</p>\n<p>计算\n<code>以 arr[i] 结尾且 arr[i] 为最小值的子数组个数</code>，我们只需要找到\n<code>arr[i]</code> 左侧第一个比 <code>arr[i]</code> 大的数；计算\n<code>以 arr[i] 开始且 arr[i] 为最小值的子数组个数</code>，我们只需要找到\n<code>arr[i]</code> 右侧第一个比 <code>arr[i]</code>\n大的数。从而把问题转化为求解两个 <a\nhref=\"https://leetcode.cn/problems/next-greater-element-i/\">496.\n下一个更大元素 I</a> 的子问题。这时候，使用 <code>单调栈</code>\n就非常显然了，因为求解 <code>下一个更大元素问题</code> 是\n<code>单调栈</code> 的 <code>模板题</code> ~</p>\n<p>上面我们定义了两个子问题：1. 计算\n<code>以 arr[i] 结尾且 arr[i] 为最小值的子数组个数</code>；2. 计算\n<code>以 arr[i] 开始且 arr[i] 为最小值的子数组个数</code>。稍加思考后，我们就会发现，这两个子问题的定义是有问题的，因为这样会出现\n<code>重复的子数组</code>。如果说一开始的 <code>逆向思维</code>\n是解决本题的\n<code>第一个难点</code>，那么，<code>如何重新定义上述两个子问题，使得不会统计重复的子数组</code>，则是解决本题的\n<code>第二个难点</code>，这个官解已经说了，大家看官解的时候，需要特别留意这一点\n~</p>\n<p>考虑所有满足以数组<code>arr</code>中的某个元素\n<code>arr[i]</code>为最右且最小的元素的子序列个数\n<code>C[i]</code>那么题目要求求连续子数组的最小值之和即为 <span\nclass=\"math inline\">\\(\\sum^{(n-1)}_{i = 0} arr_i \\times\nC_i\\)</span>，其中数组\n<code>arr</code>的长度为<code>n</code>。我们必须假设当前元素为最右边且最小的元素，这样才可以构造出互不相交的子序列。</p>\n<p>经过以上思考，我们只需要找到每个元素\n<code>arr[i]</code>以该元素为最右且最小的子序列的数目\n<code>left[i]</code>，以及以该元素为最左且最小的子序列的数目\n<code>right[i]</code>，则以\n<code>arr[i]</code>为最小元素的子序列的数目合计为\n<code>left[i]*right[i]</code>。为了防止重复计算，我们可以设置\n<code>arr[i]</code>左边的元素都必须满足小于等于<code>arr[i]</code>，<code>arr[i]</code>右边的元素必须满足严格小于<code>arr[i]</code>。当然这就变成求最小的下标\n<span class=\"math inline\">\\(j&lt;=i\\)</span>,且连续子序列中的元素\n<code>arr[j], arr[j+1], ..., arr[i]</code>都满足大于等于\n<code>arr[i]</code>，以及最大的下标 <span\nclass=\"math inline\">\\(k&gt;i\\)</span>满足连续子序列\n<code>arr[i+1],...,arr[k]</code>都满足严格大于\n<code>arr[i]</code>上述即转化为经典的单调栈问题，即求数组中当前元素\n<span class=\"math inline\">\\(x\\)</span>左边第一个小于 <span\nclass=\"math inline\">\\(x\\)</span>的元素以及右边第一个小于等于 <span\nclass=\"math inline\">\\(x\\)</span>的元素。</p>\n<p>具体做法：</p>\n<ul>\n<li><p>求左边第一个小于<code>arr[i]</code>的元素：从左向右遍历数组，并维护一个单调递增的栈，遍历当前元素<code>arr[i]</code>，如果遇到当前栈顶的元素大于等于<code>arr[i]</code>则将其弹出，直到栈顶元素小于<code>arr[i]</code>，栈顶元素即为左边第一个小于<code>arr[i]</code>的元素<code>arr[j]</code>，此时<code>left[i]=i-j</code>.</p></li>\n<li><p>求右边第一个大于等于 arr[i]\n的元素：从右向左遍历数组，维护一个单调递增的栈，遍历当前元素\narr[i]，如果遇到当前栈顶的元素大于 arr[i]\n则将其弹出，直到栈顶的元素小于等于\narr[i]，栈顶的元素即为右边第一个小于等于 arr[i] 的元素 arr[k]，此时\nright[i]=k−i。</p></li>\n<li><p>连续子数组 arr[j],arr[j+1],⋯ ,arr[k]的最小元素即为 arr[i]，以\narr[i] 为最小元素的连续子序列的数量为 (i−j)×(k−i)(i - j)。</p></li>\n<li></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumSubarrayMins</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; monoStack;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">left</span><span class=\"params\">(n)</span>, <span class=\"title\">right</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!monoStack.<span class=\"built_in\">empty</span>() &amp;&amp; arr[i] &lt;= arr[monoStack.<span class=\"built_in\">back</span>()]) monoStack.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            left[i] = i - (monoStack.<span class=\"built_in\">empty</span>() ? <span class=\"number\">-1</span> : monoStack.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">            monoStack.<span class=\"built_in\">emplace_back</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        monoStack.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!monoStack.<span class=\"built_in\">empty</span>() &amp;&amp; arr[i] &lt; arr[monoStack.<span class=\"built_in\">back</span>()]) monoStack.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            right[i] = (monoStack.<span class=\"built_in\">empty</span>() ? n : monoStack.<span class=\"built_in\">back</span>()) - i;</span><br><span class=\"line\">            monoStack.<span class=\"built_in\">emplace_back</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            ans = (ans + (<span class=\"type\">long</span> <span class=\"type\">long</span>)left[i] * right[i] * arr[i]) % mod;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"无限集中的最小数字\">2336.无限集中的最小数字</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-11-29%2010.54.01.png\"\nalt=\"截屏2023-11-29 10.54.01\" />\n<figcaption aria-hidden=\"true\">截屏2023-11-29 10.54.01</figcaption>\n</figure>\n<p>利用哈希的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SmallestInfiniteSet</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">SmallestInfiniteSet</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1005</span>; i++) hash[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">popSmallest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cnt &lt; <span class=\"number\">1000</span> &amp;&amp; !hash[cnt])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cnt ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hash[cnt] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addBack</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        hash[num % <span class=\"number\">1005</span>] = <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> hash[<span class=\"number\">1005</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your SmallestInfiniteSet object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * SmallestInfiniteSet* obj = new SmallestInfiniteSet();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj-&gt;popSmallest();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj-&gt;addBack(num);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"个位数为k的整数之和\">2310.个位数为K的整数之和</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-11-29 13.41.51.png\" alt=\"截屏2023-11-29 13.41.51\" style=\"zoom:50%;\" /></p>\n<p>枚举+利用同余性质优化至 <span\nclass=\"math inline\">\\(O(1)\\)</span>时间复杂度</p>\n<p>首先分析一下答案至少之多是多少，答案范围比较小，我们可以尝试枚举答案\n<span\nclass=\"math inline\">\\(n\\)</span>。把个位数单独拆开看，每个数可以表示为<span\nclass=\"math inline\">\\(10\\)</span>的倍数加上 <span\nclass=\"math inline\">\\(k\\)</span>的形式。由于这 <span\nclass=\"math inline\">\\(n\\)</span>个数都以 <span\nclass=\"math inline\">\\(k\\)</span>结尾，那么 <span\nclass=\"math inline\">\\(num-nk\\)</span>必须是 <span\nclass=\"math inline\">\\(10\\)</span> 的倍数。从小到大枚举 <span\nclass=\"math inline\">\\(n\\)</span> ，找到第一个满足 <span\nclass=\"math inline\">\\(num-nk\\)</span> 是 $ 10$ 倍数的 <span\nclass=\"math inline\">\\(n\\)</span> 。由于 <span\nclass=\"math inline\">\\(n\\)</span> 不会超过 <span\nclass=\"math inline\">\\(num\\)</span> ，我们至多枚举到 <span\nclass=\"math inline\">\\(num\\)</span> 时停止。注意特判 <span\nclass=\"math inline\">\\(num=0\\)</span> 的情况，此时返回 <span\nclass=\"math inline\">\\(0\\)</span> 。</p>\n<p>进一步，由于 <span class=\"math display\">\\[\nn \\cdot k \\equiv (n \\mod 10) \\cdot k (\\mod 10)\n\\]</span></p>\n<p>枚举到 <span class=\"math inline\">\\(n = 11\\)</span> 时， $(num -\nnk)mod 10 $ 的结果会和 <span class=\"math inline\">\\(n=1\\)</span>\n时相同，对于更大的 <span class=\"math inline\">\\(n\\)</span> 也会和 <span\nclass=\"math inline\">\\(n mod 10\\)</span> 相同。因此，至多枚举到 <span\nclass=\"math inline\">\\(n=10\\)</span> 就行了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minimumNumbers</span><span class=\"params\">(<span class=\"type\">int</span> num, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> n = <span class=\"number\">1</span>; n &lt;= <span class=\"number\">10</span> &amp;&amp; num - k * n &gt;= <span class=\"number\">0</span>; ++n) <span class=\"keyword\">if</span> ((num - k * n) % <span class=\"number\">10</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拼车\">1094.拼车</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 13.41.48.png\" alt=\"截屏2023-12-02 13.41.48\" style=\"zoom:50%;\" /></p>\n<p>首先第一想法是记录每个站点的人数，简单的哈希算法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">carPooling</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; trips, <span class=\"type\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sumPassengers = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum[<span class=\"number\">1005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1005</span>; i++) sum[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1005</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; trips.<span class=\"built_in\">size</span>(); j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; trips[j][<span class=\"number\">2</span>] &amp;&amp; i &gt;= trips[j][<span class=\"number\">1</span>]) sum[i] += trips[j][<span class=\"number\">0</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1005</span>; i++) <span class=\"keyword\">if</span> (sum[i] &gt; capacity) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后续看到别人的方法，还有差分的方法，</p>\n<p><strong>图解差分 入门 （“前缀和” 到 “差分” 丝滑过度）</strong></p>\n<p><strong>差分</strong></p>\n<p>从朴素的想法开始：创建一个数组 <code>cnt</code>\n，用于存储从某个站点出发时，车上的乘客数量。例如 <span\nclass=\"math inline\">\\(cnt[x]=c\\)</span> 含义为在站点 <span\nclass=\"math inline\">\\(x\\)</span>\n出发时（在该站点的下车和上车均完成），车上乘客数为 <span\nclass=\"math inline\">\\(c\\)</span> 个。对于每个 <span\nclass=\"math inline\">\\(trips[i]=(x,a,b)\\)</span> ，我们需要对 <span\nclass=\"math inline\">\\([a,b)\\)</span> 范围内的 <span\nclass=\"math inline\">\\(cnt[j]\\)</span> 进行加 <span\nclass=\"math inline\">\\(c\\)</span> 操作。处理完 <code>trips</code>\n后，检查所有站点的乘客人数，根据是否满足 <code>capacity</code>\n限制返回答案。因此，这是一个关于 <code>区间修改，单点查询</code>\n的经典问题，可使用差分求解。</p>\n<p>所谓<strong>差分</strong> ，是指\n<strong>原数组中每个元素与前一元素之差所形成的数组</strong>\n，与之相对应的是“前缀和”\n。我们知道，对原数组进行诸位累加（前缀计算操作），所得到的数组为前缀和数组。差分数组，则是对其执行前缀计算后，能够得到原数组的那个数组。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 14.16.30.png\" alt=\"截屏2023-12-02 14.16.30\" style=\"zoom:50%;\" /></p>\n<p>前缀和数组的主要作用，是利用 <code>容斥原理</code>\n快速求解某段之和。例如要查询原数组 <code>nums</code> 中下标范围\n<code>[l,r]</code> 的和，可通过 <code>sum[r]-sum[l-1]</code>\n快速求解。</p>\n<p>差分数组的主要作用，是帮助快速修改某段区间。</p>\n<p>由于差分数组执行 <code>前缀计算</code>\n后得到的是原数组，因此在差分数组上修改某个值，会对原数组某段后缀产生相同的影响。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-02 14.20.56.png\" alt=\"截屏2023-12-02 14.20.56\" style=\"zoom:50%;\" /></p>\n<p>因此，<strong>当我们想要对原数组的 <code>[l,r]</code>\n进行整体修改时，只需要对差分数组的 <code>l</code> 和 <code>r+1</code>\n位置执行相应操作即可。</strong></p>\n<p>举个例子，假设想对原数组 <code>nums</code> 的 <code>[l,r]</code>\n进行整体“加一”操作，那么可转换为对差分数组 <code>c[l]</code>\n的加一操作（等价对原数组的 <code>[l,n-1]</code>\n进行加一），以及对差分数组 <code>c[r+1]</code>\n的减一操作（等价于对原数组的 <code>[r+1,n-1]</code> 进行减一， 最终只有\n<code>[l,r]</code> 有加一效果）。</p>\n<p>至此，我们完成了对差分的基本学习：<strong>将原数组的区间修改等价为差分数组的特定位置修改</strong>。</p>\n<p>回到本题，起始先用 <code>nums</code> 来作为差分数组，对于 <span\nclass=\"math inline\">\\(trips[i]=(c,a,b)\\)</span> ，有 <span\nclass=\"math inline\">\\(c\\)</span> 个乘客在 <span\nclass=\"math inline\">\\(a\\)</span> 点上车，在 <span\nclass=\"math inline\">\\(b\\)</span> 点下车，因此对 <code>[a,b)</code>\n进行整体加 <span class=\"math inline\">\\(c\\)</span> 操作，对应差分数组操作\n<code>nums[a] += c; nums[b] -= c</code>。</p>\n<p>处理完 <span class=\"math inline\">\\(trips\\)</span> 后，对差分数组\n<code>nums</code> 进行前缀计算 （可直接复用\n<code>nums</code>，进行原地计算），便可得到各个站点的乘客数量，与\n<code>capacity</code> 比较答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">carPooling</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; trips, <span class=\"type\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(<span class=\"number\">1010</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; t :trips)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> c = t[<span class=\"number\">0</span>], a = t[<span class=\"number\">1</span>], b = t[<span class=\"number\">2</span>];</span><br><span class=\"line\">            nums[a + <span class=\"number\">1</span>] += c;</span><br><span class=\"line\">            nums[b + <span class=\"number\">1</span>] -= c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">1000</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nums[i] += nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; capacity) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"可获得的最大点数\">1423.可获得的最大点数</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-03%2012.32.08.png\"\nalt=\"截屏2023-12-03 12.32.08\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-03 12.32.08</figcaption>\n</figure>\n<p><strong>滑动窗口</strong></p>\n<p>从两边选卡片，选 <code>k</code> 张，卡片总数量为 <code>n</code>\n张，即有 <code>n-k</code> 张不被选择。所有卡片总和 <code>sum</code>\n固定，要使选择的 <code>k</code> 张的总和最大，反过来就是要让不被选择的\n<code>n-k</code> 张总和最小。原问题等价为\n：<strong>从<code>cardPoints</code> 中找长度为 <code>n-k</code>\n的连续段，使其总和最小</strong>。</p>\n<p>具体来说，用变量 <code>sum</code> 代指 <code>cardPoints</code> 总和，\n<code>cur</code>代表长度固定为 <code>n-k</code>的当前窗口总和，\n<code>minv</code> 代表所有长度为 <code>n-k</code>\n的窗口总和最小的值。</p>\n<p>起始先将滑动窗口压满，取得第一个滑动窗口的目标值 <code>cur</code>\n（同时更新为 <code>minv</code>） ，随后往后继续处理\n<code>cardPoints</code>\n，每往前滑动一位，需要删除一个和添加一个元素，并不断更新\n<code>minv</code> ，最终 <code>sum-minv</code>即是答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxScore</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; cardPoints, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; cardPoints.<span class=\"built_in\">size</span>(); i++) sum += cardPoints[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; cardPoints.<span class=\"built_in\">size</span>() - k; i++) cur += cardPoints[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> minv = cur;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = cardPoints.<span class=\"built_in\">size</span>() - k; i &lt; cardPoints.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cur = cur + cardPoints[i] - cardPoints[i - cardPoints.<span class=\"built_in\">size</span>() + k];</span><br><span class=\"line\">            minv = <span class=\"built_in\">min</span>(minv, cur); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum - minv;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"需要添加的硬币的最小数量\">100153.需要添加的硬币的最小数量</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-03%2013.22.21.png\"\nalt=\"截屏2023-12-03 13.22.21\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-03 13.22.21</figcaption>\n</figure>\n<p><strong>用归纳法思考</strong></p>\n<p>为了方便描述，把0也算作可以得到的数。假设现在得到了 <span\nclass=\"math inline\">\\([1,s-1]\\)</span>\n内的所有整数，如果此时新发现了一个整数 <span\nclass=\"math inline\">\\(x\\)</span> ,那么把 <span\nclass=\"math inline\">\\(x\\)</span> 加到已得到的数字中，就得到了 <span\nclass=\"math inline\">\\([x,s + x-1]\\)</span> 内的所有整数。</p>\n<p>分类讨论：</p>\n<ol type=\"1\">\n<li>如果 <span class=\"math inline\">\\(x\\leq s\\)</span>\n，那么合并这两个区间，我们可以得到 <span\nclass=\"math inline\">\\([0,s+x-1]\\)</span> 内的所有整数。</li>\n<li>如果 <span class=\"math inline\">\\(x&gt;s\\)</span>\n，这意味着我们无法得到 <span class=\"math inline\">\\(s\\)</span>\n，那么就一定要把 <span class=\"math inline\">\\(s\\)</span>\n加到数组中，这样就可以得到 <span class=\"math inline\">\\([s,2s-1]\\)</span>\n内的所有整数，再与 <span class=\"math inline\">\\([0,s-1]\\)</span>\n合并，可以得到 <span class=\"math inline\">\\([0,2s-1]\\)</span>\n内的所有整数。</li>\n</ol>\n<p>把 <span class=\"math inline\">\\(coins\\)</span> 排序，从小到大考虑\n<span class=\"math inline\">\\(x=coins[i]\\)</span>\n。按照上述分类讨论来看是否要添加数字。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minimumAddedCoins</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; coins, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(coins.<span class=\"built_in\">begin</span>(), coins.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>, s = <span class=\"number\">1</span>, i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s &lt;= target)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; coins.<span class=\"built_in\">size</span>() &amp;&amp; coins[i] &lt;= s)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                s += coins[i];</span><br><span class=\"line\">                i ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                s *= <span class=\"number\">2</span>;</span><br><span class=\"line\">                ans ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"统计完全子字符串\">100145.统计完全子字符串</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-03 13.37.33.png\" alt=\"截屏2023-12-03 13.37.33\" style=\"zoom:50%;\" /></p>\n<p><strong>相邻字母相差至多为2</strong> 这个约束把 <code>word</code>\n划分成了多个子串 <code>s</code>\n每个子串分别处理。可以用<strong>分组循环</strong>找到每个子串\n<code>s</code>。</p>\n<blockquote>\n<p>分组循环</p>\n<p>指的是将整个数组或者字符串分成很多片段，这些片段的判断处理逻辑是一样的。分组循环需要使用同向双指针，但是与滑动窗口不同的是，滑动窗口是收集左右区间内连续数组或者字符串，当不满足收集要求时移动右指针，而当满足后移动左指针，此时左指针移动到原来左指针的下一位，而分组循环是左指针移动到右指针下一位。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模版 l,r 分别表示左右指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (r &lt; n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 每一次求新区间则重新赋值l</span></span><br><span class=\"line\">\tl = r；</span><br><span class=\"line\"> <span class=\"comment\">// r 表示最长连续区间最后一个</span></span><br><span class=\"line\"> <span class=\"keyword\">while</span> (r &lt; n - <span class=\"number\">1</span> &amp;&amp; s[r] == s[r + <span class=\"number\">1</span>])</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   \tr ++;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 求完区间后收集结果</span></span><br><span class=\"line\">\tres = <span class=\"built_in\">max</span>(r - l + <span class=\"number\">1</span>, res);</span><br><span class=\"line\">\t<span class=\"comment\">// 并移动r到下一个</span></span><br><span class=\"line\">\tr ++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>对于每个子串，由于每个字符恰好出现 <code>k</code> 次，我们可以枚举有\n<code>m</code> 种字符，这样问题就变成了：</p>\n<p>长度固定为 <code>m·k</code> 的滑动窗口，判断每种字符是否都出现了恰好\n<code>k</code>次。</p>\n<h4 id=\"从二叉搜索树到更大和树\">1038.从二叉搜索树到更大和树</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04%2020.34.57.png\"\nalt=\"截屏2023-12-04 20.34.57\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-04 20.34.57</figcaption>\n</figure>\n<p>打卡题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 遍历</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bst</span><span class=\"params\">(TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">bst</span>(root-&gt;right);</span><br><span class=\"line\">        cnt += root-&gt;val;</span><br><span class=\"line\">        root-&gt;val = cnt;</span><br><span class=\"line\">        <span class=\"built_in\">bst</span>(root-&gt;left);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">bstToGst</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">bst</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"有序数组中差绝对值之和\">1685.有序数组中差绝对值之和</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04%2020.37.32.png\"\nalt=\"截屏2023-12-04 20.37.32\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-04 20.37.32</figcaption>\n</figure>\n<p>利用前缀和解决，首先计算出前缀和，然后遍历<code>nums</code>，以当前元素<code>nums[i]</code>\n为分界点， <code>i</code>前边的元素一定是比\n<code>nums[i]</code>小，<code>i</code>后边的元素一定比\n<code>nums[i]</code>大。这时，我们把这个问题放在二维空间看。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-04%2020.46.32.png\"\nalt=\"截屏2023-12-04 20.46.32\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-04 20.46.32</figcaption>\n</figure>\n<p>比如在 <code>i=1</code>的位置在<code>nums[1]</code>左边的比\n<code>nums[1]</code> 小，此时<code>sum(|nums[i]-nums[j]|)</code>\n为左边的橙色面积。可以写为 <code>left=nums[i] * i - f[i]</code>\n。同理，右边部分为 右边橙色面积 ，可以写为\n<code>f[n]-f[i] - (n - i) * nums[i]</code>\n。这样，就可以把<code>result[i]</code> 的求解过程等价为\n<code>nums[i]</code> 左右两边的面积。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getSumAbsoluteDifferences</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> f[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) f[i + <span class=\"number\">1</span>] = f[i] + nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> target = nums[i];</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> left = target * i - f[i];</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> right = f[n] - f[i] - (n - i) * target;</span><br><span class=\"line\">            res[i] = left + right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"到达首都的最少油耗\">2477.到达首都的最少油耗</h4>\n<p><img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-05%2010.27.40.png\"\nalt=\"截屏2023-12-05 10.27.40\" /><strong>贪心+深度优先搜索 </strong></p>\n<p>题目等价于给出了一棵以节点<span class=\"math inline\">\\(0\\)</span>\n为根结点的树，并且初始树上的每一个节点上都有一个人，现在所有人都需要通过\n<code>车子</code> 向节点 <span class=\"math inline\">\\(0\\)</span>\n移动。</p>\n<p>对于某一节点 <span class=\"math inline\">\\(x\\)</span> ，<span\nclass=\"math inline\">\\(x\\neq 0\\)</span> ，其父节点为 <span\nclass=\"math inline\">\\(y\\)</span> 。因为以节点 <span\nclass=\"math inline\">\\(x\\)</span> 为根结点的子树上的人都需要通过边 <span\nclass=\"math inline\">\\(x\\to y\\)</span> 向节点 <span\nclass=\"math inline\">\\(0\\)</span> 移动，所以为了使这条边上的\n<code>车子</code> 利用率最高，我们贪心的让 <span\nclass=\"math inline\">\\(x\\)</span> 的全部子节点上的人到了节点 <span\nclass=\"math inline\">\\(x\\)</span> 后再一起坐车向上移动，我们不妨设以节点\n<span class=\"math inline\">\\(x\\)</span> 为根节点的子树大小为 <span\nclass=\"math inline\">\\(cnt_x\\)</span> 那么我们至少需要\n<code>车子</code>的数量为 <span class=\"math inline\">\\(\\lceil\n\\frac{cnt_x}{seats} \\rceil\\)</span> ，其中 <span\nclass=\"math inline\">\\(seatx\\)</span> 为一辆车的给定座位数。</p>\n<p>那么，我们可以通过从根节点 <span class=\"math inline\">\\(0\\)</span>\n往下进行 <code>深度优先搜索</code> ，每一条边上\n<code>车子🚗</code>的数目即为该条边上汽油的开销，统计全部边上汽油的开销即为最终答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">minimumFuelCost</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; roads, <span class=\"type\">int</span> seats)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = roads.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;e : roads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            g[e[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            g[e[<span class=\"number\">1</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        function&lt;<span class=\"type\">int</span>(<span class=\"type\">int</span>, <span class=\"type\">int</span>)&gt; dfs = [&amp;](<span class=\"type\">int</span> cur, <span class=\"type\">int</span> fa) -&gt; <span class=\"type\">int</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> peopleSum = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> ne : g[cur])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ne != fa) <span class=\"comment\">// 判断是否是同一棵子树</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> peopleCnt = <span class=\"built_in\">dfs</span>(ne, cur);</span><br><span class=\"line\">                    peopleSum += peopleCnt;</span><br><span class=\"line\">                    res += (peopleCnt + seats - <span class=\"number\">1</span>) / seats;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> peopleSum;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>之前卡住的原因主要在，不知道怎么确定一条支路走到头。这里了很明显</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">dfs(0, -1)</span></span><br><span class=\"line\"><span class=\"comment\">dfs(1, 0)</span></span><br><span class=\"line\"><span class=\"comment\">dfs(3, 1)</span></span><br><span class=\"line\"><span class=\"comment\">dfs(2, 3)</span></span><br><span class=\"line\"><span class=\"comment\">dfs(3, 3)</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4\nid=\"统计网格图中没有被保卫的格子数\">2257.统计网格图中没有被保卫的格子数</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-06%2009.59.40.png\"\nalt=\"截屏2023-12-06 09.59.40\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-06 09.59.40</figcaption>\n</figure>\n<p><strong>广度优先搜索+存储每个格子的状态</strong></p>\n<p>为了方便操作，我们可以用二维数组 <code>grid</code>\n来表示网格图的状态。其中，警卫对应的状态值为<span\nclass=\"math inline\">\\(-1\\)</span> ，墙对应的状态值为 <span\nclass=\"math inline\">\\(-2\\)</span> ，未被保卫的格子对应的状态值为 <span\nclass=\"math inline\">\\(0\\)</span>\n，被保卫的格子对应的状态值为正整数。二维数组的初始值均为 <span\nclass=\"math inline\">\\(0\\)</span> ，随后我们遍历 <code>guards</code> 和\n<code>walls</code> 数组对应更新网格图。</p>\n<p>在恢复了网格图后，我们可以使用广度优先搜索维护每个格子的状态。由于视线是向特定方向的，因此在广度优先搜索的过程中，除了要维护格子的横纵坐标，还要维护当前的视线方向。我们用\n<span class=\"math inline\">\\((i,j,k)\\)</span>\n来表示广度优先搜索的状态，其中 <span\nclass=\"math inline\">\\((i,j)\\)</span> 代表当前点的横纵坐标， <span\nclass=\"math inline\">\\(k\\)</span> 为 <span\nclass=\"math inline\">\\([0,3]\\)</span>\n闭区间内整数，分别代表右、上、左、下的视线方向。同样的，为了防止每个非警卫或者墙的点被重复或遗漏，我们用\n<span class=\"math inline\">\\(4\\)</span>\n个二进制位组成的正整数来表示该格子的状态，其中从低到高的第 <span\nclass=\"math inline\">\\(k\\)</span> 位为 <span\nclass=\"math inline\">\\(1\\)</span> 代表有指向第 <span\nclass=\"math inline\">\\(k\\)</span>\n个方向的视线经过该点，反之则代表没有。</p>\n<p>我们用队列 <span class=\"math inline\">\\(q\\)</span>\n来进行广度优先搜索。首先，对于每个警卫点 <span\nclass=\"math inline\">\\((i,j)\\)</span>\n，由于警卫可以看到四个方向，因此我们需要将 <span\nclass=\"math inline\">\\(k\\)</span> 为 <span\nclass=\"math inline\">\\([0,3]\\)</span> 闭区间内对应的四种状态 <span\nclass=\"math inline\">\\((i,j,k)\\)</span> 全部加进队列。</p>\n<p>当遍历到 <span class=\"math inline\">\\((x,y,k)\\)</span>\n时，我们首先计算沿着该视线方向的下一个坐标 <span\nclass=\"math inline\">\\((n_x,n_y)\\)</span>\n，如果该坐标不合法或为墙或警卫，则我们直接跳过该坐标；对于余下的情况，我们需要检查该坐标对应状态\n<span class=\"math inline\">\\(grid[i][j]\\)</span> 中从低到高的第 <span\nclass=\"math inline\">\\(k\\)</span> 位的数值。此时有两种情况：</p>\n<ul>\n<li>第 <span class=\"math inline\">\\(k\\)</span> 位为<span\nclass=\"math inline\">\\(1\\)</span> ，则说明该坐标及视线方向对应的状态\n<span class=\"math inline\">\\((n_x,n_y,k)\\)</span>\n已被遍历过，我们直接跳过即可；</li>\n<li>第 <span class=\"math inline\">\\(k\\)</span> 位为 <span\nclass=\"math inline\">\\(0\\)</span> ，则说明该坐标及视线方向对应的状态\n<span class=\"math inline\">\\(n_x,n_y,k\\)</span>\n未被遍历过，我们需要将该位置为 <span class=\"math inline\">\\(1\\)</span>\n，并将该状态加入队列 <span class=\"math inline\">\\(q\\)</span>\n的尾部。</li>\n</ul>\n<p>最终，当广度优先搜索完成时，一个格子未被保卫当且仅当 <span\nclass=\"math inline\">\\(grid\\)</span> 中的对应状态值为 <span\nclass=\"math inline\">\\(0\\)</span> 。我们只需要遍历 <span\nclass=\"math inline\">\\(grid\\)</span> ，维护数值为 <span\nclass=\"math inline\">\\(0\\)</span> 的格子数量，并返回即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">countUnguarded</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; guards, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; walls)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">grid</span>(m, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (n));  <span class=\"comment\">// 网格状态数组</span></span><br><span class=\"line\">        queue&lt;tuple&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; q;   <span class=\"comment\">// 广度优先搜索队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 每个方向的单位向量</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; dx = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; dy = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; guard : guards)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            grid[guard[<span class=\"number\">0</span>]][guard[<span class=\"number\">1</span>]] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将四个方向视线对应的状态均添加进搜索队列中</span></span><br><span class=\"line\">                q.<span class=\"built_in\">emplace</span>(guard[<span class=\"number\">0</span>], guard[<span class=\"number\">1</span>], k);</span><br><span class=\"line\">                <span class=\"comment\">// 比如，(0, 0) 这时候加入的就是 (0, 0, 0), (0, 0, 1), (0, 0 ,2), (0, 0, 3)</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; wall : walls) grid[wall[<span class=\"number\">0</span>]][wall[<span class=\"number\">1</span>]] = <span class=\"number\">-2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [x, y, k] = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> nx = x + dx[k];</span><br><span class=\"line\">            <span class=\"type\">int</span> ny = y + dy[k];</span><br><span class=\"line\">            <span class=\"comment\">// 太优雅了， k = 0 时， 代表 (nx, ny) -&gt; (nx + 1, ny + 0) 这时候对应向下的视线</span></span><br><span class=\"line\">            <span class=\"comment\">//  k = 1 时，(nx, ny) -&gt; (nx + 0, ny + 1) 右</span></span><br><span class=\"line\">            <span class=\"comment\">// k = 2, (nx, ny) -&gt; (nx - 1, ny + 0) 上</span></span><br><span class=\"line\">            <span class=\"comment\">// k = 3, (nx, ny) -&gt; (nx + 0, ny - 1) 左</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 沿着视线方向的下一个坐标合法，且不为警卫或墙</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((grid[nx][ny] &amp; (<span class=\"number\">1</span> &lt;&lt; k)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 对应状态未遍历过</span></span><br><span class=\"line\">                    grid[nx][ny] |= (<span class=\"number\">1</span> &lt;&lt; k);</span><br><span class=\"line\">                    q.<span class=\"built_in\">emplace</span>(nx, ny, k);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"number\">0</span>) res ++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最小化旅行的价格总和\">2646.最小化旅行的价格总和</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-06%2010.44.48.png\"\nalt=\"截屏2023-12-06 10.44.48\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-06 10.44.48</figcaption>\n</figure>\n<p><strong>暴力DFS每条路径</strong></p>\n<p>对每个 <code>trips[i]</code> 都 DFS 一次这棵树，在 DFS 的过程中，把\n<code>start</code> 到 <code>end</code> 的路径上的每个点 <span\nclass=\"math inline\">\\(x\\)</span> 的经过次数 <span\nclass=\"math inline\">\\(cnt[x]\\)</span> 都加一。</p>\n<p>既然知道了每个点会被经过多少次，把 <code>price[i]</code> 更新为\n<code>price[i]·cnt[i]</code> ，问题就转换为计算减半后的\n<code>price[i]</code> 之和的最小值。注意 <code>cnt[i]=0</code> 时\n<code>price[0]</code> 会被更新为 <span class=\"math inline\">\\(0\\)</span>\n，我们无需考虑没有经过的节点。</p>\n<p>对于转换后的问题，我们随便选一个节点出发 DFS 。在 DFS\n的过程中，对于节点 <span class=\"math inline\">\\(x\\)</span> 及其儿子 <span\nclass=\"math inline\">\\(y\\)</span> ，分类讨论：</p>\n<ul>\n<li>如果 <code>price[x]</code> 不变，那么 <code>price[y]</code>\n可以减半，也可以不变，取这两种情况的最小值；</li>\n<li>如果<code>price[x]</code> 减半，那么\n<code>price[y]</code>只能不变。</li>\n</ul>\n<p>因此子树 <span class=\"math inline\">\\(x\\)</span> 需要返回两个值</p>\n<ul>\n<li><code>price[x]</code> 不变时的子树 <span\nclass=\"math inline\">\\(x\\)</span> 的最小价值总和；</li>\n<li><code>price[x]</code> 减半时的子树 <span\nclass=\"math inline\">\\(x\\)</span> 的最小价值总和；</li>\n</ul>\n<p>答案就是根结点不变/减半的最小值。</p>\n<p>以 <code>start</code> 为树根 DFS ，找到 <code>end</code> 时，\n<code>end</code> 及其祖先节点就恰好组成了从 <code>start</code> 到\n<code>end</code> 的路径。</p>\n<h4 id=\"最小路径和\">64.最小路径和</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-07%2019.45.13.png\"\nalt=\"截屏2023-12-07 19.45.13\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-07 19.45.13</figcaption>\n</figure>\n<p>此题是典型的动态规划题目。</p>\n<ol type=\"1\">\n<li>状态定义 设 <span class=\"math inline\">\\(dp\\)</span> 为大小 <span\nclass=\"math inline\">\\(m\\times n\\)</span> 矩阵，其中 <span\nclass=\"math inline\">\\(dp[i][j]\\)</span> 的值代表直到走到 <span\nclass=\"math inline\">\\((i, j)\\)</span> 的最小路径和</li>\n<li>转移方程 题目要求，只能向右或向下走，换句话说，当前单元格 <span\nclass=\"math inline\">\\((i,j)\\)</span> 只能从左边的单元格 <span\nclass=\"math inline\">\\((i-1,j)\\)</span> 或者上边的单元格 <span\nclass=\"math inline\">\\((i, j -1)\\)</span>\n走到，因此只需要考虑矩阵的左边界和上边界。</li>\n</ol>\n<p>走到当前单元格 <span class=\"math inline\">\\((i,j)\\)</span>\n的最小路径和 = “从左方单元格 <span\nclass=\"math inline\">\\((i-1,j)\\)</span> 与从上方单元格 <span\nclass=\"math inline\">\\((i,j-1)\\)</span> 走来的\n<strong>两个最小路径和中较小的</strong> ”+当前单元格值 <span\nclass=\"math inline\">\\(grid[i][j]\\)</span> 。具体分为以下 <span\nclass=\"math inline\">\\(4\\)</span> 种情况：</p>\n<ol type=\"1\">\n<li>当左边和上边都不是矩阵边界时：即当 <span class=\"math inline\">\\(i\\neq\n0,j\\neq 0\\)</span> 时， <span class=\"math inline\">\\(dp[i][j] =\nmin(dp[i-1][j], dp[i][j-1])+grid[i][j]\\)</span></li>\n<li>当只有左边是矩阵边界时：只能从上边来，即当 <span\nclass=\"math inline\">\\(i=0,j\\neq 0\\)</span> 时，<span\nclass=\"math inline\">\\(dp[i][j] = dp[i][j-1] + grid[i][j]\\)</span></li>\n<li>当只有上边是矩阵边界时：只能从左边来，即当 <span\nclass=\"math inline\">\\(i\\neq0 j = 0\\)</span> 时， <span\nclass=\"math inline\">\\(dp[i][j]=dp[i-1][j] + grid[i][j]\\)</span></li>\n<li>当左边和上边都是矩阵边界时：即当 <span\nclass=\"math inline\">\\(i=0,j=0\\)</span> 时，<span\nclass=\"math inline\">\\(dp[i][j]=grid[i][j]\\)</span></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minPathSum</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = grid.<span class=\"built_in\">size</span>(), m = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) grid[i][j] = grid[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j != <span class=\"number\">0</span>) grid[i][j] = <span class=\"built_in\">min</span>(grid[i<span class=\"number\">-1</span>][j], grid[i][j - <span class=\"number\">1</span>]) + grid[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; j != <span class=\"number\">0</span>) grid[i][j] = grid[i][j - <span class=\"number\">1</span>] + grid[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) grid[i][j] = grid[i - <span class=\"number\">1</span>][j] + grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> grid[n - <span class=\"number\">1</span>][m - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"重新规划路线\">1466.重新规划路线</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-07%2020.06.21.png\"\nalt=\"截屏2023-12-07 20.06.21\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-07 20.06.21</figcaption>\n</figure>\n<p>题目给定一张由 <code>n</code> 个点（使用 <code>0</code> 到\n<code>n-1</code> 编号），<code>n-1</code>\n条边构成的有向图，如果忽略变得方向，就变成了一棵树。我们需要改变某些边的方向使得每个点都可以访问到\n<code>0</code> 号点。</p>\n<p>如果忽略边的方向，将每条有向边以及其反向边加入到图中，那么从任意一点出发都能到达\n<code>0</code>\n号点。路径上可能会经过反向边，我们需要变更与之对应的原边的方向。需要变更的次数即为答案。</p>\n<p>以每个点为起点进行搜索的代价会很大，因此我们考虑从 <code>0</code>\n出发去遍历其他点（可以使用深度优先搜索或者广度优先搜索，本题解使用深度优先搜索），原来我们需要统计反向边的数量，现在需要统计原方向边的数量。</p>\n<p>具体而言，我们使用<code>1</code>标记原方向的边，使用 <code>0</code>\n标记反向边。然后从 <code>0</code>\n号点开始遍历，访问到某个新的点时，所经过的边被 <code>1</code>\n标记，就令答案加\n<code>1</code>。最终统计得到的答案就是我们需要变更方向的最小路线数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> parent, vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt;&amp; e)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里 parent 作用是保存了上一个节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;edge : e[x])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里意思是，如果当前节点的下一个节点是上一个节点，那么说明到头了</span></span><br><span class=\"line\">            <span class=\"comment\">// 直接跳转下一个节点</span></span><br><span class=\"line\">            <span class=\"comment\">// 比如到2了，2的下一个节点到3且3是2的前一个节点，那么直接跳转到 (0, 4, 0) 此时 parent = x = 3继续dfs</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edge.first == parent) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            res += edge.second + <span class=\"built_in\">dfs</span>(edge.first, x, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minReorder</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">e</span>(n);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> edge : connections)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e[edge[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(edge[<span class=\"number\">1</span>], <span class=\"number\">1</span>));</span><br><span class=\"line\">            e[edge[<span class=\"number\">1</span>]].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(edge[<span class=\"number\">0</span>], <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, <span class=\"number\">-1</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"下一个更大的数值平衡数\">2048.下一个更大的数值平衡数</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2012.46.46.png\"\nalt=\"截屏2023-12-09 12.46.46\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-09 12.46.46</figcaption>\n</figure>\n<p>我首先想到的是，直接对每个数字进行暴力判断。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">judgeBeautiful</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"type\">int</span> n_ = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n_)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> tmp = n_ % <span class=\"number\">10</span>;</span><br><span class=\"line\">            mp[tmp] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            n_ /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> tmp = n % <span class=\"number\">10</span>;</span><br><span class=\"line\">            mp[tmp] ++;</span><br><span class=\"line\">            n /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; mp_ : mp) <span class=\"keyword\">if</span> (mp_.first != mp_.second) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">nextBeautifulNumber</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &lt;= <span class=\"number\">666666</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            n ++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">judgeBeautiful</span>(n))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                res = n;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &lt;= <span class=\"number\">666666</span> ? res : <span class=\"number\">1224444</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"不同路径\">62.不同路径</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2013.23.57.png\"\nalt=\"截屏2023-12-09 13.23.57\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-09 13.23.57</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> dp[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j != <span class=\"number\">0</span>) dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; j != <span class=\"number\">0</span>) dp[i][j] = dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"不同路径-1\">63.不同路径</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2014.09.07.png\"\nalt=\"截屏2023-12-09 14.09.07\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-09 14.09.07</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = obstacleGrid.<span class=\"built_in\">size</span>(), n = obstacleGrid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> dp[m][n];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (obstacleGrid[i][j] == <span class=\"number\">1</span>) dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j != <span class=\"number\">0</span>) dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; j != <span class=\"number\">0</span>) dp[i][j] = dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三角形最小路径和\">120.三角形最小路径和</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-09%2014.48.17.png\"\nalt=\"截屏2023-12-09 14.48.17\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-09 14.48.17</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (triangle.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> m = triangle.<span class=\"built_in\">size</span>(), n = triangle[m - <span class=\"number\">1</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> dp[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; triangle[i].<span class=\"built_in\">size</span>(); j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>) dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + triangle[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == triangle[i].<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; i != <span class=\"number\">0</span>) dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + triangle[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) dp[i][j] = triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j != <span class=\"number\">0</span> &amp;&amp; j != triangle[i].<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>) dp[i][j] = <span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]) + triangle[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> minVal = <span class=\"number\">1e5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"keyword\">if</span> (minVal &gt; dp[m - <span class=\"number\">1</span>][i]) minVal = dp[m - <span class=\"number\">1</span>][i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"下降路径最小和\">931.下降路径最小和</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minFallingPathSum</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> n = matrix.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> dp[n][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) dp[i][j] = matrix[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) dp[i][j] = <span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i - <span class=\"number\">1</span>][j + <span class=\"number\">1</span>]) + matrix[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j == (n - <span class=\"number\">1</span>)) dp[i][j] = <span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]) + matrix[i][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; j != <span class=\"number\">0</span> &amp;&amp; j != (n - <span class=\"number\">1</span>)) </span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">min</span>(&#123;dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j], dp[i - <span class=\"number\">1</span>][j + <span class=\"number\">1</span>]&#125;) + matrix[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> minVal = <span class=\"number\">1e5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"keyword\">if</span> (minVal &gt; dp[n - <span class=\"number\">1</span>][i]) minVal = dp[n - <span class=\"number\">1</span>][i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4\nid=\"最多k个重复元素的最长子数组\">100147.最多K个重复元素的最长子数组</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-10%2010.30.05.png\"\nalt=\"截屏2023-12-10 10.30.05\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-10 10.30.05</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxSubarrayLength</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; cnt;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cnt[nums[i]] ++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cnt[nums[i]] &gt; k)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cnt[nums[j++]]--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, i - j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最大正方形\">221.最大正方形</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 13.40.25.png\" alt=\"截屏2023-12-10 13.40.25\" style=\"zoom:50%;\" /></p>\n<p>我们用 <code>dp[i][j</code>] 表示 以 <code>[i][j]</code>\n为右下角，且只包含 <code>1</code>\n的正方形的边长最大值。如果我们能计算出所有 <code>dp[i][j]</code>\n的值，那么其中的最大值即为矩阵中只包含 <code>1</code>\n的正方形的边长最大值，其平方即为最大正方形的面积。</p>\n<p>那么如何计算 <code>dp</code> 中的每个元素值？对于每个位置\n<code>[i][j]</code> ，检查在矩阵中该位置的值“</p>\n<ul>\n<li><p>如果该位置的值是 <code>0</code> ，则 <code>dp[i][j]=0</code>\n因为当前位置不可能在由 <code>1</code> 组成的正方形中。</p></li>\n<li><p>如果该位置的值是 <code>1</code> ，则 <code>dp[i][j]</code>\n的值由其上方、左方和左上方的三个相邻位置的 <code>dp</code>\n值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加<code>1</code>\n状态转移方程： <span class=\"math display\">\\[\ndp(i,j)=min(d(i-1,j),dp(i-1,j-1),dp(i,j-1)) + 1\n\\]</span> 此外，还需要考虑边界条件。如果 <code>i</code> 和\n<code>j</code> 中至少有一个为 <code>0</code>\n则以位置为右下角的最大正方形的边长就只能是 <code>1</code> ，因此\n<code>dp[i][j]=1</code></p></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxSide = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> rows = matrix.<span class=\"built_in\">size</span>(), columns = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(rows, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(columns));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; columns; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> dp[i][j] = <span class=\"built_in\">min</span>(<span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]), dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    maxSide = <span class=\"built_in\">max</span>(maxSide, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSide * maxSide;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4\nid=\"统计最大元素出现至少k次的子数组-1\">100137.统计最大元素出现至少K次的子数组</h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-10 14.15.07.png\" alt=\"截屏2023-12-10 14.15.07\" style=\"zoom:50%;\" /></p>\n<p><strong>同向双指针+滑动窗口</strong></p>\n<p>在子数组子串问题中，经常会用到双指针这一技巧 。举个例子：给定一个含有\n<code>n</code> 个正整数的数组和一个正整数 <code>target</code>\n。找出该数组中满足其和 <code>&gt;=target</code>的长度最小的\n<strong>连续子数组</strong> <code>nums</code>\n，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> .</p>\n<p>例如209题目。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minLen = nums.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; right &lt; nums.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum += nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((sum - nums[left]) &gt;= target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sum -= nums[left];</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt;= target) minLen = <span class=\"built_in\">min</span>(minLen, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minLen &lt;= nums.<span class=\"built_in\">size</span>() ? minLen : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>再比如<strong>713.乘积小于K的子数组</strong> 给定一个整数数组\n<code>nums</code> 和一个整数 <code>k</code>\n，返回子数组内所有元素的乘积严格小于 <code>k</code>\n的连续子数组的数目。万变不离其宗，元素都是正数，方法和上一题一样，对于\n<code>[10, 5, 2, 6]</code> 比如枚举到 <code>2</code> 的时候，就把\n<code>2</code> 接到上一次计算的结果后面。那如果元素的乘积\n<code>&gt;=k</code> 就把左端点右移，缩小子数组的长度，直到乘积小于\n<code>k</code>\n为止。那么问题的关键，也是与上题不同的点，<strong>子数组的数目要怎么算</strong>\n这里，我们枚举到 <code>2</code> ，需要算的就是以 <code>2</code>\n为右端点的满足要求的子数组的个数。<code>[5, 2]</code>算是一个，\n<code>[2]</code>\n单独算一个。用代码来计算，就需要推导出来一个公式，假设此时左端点为\n<code>l</code>，右端点为<code>r</code> 。那么我们现在需要计算的就是以\n<code>r</code> 为右端点的子数组的个数。注意右端点是固定的，如果从\n<code>l</code> 到 <code>r</code> 的这一段的乘积是小于 <code>k</code>\n的。那么从 <code>l+1</code> 到 <code>r</code> 的这一段也是小于\n<code>k</code> 的。一直到 <code>[r, r]</code>\n这些子数组都是满足要求的。那么子数组的个数其实就是从 <code>l</code> 到\n<code>r</code> 的元素个数。那么就是 <code>r-l+1</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numSubarrayProductLessThanK</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxNums = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; right &lt; nums.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum *= nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum  &gt;= k)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sum /= nums[left];</span><br><span class=\"line\">                left ++;  </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxNums += right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxNums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>接着还有 <strong>3.无重复字符的最长子串</strong> 给定一个字符串\n<code>s</code> ,找出其中不含重复字符的 <strong>最长子串</strong>\n的长度。由于如果出现的重复字符的唯一情况就是刚刚加入的字符与之前的字符发生重复，所以我们只需要使用哈希的方法，统计一下刚加入的字符是否出现重复即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (right; right &lt; s.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mp[s[right]] ++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (mp[s[right]] &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mp[s[left]] --;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxLen = <span class=\"built_in\">max</span>(maxLen, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>回到这个题目，首先找到数组中的最大数，设 <span\nclass=\"math inline\">\\(mx=max(nums)\\)</span> 右端点 <span\nclass=\"math inline\">\\(right\\)</span> 从左到右遍历 <span\nclass=\"math inline\">\\(nums\\)</span> 。遍历到元素<span\nclass=\"math inline\">\\(x=nums[right]\\)</span> 如果 <span\nclass=\"math inline\">\\(x=mx\\)</span> ，就把计数器 <span\nclass=\"math inline\">\\(cntMx\\)</span> 加一。如果此时 <span\nclass=\"math inline\">\\(cntMx = k\\)</span> 则不断右移左指针 <span\nclass=\"math inline\">\\(left\\)</span> ，直到窗内的 <span\nclass=\"math inline\">\\(mx\\)</span> 的出现次数 <strong>小于</strong> <span\nclass=\"math inline\">\\(k\\)</span> 为止。此时，对于右端点为 <span\nclass=\"math inline\">\\(right\\)</span> 且左端点小于 <span\nclass=\"math inline\">\\(left\\)</span> 的子数组，<span\nclass=\"math inline\">\\(mx\\)</span> 的出现次数都至少为 <span\nclass=\"math inline\">\\(k\\)</span> ，把答案增加 <span\nclass=\"math inline\">\\(left\\)</span> 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">countSubarrays</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) maxVal = <span class=\"built_in\">max</span>(maxVal, nums[i]);</span><br><span class=\"line\">        <span class=\"type\">int</span> maxValCnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (right; right &lt; nums.<span class=\"built_in\">size</span>(); right++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[right] == maxVal) maxValCnt ++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (maxValCnt == k)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[left] == maxVal) maxValCnt --;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum += left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最小体力消耗路径\">1631.最小体力消耗路径</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/力扣/截屏2023-12-11%2012.28.59.png\"\nalt=\"截屏2023-12-11 12.28.59\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-11 12.28.59</figcaption>\n</figure>\n<p>看到这个题目，最小路径，第一反应是DP，但是这里是往\n<strong>上，下，左，右</strong>\n四个方向移动，转念一想，这已经是DP解决不了的问题了。因为，你无法确定都有哪些位置能够到达你当前的位置，也就是无法推出状态转移方程。</p>\n<p>事实上，当题目允许往任意方向移动时，考察的往往就不是DP了，而是图论。从本质上说，DP问题是一类特殊的图论问题。那为什么有一些DP题目简单修改条件后，就只能彻底转化为图论问题来解决呢？这是因为修改条件后，导致我们DP状态展开不再是一个拓扑序列。换句话说，DP题虽然都属于图论范畴。但对于不是拓扑图的图论问题，我们无法使用DP求解。而此类看似DP，实则图论的问题，通常是最小生成树或者最短路问题。</p>\n<p><strong>Kruskal</strong></p>\n<p><strong>当一道题我们决定往图论方向思考时，我们的重点应该放在如何建图上。</strong>\n因为解决特定的图论问题时（最短路/最小生成树/二分图匹配），我们都是使用特定的算法。由于使用到的算法都有固定的模版，因此编码难度很低，而如何建图的思维难度则很高。对于本题，我们可以按照如下分析进行建图：</p>\n<p>因为在任意格子可以往任意方向移动，所以相邻的格子之间存在一条无向边。题目要求我们求的就是从起点到终点，经过路径中的最小权重的最大值是多少。我们可以先遍历所有的格子，将所有的边加入集合。存储的格式为数组\n<code>[a,b,w]</code> ，代表编号为 <code>a</code> 的点和编号为\n<code>b</code> 的点之间的权重为 <code>w</code> 。按照题意，\n<code>w</code> 为两者的高度差的绝对值。对集合进行排序，按照\n<code>w</code> 进行从小到大排序\n(Kruskal)当我们有了排好序的候选边集合之后，我们可以对边进行从前往后处理，每次加入一条边之后，使用并查集来查询起点和终点是否连通。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并查集模板</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UnionFind</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; parent;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; size;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"comment\">// 当前连通分量数目</span></span><br><span class=\"line\">    <span class=\"type\">int</span> setCount;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">UnionFind</span>(<span class=\"type\">int</span> _n): <span class=\"built_in\">n</span>(_n), <span class=\"built_in\">setCount</span>(_n), <span class=\"built_in\">parent</span>(_n), <span class=\"built_in\">size</span>(_n, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">iota</span>(parent.<span class=\"built_in\">begin</span>(), parent.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findset</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[x] == x ? x : parent[x] = <span class=\"built_in\">findset</span>(parent[x]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">unite</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">findset</span>(x);</span><br><span class=\"line\">        y = <span class=\"built_in\">findset</span>(y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == y) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(x, y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent[y] = x;</span><br><span class=\"line\">        size[x] += size[y];</span><br><span class=\"line\">        --setCount;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">connected</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">findset</span>(x);</span><br><span class=\"line\">        y = <span class=\"built_in\">findset</span>(y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x == y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minimumEffortPath</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = heights.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> n = heights[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;tuple&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; edges;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> id = i * n + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    edges.<span class=\"built_in\">emplace_back</span>(id - n, id, <span class=\"built_in\">abs</span>(heights[i][j] - heights[i - <span class=\"number\">1</span>][j]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    edges.<span class=\"built_in\">emplace_back</span>(id - <span class=\"number\">1</span>, id, <span class=\"built_in\">abs</span>(heights[i][j] - heights[i][j - <span class=\"number\">1</span>]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(edges.<span class=\"built_in\">begin</span>(), edges.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; e1, <span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; e2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span>&amp;&amp; [x1, y1, v1] = e1;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span>&amp;&amp; [x2, y2, v2] = e2;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v1 &lt; v2;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">UnionFind <span class=\"title\">uf</span><span class=\"params\">(m * n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> [x, y, v]: edges) &#123;</span><br><span class=\"line\">            uf.<span class=\"built_in\">unite</span>(x, y);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (uf.<span class=\"built_in\">connected</span>(<span class=\"number\">0</span>, m * n - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                ans = v;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"反转二叉树的奇数层\">2415.反转二叉树的奇数层</h4>\n<p>方法一：广度优先搜索</p>\n<p>我们直接按照层次遍历该二叉树，然后将奇数层中的值进行反转。二叉树按照层次遍历是一个基本的广度优先搜索问题，在遍历的同时，对每一层进行标记，如果当前该层为奇数层，则将该层中的节点用数组保存起来，然后将该层所有节点的值进行反转即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">reverseOddLevels</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        queue&lt;TreeNode *&gt; qu;</span><br><span class=\"line\">        qu.<span class=\"built_in\">emplace</span>(root);</span><br><span class=\"line\">        <span class=\"type\">bool</span> isOdd = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!qu.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sz = qu.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            vector&lt;TreeNode *&gt; arr;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode *node = qu.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                qu.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isOdd) arr.<span class=\"built_in\">emplace_back</span>(node);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node-&gt;left)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    qu.<span class=\"built_in\">emplace</span>(node-&gt;left);</span><br><span class=\"line\">                    qu.<span class=\"built_in\">emplace</span>(node-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isOdd) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = sz - <span class=\"number\">1</span>; l &lt; r; l++, r--) <span class=\"built_in\">swap</span>(arr[l]-&gt;val, arr[r]-&gt;val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            isOdd ^= <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2024/05/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/",
            "url": "https://chnhqz.github.io/2024/05/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/",
            "title": "论文阅读",
            "date_published": "2024-05-06T02:19:12.000Z",
            "content_html": "<h3\nid=\"selective-hourglass-mapping-for-universal-image-restoration-based-on-diffusion-model\">19.Selective\nHourglass Mapping for Universal Image Restoration Based on Diffusion\nModel</h3>\n<p><strong>基于扩散模型的全局图像恢复的选择性沙漏映射</strong></p>\n<p><strong>摘要：</strong>\n\"通用图像恢复是实际和潜在的计算机视觉任务，适用于现实世界的应用。该任务的主要挑战是同时处理不同的退化分布。现有方法主要利用任务特定条件（例如，提示）来引导模型分别学习不同的分布，称为多部分映射。然而，这对于通用模型学习并不适用，因为它忽略了不同任务之间的共享信息。在这项工作中，我们提出了一种基于扩散模型的先进选择性沙漏映射策略，称为DiffUIR。两个新颖的考虑使我们的DiffUIR非常规。首先，我们为模型配备了强大的条件指导，以获得扩散模型的准确生成方向（选择性）。更重要的是，DiffUIR将灵活的共享分布项（SDT）优雅而自然地整合到扩散算法中，逐渐将不同的分布映射到共享分布中。在反向过程中，结合SDT和强条件指导，DiffUIR迭代地将共享分布引导到具有高图像质量的任务特定分布（沙漏）。没有花哨的东西，仅通过修改映射策略，我们在五个图像恢复任务中取得了最先进的性能，在通用设置和零次通用化设置中有22个基准。令人惊讶的是，仅使用轻量级模型（仅0.89M），我们就能实现出色的性能。源代码和预训练模型可在\nhttps://github.com/iSEE-Laboratory/DiffUIR 找到。\"</p>\n<p><strong>1.Introduction</strong></p>\n<p>通用图像恢复旨在通过单一模型处理不同的图像恢复任务，在现实世界的机器人导航\n[3] 和自动驾驶 [4]\n等领域具有广泛的应用。通过单一模型处理不同的图像恢复任务的主要挑战是同时学习各种分布。现有的通用图像恢复方法\n[24, 31, 33, 40, 57]\n主要利用多编码器架构或提示大规模模型，如图1所示。按照\n[63]，通过这种方式，它们将在一个模型中学习不同的分布映射，通过在满足特定条件时引导模型分别学习不同的分布（即多部分映射）。尽管强大的条件指导能够保持一定的图像质量，但它们忽视了不同任务可能共享信息的事实，这些信息有潜力补充和增强单一任务的性能。例如，在去雨数据集中，雨天和雾天通常同时发生。试图独立学习这两种退化类型可能无法解决这种情况。</p>\n<p><img loading=\"lazy\" data-src=\"截屏2024-05-06 10.48.50.png\" alt=\"截屏2024-05-06 10.48.50\" style=\"zoom:50%;\" /></p>\n<p>图1.\n对比我们的DiffUIR与现有的通用图像恢复方法的示意图，现有方法主要设计任务特定模块来处理不同的分布，这迫使通用模型（橙色模块）同时学习不同的分布，称为多部分映射。相比之下，所提出的DiffUIR将不同的分布映射到一个共享分布中（即注意，这不是纯高斯分布），同时保持强大的条件指导。通过这种方式，DiffUIR使通用模型仅学习一个共享分布，并将共享分布引导到一个任务特定的分布，称为选择性沙漏映射。放大以获得最佳视图。</p>\n<p>在这项工作中，我们旨在捕捉不同任务之间的共享信息，以实现更好的通用图像恢复学习。我们用基于条件扩散模型的新颖选择性沙漏映射策略替换了多部分映射策略，称为DiffUIR。两个新颖的设计使我们的DiffUIR非同寻常。首先，受RDDM\n[28]的启发，我们将条件（即降级图像）明确融合到扩散模型的扩散算法中，并将条件与扩散目标广泛连接起来。通过这种方式，DiffUIR具备了类似于多部分映射方法的强大条件指导能力。其次，为了实现共享分布映射，我们优雅而自然地将一个名为SDT的共享分布项整合到扩散算法中，逐渐调整算法中条件的权重。通过建模这两个问题，在前向扩散过程中，DiffUIR逐渐减小条件的权重，各种分布将接近一个共享分布，使模型能够捕捉不同任务之间的共享信息。<strong>值得注意的是，我们将不同的分布映射到一个不纯的高斯分布中，留下了轻微的条件，正如[10,\n27,\n28]中所述，纯高斯噪声不包含任何任务信息，这不利于良好的生成质量。</strong></p>\n<blockquote>\n<p>这句话的意思是在反向去噪的过程中不直接使用纯高斯噪声？而是选择由分布映射到一个不纯的高斯分布中，留下轻微的条件，在这个不纯的高斯分布的基础上进行去噪？我这样理解有问题吗？</p>\n</blockquote>\n<p>在反向过程中，在强条件和SDT的引导下，DiffUIR将逐渐从共享分布中恢复到任务特定分布。通过仅修改映射策略，没有花里胡哨的，我们在五个图像恢复基准测试中大幅超越了所有现有的通用方法。值得注意的是，我们只使用了参数为36.26M的模型，比现有的基于大规模模型的通用方法少至少5倍，但性能更高。此外，为了满足实际应用的需求，我们提出了几个我们的DiffUIR的轻量级版本，其中微型版本DiffUIR-T仅包含0.89M个参数，但表现出色。为了进一步验证我们通用模型的能力，我们进行了已知任务和未知任务设置下的零次通用化实验，与其他通用方法相比，也实现了最先进的性能。总之，我们的主要贡献如下：</p>\n<ol type=\"1\">\n<li>提出了一种新颖的选择性沙漏映射方法DiffUIR，它可以自由地将各种分布转换为一个共享分布，并使模型学习不同任务之间的共享信息。此外，配备强条件的DiffUIR将共享分布引导到具有高图像质量的任务特定分布中。</li>\n<li>我们通过实证验证，我们的分布映射策略是通用图像恢复任务的更好解决方案。仅通过改变映射策略，我们甚至超越了基于大规模模型的通用图像恢复方法，而参数量仅为1/5。</li>\n<li>我们的DiffUIR符合实际场景的需求。我们在零次通用化设置中超越了其他通用方法。我们的微型版本DiffUIR-T仅包含0.89M个参数，但性能出色。</li>\n</ol>\n<p><strong>2.Related Work</strong></p>\n<p><strong>2.1. Image Restoration</strong></p>\n<p>图像恢复旨在从其降级对应物中恢复出干净的图像，这是一个基础且重要的计算机视觉领域，涵盖了各种任务，如去雨、去雪、低光增强、去模糊和去雾等。现有的作品主要集中在通过独特的模型设计解决一个特定任务。虽然这些方法取得了很大的性能成功，但它们忽视了一个现实中的事实，即在实际应用中，人们更喜欢一个能够处理所有降级类型的模型。最近一些先驱研究了通用图像恢复模型并取得了一些进展。AirNet使用一个模块将不同的分布映射到由对比学习约束的一个共享分布中，这对训练来说是困难的，并且性能受到限制。IDR观察到不同的降级类型可以通过奇异值分解进行划分，并且可以通过重新制定奇异值和向量来重新计算干净的图像。Painter、ProRes和DA-CLIP旨在通过提示学习来整合大规模模型的全部潜力。尽管它们利用了大规模模型的先验知识，但由于使用了多部分映射策略，它们的性能仅有限，并且需要大量的参数。在这项工作中，我们提出了一种基于条件扩散模型的选择性沙漏映射策略，一次装备了模型具有共享分布映射和强条件引导的能力。由于这些能力，我们实现了出色的结果，而无需依赖复杂的训练流水线或大规模模型或预训练。</p>\n<p><strong>2.2.Diffusion Model</strong></p>\n<p>作为密集估计任务的一部分，许多研究人员将扩散模型应用于图像恢复。RainDiffusion\n[62]将循环框架融入条件扩散模型中，在无监督设置中表现良好；DDNM\n[58]构建了一个优雅的身份方程，自然地将条件添加到扩散模型的反向过程中，对线性图像恢复任务效果显著；RDDM\n[28]将扩散方向从目标域改变为输入域，自然地将条件（即降级图像）集成到正向过程中，并在几个图像恢复基准测试中取得了令人印象深刻的性能。以上方法提出了一些关于条件约束的有趣修改，实现了强大的条件指导。然而，它们都不适合通用图像恢复学习。标准条件扩散模型的扩散终点是标准高斯噪声，没有任何特定任务的上下文信息，正如[10,\n27,\n28]中所述，它因为条件是以中介方式添加（即串联）而导致恢复质量不佳；RDDM\n[28]将条件明确融合到扩散算法中，实现了高质量的图像。然而，多元映射问题出现了，因为不同任务的端点是可区分的，并且属于不同的分布。在这项工作中，我们解决了现有条件扩散模型的缺点，并同时实现了共享分布映射和强大的条件建模。</p>\n<p><strong>3.DiffUIR</strong></p>\n<p>在本节中，我们首先受RDDM启发，探索了扩散模型的适当条件机制，然后介绍了我们的选择性沙漏映射策略，该策略具备了共享分布映射和强大的条件引导能力，以实现更好的通用学习效果。</p>\n<p><strong>3.1.Revist the condition mechanism of RDDM</strong></p>\n<p>RDDM [28]遵循标准的T步扩散模型[14,\n48]，其中包含前向过程和反向过程。在前向过程中，单步噪声可以被写成马尔可夫链：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-05-13 10.18.10.png\" alt=\"截屏2024-05-13 10.18.10\" style=\"zoom:50%;\" /></p>\n<p>其中 <span class=\"math inline\">\\(I_t\\)</span> 是在时间步 <span\nclass=\"math inline\">\\(t\\)</span> 的扩散结果，<span\nclass=\"math inline\">\\(I_{res}\\)</span> 是退化图像 <span\nclass=\"math inline\">\\(I_{in}\\)</span> 和 清晰图像 <span\nclass=\"math inline\">\\(I_0\\)</span> 的残差 ：<span\nclass=\"math inline\">\\(I_{res} = I_{in} - I_0\\)</span> 。<span\nclass=\"math inline\">\\(\\alpha_t,\\beta_t\\)</span> 分别是 <span\nclass=\"math inline\">\\(I_{res}\\)</span>\n噪声系数和高斯噪声系数。他们将噪声目标从<span\nclass=\"math inline\">\\(I_0\\)</span>（即之前图像恢复扩散方法[38,\n62]中使用的）更改为了<span\nclass=\"math inline\">\\(I_{res}\\)</span>，遵循了残差学习的原则[13]。通过马尔可夫链的性质和重新参数化技术[19,\n20]，单步噪声分布可以扩展为任意步骤的噪声形式，如下所示：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240513102646412.png\" alt=\"image-20240513102646412\" style=\"zoom:50%;\" /></p>\n<p>其中， <span\nclass=\"math inline\">\\(\\bar{\\alpha}_t=\\sum^t_{i=1}\\alpha_i,\\bar{\\beta}_t=\\sqrt{\\sum^t_{i=1}\\beta^2_i}\\)</span>\n当 <span class=\"math inline\">\\(t\\to T, \\bar{\\alpha}_T=1\\)</span>\n此时，公式可以被写为 <span\nclass=\"math inline\">\\(I_T=I_{in}+\\bar{\\beta}_T\\epsilon\\)</span> 。\n这表明端点仅与退化图像和添加的噪声相关，自然地将条件添加到模型训练中。在反向过程中，RDDM使用\n<span\nclass=\"math inline\">\\(q(I_{t-1}|I_t,I^{\\theta}_0,I^{\\theta}_{res})\\)</span>\n来模拟真实分布 <span\nclass=\"math inline\">\\(p_{\\theta}(I_{t-1}|I_t)\\)</span>\n，并且它可以被写为马尔可夫链：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240513103504239.png\" alt=\"image-20240513103504239\" style=\"zoom:50%;\" /></p>\n<p>在这里，θ 代表基于模型输出获得的项，0 代表根据 [48]\n中的确定性隐式采样方程使用的结果。</p>\n<p>作为 RDDM\n的终点包含了条件信息（即，降级图像），它是扩散模型的一个很好的条件机制，我们称之为显式条件；此外，他们广泛地将条件与扩散目标进行连接，从而获得更好的图像质量，称为隐式条件。然而，RDDM\n中的强条件机制并不适合用于通用训练，因为条件始终存在，这意味着他们强迫模型分别学习不同的降级分布，导致多部分映射，无法捕获不同任务之间的共享信息。</p>\n<p><strong>3.2. Selective Hourglass Mapping</strong></p>\n<p>我们方法的目标是同时实现强条件引导和共享分布映射。我们采用了RDDM的条件机制，并将共享分布项（SDT）整合到扩散算法中，实现了两个组件之间的协同效应。我们展示我们的变体扩散过程如下。分布逼近前向过程。在前向过程中，由于我们采用了RDDM的条件机制，一步扩散过程如下：\n<span\nclass=\"math inline\">\\(I_t=I_{t-1}+\\alpha_tI_{res}+\\beta_t\\epsilon_{t-1}\\)</span>\n。为了进一步实现共享分布映射，我们修改前向过程如下：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240513104339479.png\" alt=\"image-20240513104339479\" style=\"zoom:50%;\" /></p>\n<p>其中，<span class=\"math inline\">\\(\\delta_tI_{in}\\)</span> 是\nSDT，<span class=\"math inline\">\\(\\delta\\)</span> 是共享分布项系数，<span\nclass=\"math inline\">\\(\\bar\\delta_t = \\sum^t_{i=1}\\delta_i\\)</span>\n。我们设置 <span class=\"math inline\">\\(\\bar\\delta_t\\)</span> 从 0 逐渐到\n0.9 。这将逐渐减少条件的影响。当 <span class=\"math inline\">\\(t\\to\nT\\)</span> 时，<span class=\"math inline\">\\(\\bar\\alpha_T = 1\\)</span>\n,公式可以重写为 <span class=\"math inline\">\\(I_T = (1-\\bar\\delta_T)I_{in}\n+ \\bar \\beta_T\\epsilon = 0.1I_{in}+\\bar\\beta_T\\epsilon\\)</span>\n，这接近一个不纯的高斯分布（我们在实验中进一步验证）。请注意，我们采用渐进逼近策略来自然地适应扩散模型的扩散过程。</p>\n<p><strong>Distribution Diffusing Reverse Process</strong>\n在反向过程（推理阶段）中，我们的目标是从共享分布恢复样本（即 <span\nclass=\"math inline\">\\(( I_T = (1 - \\bar\\delta_T)I_{in} + \\bar\\beta_T\n\\epsilon )\\)</span>）到任务特定的分布。按照DDPM [14]的方法，我们使用 (\n<span class=\"math inline\">\\(q(I_{t-1}|I_t, I_{in}, I_{\\theta}^0,\nI_{\\theta}^{res})\\)</span> ) 来模拟 <span class=\"math inline\">\\((\np_{\\theta}(I_{t-1}|I_t) )\\)</span>\n的分布，并基于贝叶斯定理，我们可以计算如下公式：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240514101344348.png\" alt=\"image-20240514101344348\" style=\"zoom:50%;\" /></p>\n<p>由于该公式的目标是获得 ( <span class=\"math inline\">\\(I_{t-1}\\)</span>\n) 的分布，我们将其简化并重排列成关于 <span\nclass=\"math inline\">\\(I_{t-1}\\)</span> 的形式，其中 $ C(I_t, I_{}^0,\nI_{}^{res}, I_{in}) $ 是与其无关的项。然后，我们根据方程 (5) 计算分布 (\n<span class=\"math inline\">\\(p_{\\theta}(I_{t-1}|I_t)\\)</span> ) 的均值 (\n<span class=\"math inline\">\\(\\mu_{\\theta}(I_t, t)\\)</span> ) 和方差 (\n<span class=\"math inline\">\\(\\sigma_{\\theta}(I_t, t)\\)</span> )。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240514102319443.png\" alt=\"image-20240514102319443\" style=\"zoom:50%;\" /></p>\n<p>其中 ( <span class=\"math inline\">\\(I_{\\theta}^{res}\\)</span> )\n由模型预测，( <span class=\"math inline\">\\(\\epsilon_{\\theta}\\)</span> )\n通过 ( <span class=\"math inline\">\\(I_{\\theta}^{res}\\)</span> )\n获得。基于重参数化技术 [19, 20]，如果我们使用来自DDPM\n[14]的采样策略，可以按以下方式计算 ( <span\nclass=\"math inline\">\\(I_{t-1}\\)</span> )：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240514102524496.png\" alt=\"image-20240514102524496\" style=\"zoom:50%;\" /></p>\n<p>其中 ( <span class=\"math inline\">\\(\\epsilon^*\\)</span> )\n是随机高斯噪声。本文中，为了加速采样速度，我们使用了DDIM\n[48]的采样策略，并按以下方式计算 ( <span\nclass=\"math inline\">\\(I_{t-1}\\)</span> )： <span class=\"math display\">\\[\nI_{t-1} = I_t - \\alpha_t I_{\\theta}^{res} + \\delta_t\nI_{in}  \\qquad\\text(8)\n\\]</span></p>\n<p>根据公式 (8)，我们可以迭代地从 ( <span\nclass=\"math inline\">\\(I_T\\)</span> ) 恢复样本到 ( <span\nclass=\"math inline\">\\(I_{T-k}\\)</span> )、( <span\nclass=\"math inline\">\\(I_{T-2k}\\)</span> )、(...)、( <span\nclass=\"math inline\">\\(I_k\\)</span> )、( <span\nclass=\"math inline\">\\(I_0\\)</span> )，其中 ( <span\nclass=\"math inline\">\\(k\\)</span> ) 表示遵循DDIM\n[48]的跳步。完整的采样算法见算法2。请注意，这里仅展示了最重要的步骤，完整的推导请参见附录C。</p>\n<p>通用训练目标。我们通过将扩散模型的条件机制修改为显式条件（注入到扩散算法中）和隐式条件（连接）以实现强条件引导，并将SDT添加到扩散算法中以实现共享分布映射，从而实现通用学习。尽管这与标准扩散模型\n[14, 48]\n不同，但由于我们都是通过将不同的降级分布接近到一个共享分布，因此我们参考了DDPM\n[14]并进行了训练目标的详细推导如下： <span class=\"math display\">\\[\nL(\\theta) = D_{KL}(q(I_{t-1}|I_t, I_0, I_{\\theta}^{res}, I_{in})\n\\parallel p_{\\theta}(I_{t-1}|I_t)).  \\tag{9}\n\\]</span> 如VAE\n[19]中提到的，两高斯分布的Kullback-Leibler散度可以简化为它们均值的差异，该函数变为：\n<span class=\"math display\">\\[\n\\mathcal L(\\theta) = \\mathbb{E}_{q(I_t|I_0)} \\left[ \\|\\mu(I_t, I_0) -\n\\mu_{\\theta}(I_t, t)\\|^2 \\right]\\\\\n= \\mathbb{E}_{t, \\epsilon, I_{\\theta}^{res}} \\left[ \\|I_t - \\alpha_t\nI_{\\theta}^{res} + \\delta_t I_{in} - \\frac{\\beta_t^2}{\\beta_t} \\epsilon\n- (I_t - \\alpha_t I_{\\theta}^{res} + \\delta_t I_{in} -\n\\frac{\\beta_t^2}{\\beta_t} \\epsilon_{\\theta})\\|^2 \\right]\\\\\n= \\mathbb{E}_{t, \\epsilon, I_{\\theta}^{res}} \\left[ \\|\\alpha_t\n(I_{\\theta}^{res} - I_{\\theta}^{res}) + \\frac{\\beta_t^2}{\\beta_t}\n(\\epsilon_{\\theta} - \\epsilon)\\|^2 \\right], \\tag{10}\n\\]</span> 其中 ( <span class=\"math inline\">\\(I_{\\theta}^{res}\\)</span> )\n和 ( <span class=\"math inline\">\\(\\epsilon\\)</span> )\n表示前向过程中确定的值，而 ( <span\nclass=\"math inline\">\\(I_{\\theta}^{res}\\)</span> ) 和 ( <span\nclass=\"math inline\">\\(\\epsilon_{\\theta}\\)</span> )\n表示反向过程中的预测结果。参考DDPM\n[14]的官方代码，预测噪声或输入本质上是等效的，因此我们直接使用模型预测残差\n( <span class=\"math inline\">\\(I_{\\theta}^{res}\\)</span> )，从而可以导出\n( <span class=\"math inline\">\\(\\epsilon_{\\theta}\\)</span> )。根据 [7, 55,\n74]，在预测输入时，L1损失比L2损失表现更好。基于上述实验和理论基础，我们的最终损失函数简化如下:\n<span class=\"math display\">\\[\n\\mathcal L(\\theta)_{\\text{simple}} = \\mathbb{E}_{t, I_t, I_{res}} \\left[\n\\|I_{res} - I^{\\theta}_{res}(I_t, t)\\|_1 \\right].  \\tag{11}\n\\]</span></p>\n<h3\nid=\"structure-matters-tackling-the-semantic-discrepancy-in-diffusion-models-for-image-inpainting\">20.Structure\nMatters: Tackling the Semantic Discrepancy in Diffusion Models for Image\nInpainting</h3>\n<p><strong>摘要：</strong>\n去噪扩散概率模型（DDPMs）用于图像修复，旨在前向过程中向图像纹理添加噪声，并通过反向去噪过程用未被遮挡的纹理区域恢复被遮挡的区域。尽管现有方法能够生成有意义的语义，但由于遮挡区域和未遮挡区域之间的语义差异，它们仍然存在问题。这是因为语义密集的未遮挡纹理在扩散过程中未能完全退化，而遮挡区域则变成纯噪声，导致它们之间存在很大差异。本文旨在解答未遮挡语义如何引导纹理去噪过程，以及如何解决语义差异，以促进一致且有意义的语义生成。为此，我们提出了一种新的结构引导扩散模型用于图像修复，称为StrDiffusion，重新构建了在结构引导下的传统纹理去噪过程，推导出用于图像修复的简化去噪目标，同时揭示了：1）语义稀疏的结构在早期阶段有助于解决语义差异，而密集的纹理在后期阶段生成合理的语义；2）未遮挡区域的语义本质上为纹理去噪过程提供了时间相关的结构引导，受益于结构语义的时间相关稀疏性。对于去噪过程，训练了一个结构引导的神经网络，通过利用遮挡和未遮挡区域之间去噪结构的一致性来估计简化的去噪目标。此外，我们设计了一种自适应重采样策略，作为结构是否有能力引导纹理去噪过程的正式标准，同时调节它们的语义关联。广泛的实验验证了StrDiffusion在现有方法上的优越性。我们的代码可在\n<a\nhref=\"https://github.com/htyjers/StrDiffusion\">https://github.com/htyjers/StrDiffusion</a>\n获取。</p>\n<p><strong>1.Introduction</strong></p>\n<p>最近，图像修复支持了广泛的应用，例如照片修复和图像编辑，旨在利用未遮挡区域的语义信息恢复图像的遮挡区域，其中主要涵盖两个方面的原则：遮挡区域的合理语义及其与未遮挡区域的语义一致性。之前的工作主要涉及基于扩散的[2,\n8]和基于块的[1, 4,\n10]方法，这些方法倾向于通过简单的颜色信息来修复图像的小遮挡或重复图案，但无法处理不规则或复杂的遮挡。为了解决这一问题，大量注意力[15,\n17, 31,\n36]转向了卷积神经网络（CNNs），这些网络致力于编码遮挡区域周围的局部语义，同时忽略了来自未遮挡区域的全局信息，导致远离遮挡边界的区域仍然模糊。最近，自注意力机制[5,\n14, 16, 32,\n35]被提出以在分割的图像块形式中全局关联遮挡区域和未遮挡区域，增强它们之间的语义一致性。然而，这些策略在遮挡区域内部的不同块之间存在较差的语义关联。为此，利用语义稀疏结构[3,\n7, 9, 13, 18, 20, 27, 28, 33,\n34]来加强它们的关联，然而，这意味着对结构和纹理之间语义一致性的高度依赖，因此不可避免地在修复输出中产生伪影。</p>\n<h3\nid=\"condition-aware-neural-network-for-controlled-image-generation\">21.Condition-Aware\nNeural Network for Controlled Image Generation</h3>\n<h3\nid=\"accelerating-diffusion-sampling-with-optimized-time-steps\">22.Accelerating\nDiffusion Sampling with Optimized Time Steps</h3>\n<h3\nid=\"balancing-act-distribution-guided-debiasing-in-diffusion-models\">23.Balancing\nAct: Distribution-Guided Debiasing in Diffusion Models</h3>\n<h3\nid=\"diffir-efficient-diffusion-model-for-image-restoration\">24.DiffIR:\nEfficient Diffusion Model for Image Restoration</h3>\n<h3 id=\"residual-denoising-diffusion-models\">25.Residual Denoising\nDiffusion Models</h3>\n<p><strong>摘要：</strong>\n我们提出了残差去噪扩散模型（RDDM），这是一种新颖的双重扩散过程，将传统的单一去噪扩散过程解耦为残差扩散和噪声扩散。这种双重扩散框架将最初仅用于图像恢复的基于去噪的扩散模型扩展为一个统一且可解释的模型，通过引入残差实现图像生成和恢复的统一。具体来说，我们的残差扩散表示从目标图像到退化输入图像的定向扩散，并明确引导图像恢复的反向生成过程，而噪声扩散表示扩散过程中的随机扰动。残差优先考虑确定性，而噪声强调多样性，使RDDM能够有效地统一具有不同确定性或多样性要求的任务，例如图像生成和恢复。我们通过系数转换证明了我们的采样过程与DDPM和DDIM的一致性，并提出了一个部分路径独立的生成过程，以更好地理解反向过程。值得注意的是，我们的RDDM使得仅通过L1损失和批量大小为1进行训练的通用UNet能够与最先进的图像恢复方法竞争。我们提供了代码和预训练模型，以鼓励对我们创新框架的进一步探索、应用和开发（https://github.com/nachifur/RDDM）。</p>\n<p><strong>1.Introduction</strong></p>\n<p>在现实生活中，扩散通常以涉及多个并发过程的复杂形式发生，例如多种气体的扩散或不同类型的波或场的传播。这让我们思考，基于去噪的扩散模型\n[17, 51] 是否在仅关注去噪方面存在局限性。当前基于扩散的图像恢复方法 [22,\n39, 48, 49, 82]\n通过使用降级图像作为条件输入来将扩散模型扩展到图像恢复任务中，以隐式地指导反向生成过程，而不修改原始的去噪扩散过程\n[17,\n51]。然而，从噪声开始的反向过程似乎是不必要的，因为降级图像已经是已知的。正向过程对于图像恢复来说是不可解释的，因为扩散过程不包含任何关于降级图像的信息，如图1(a)所示。</p>\n<p>在本文中，我们探索了一种新颖的双重扩散过程，并提出了残差去噪扩散模型（RDDM），可以解决单一去噪过程对图像恢复的不可解释性。在RDDM中，我们将先前的扩散过程解耦为残差扩散和噪声扩散。残差扩散优先考虑确定性，并表示从目标图像到条件输入图像的定向扩散，噪声扩散强调多样性，并表示扩散过程中的随机扰动。因此，我们的RDDM可以统一需要不同确定性或多样性的不同任务，例如图像生成和恢复。与基于去噪的扩散模型相比，RDDM中的残差清晰地指示了正向扩散方向，并明确地指导了图像恢复的反向生成过程，如图1(b)所示。</p>\n<figure>\n<img loading=\"lazy\" data-src=\"截屏2024-05-06%2016.02.59.png\"\nalt=\"截屏2024-05-06 16.02.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-05-06 16.02.59</figcaption>\n</figure>\n<p>具体来说，我们重新定义了一种新的正向过程，允许残差和噪声同时扩散，在其中目标图像逐渐扩散成纯噪声图像用于图像生成，或者扩散成带有噪声的输入图像用于图像恢复。与之前的去噪扩散模型[17,\n51]不同，其使用一个系数表来控制噪声和图像的混合比例，我们的RDDM使用两个独立的系数表来控制残差和噪声的扩散速度。我们发现，这种独立的扩散属性在反向生成过程中也是明显的，例如，在测试过程中在一定范围内调整系数表不会影响图像生成结果，并且首先移除残差，然后去噪（见图2），也可以生成语义一致的图像。我们的RDDM与广泛使用的去噪扩散模型兼容，即，通过转换系数表，我们的采样过程与DDPM[17]和DDIM[51]的采样过程一致。此外，我们的RDDM本身支持条件输入，使得仅使用ℓ1损失和批量大小为1进行训练的网络能够与最先进的图像恢复方法竞争。我们预见我们的模型可以促进统一且可解释的图像分布转换方法，突显了残差和噪声对于扩散模型同样重要的事实，例如，残差优先考虑确定性，而噪声强调多样性。本文的贡献总结如下：\n-\n我们提出了一种新颖的双重扩散框架，通过引入残差来解决单一去噪过程对于图像恢复的不可解释性。我们的残差扩散表示了从目标图像到条件输入图像的定向扩散。\n-\n我们引入了一个部分路径独立的生成过程，将残差和噪声解耦，突出了它们在控制方向性残差偏移（确定性）和随机扰动（多样性）中的作用。\n-\n我们设计了一个自动目标选择算法，用于选择对于未知新任务是否预测残差或噪声。\n-\n大量实验表明，我们的方法可以适用于不同的任务，例如图像生成、恢复、修补和翻译，聚焦于确定性或多样性，并涉及成对或非成对数据。</p>\n<p><strong>2.Related Work</strong></p>\n<p>去噪扩散模型（例如，DDPM [17]、SGM [52, 53] 和 DDIM\n[51]）最初是为图像生成而开发的。基于DDPM和DDIM的后续图像恢复方法 [14,\n39, 48] 将降级图像作为条件输入提供给一个去噪网络，例如DvSR [62]、SR3\n[49] 和 WeatherDiffusion\n[82]，这些方法通常需要较大的采样步长和批量大小。此外，在这些方法中，从噪声开始的反向过程似乎对于图像恢复任务是不必要且低效的。因此，SDEdit\n[41]、ColdDiffusion [2]、InDI [11] 和 I2SB [29]\n提出直接从降级图像或带有噪声的降级图像生成清晰图像。InDI [11] 和 I2SB\n[29]\n还提出了统一的图像生成和恢复框架，与我们提出的RDDM最相关。具体来说，InDI、I2SB\n和我们的RDDM的正向扩散一致地采用了三个术语的混合（即，输入图像Iin、目标图像I0\n和噪声 ϵ），超出了基于去噪的扩散模型 [17,\n51]，该模型包括了两个术语的混合（即，I0 和 ϵ）。然而，InDI 和 I2SB\n选择估计目标图像或其线性变换项来替换噪声估计，类似于我们RDDM的一个特例（SM-Res）。相比之下，我们引入了残差估计，同时为生成和恢复任务采用了噪声。我们的RDDM可以进一步扩展DDPM\n[17]、DDIM [51]、InDI [11] 和 I2SB [29]\n到独立的双重扩散过程，并为多维扩散过程铺平道路。我们强调残差和噪声同样重要，例如，残差优先考虑确定性，而噪声强调多样性。此外，我们的工作与系数表设计\n[44, 48]、方差策略优化 [3, 4, 24, 44]、叠加图像分解 [12, 81]、曲线积分\n[47]、随机微分方程 [53] 和图像恢复 [1, 32, 56, 70, 72, 75] 中的残差学习\n[15] 相关。详细比较请参见附录 A.5。</p>\n<p><strong>4.Residual Denoising Diffusion Models</strong></p>\n<p>我们的目标是发展一种双重扩散过程去统一和融合图像生成和恢复。我们修改了传统DDPM中<span\nclass=\"math inline\">\\(I_T =\nϵ\\)</span>的表示形式，将其改为在我们的RDDM中<span\nclass=\"math inline\">\\(I_T = I_{in} + ϵ\\)</span>，其中<span\nclass=\"math inline\">\\(I_{in}\\)</span>是一个降级图像（例如，阴影、低光或模糊图像）用于图像恢复，对于图像生成则设置为0。这种修改与广泛使用的去噪扩散模型兼容。例如，\n<span class=\"math inline\">\\(I_T = 0 + ϵ\\)</span>\n是完全的噪声，对应生成，对于图像恢复， <span\nclass=\"math inline\">\\(I_T\\)</span> 是一个带有噪声的降级图像（<span\nclass=\"math inline\">\\(I_{in} + ϵ\\)</span>），如图3所示。</p>\n<figure>\n<img loading=\"lazy\" data-src=\"截屏2024-05-06%2020.18.45.png\"\nalt=\"截屏2024-05-06 20.18.45\" />\n<figcaption aria-hidden=\"true\">截屏2024-05-06 20.18.45</figcaption>\n</figure>\n<p>图3:提出的残差去噪扩散模型是一个统一图像生成和修复的框架，我们在RDDM中引入残差（<span\nclass=\"math inline\">\\(I_{res}\\)</span>），重新定义正向扩散过程，使其涉及残差和噪声的同时扩散。残差\n<span class=\"math inline\">\\(I_{res} = I_{in} - I_0\\)</span>\n扩散表示从目标图像 <span class=\"math inline\">\\(I_0\\)</span>\n到输入的退化图像 <span class=\"math inline\">\\(I_{in}\\)</span>\n的直接扩散。而噪声扩散表示扩散过成中的随机扰动。在RDDM中 <span\nclass=\"math inline\">\\(I_0\\)</span> 逐渐扩散到 <span\nclass=\"math inline\">\\(I_T = I_{in} + ϵ  ϵ ∼ N (0, I)\\)</span>\n。在第三列，对于图像生成 <span class=\"math inline\">\\(I_{in} = 0\\)</span>\n此时 <span class=\"math inline\">\\(I_T\\)</span>\n是一个完全的噪声，并且对于图像恢复来说，<span\nclass=\"math inline\">\\(I_T\\)</span> 是一个携带退化图像的噪声， <span\nclass=\"math inline\">\\(I_{in}\\)</span> 是退化图像。</p>\n<p>修正后的正向过程从 <span class=\"math inline\">\\(I_0\\)</span> 到 <span\nclass=\"math inline\">\\(I_{in} + \\epsilon\\)</span> ,涉及将 <span\nclass=\"math inline\">\\(I_0\\)</span> 逐渐降级为 <span\nclass=\"math inline\">\\(I_{in}\\)</span> ，并注入噪声 <span\nclass=\"math inline\">\\(\\epsilon\\)</span>\n。这自然产生了一个双重扩散过程，一个是残差扩散来建模从 <span\nclass=\"math inline\">\\(I_0\\)</span> 到 <span\nclass=\"math inline\">\\(I_{in}\\)</span>\n的过渡，另一个是噪声扩散。例如，从无阴影图像 <span\nclass=\"math inline\">\\(I_0\\)</span> 到带阴影图像的带噪声图像 <span\nclass=\"math inline\">\\(I_T\\)</span>\n的正向扩散过程涉及逐渐添加阴影和噪声。</p>\n<p>在接下来的小节中，我们详细介绍了RDDM背后的基本理论和方法论。受到残差学习的启发，我们重新定义了第4.1节中每个正向扩散过程的步骤。对于反向过程，我们在第4.2节中提出了一个训练目标，用于预测正向过程中注入的残差和噪声。在第4.3节中，我们提出了三种采样方法，即残差预测（SM-Res）、噪声预测（SM-N）和“残差和噪声预测”（SM-Res-N）。</p>\n<p><strong>4.1 Directional Residual Diffusion Process with\nPerturbation</strong></p>\n<p>为了建模图像质量的逐渐降低和噪声的增加，我们定义了RDDM中单个正向过程步骤如下：\n<span class=\"math display\">\\[\nI_t = I_{t-1} + I^t_{res} \\quad \\quad I^t_{res} \\sim\n\\mathcal{N(\\alpha_tI_{res},\\beta^2_{t}I)}\n\\]</span> 其中 <span class=\"math inline\">\\(I^t_{res}\\)</span> 代表从状态\n<span class=\"math inline\">\\(I_{t-1}\\)</span> 到状态 <span\nclass=\"math inline\">\\(I_t\\)</span>\n的方向均值偏移（残差扩散）与随机扰动（噪声扩散），其中 <span\nclass=\"math inline\">\\(I^t_{res}\\)</span> 中的残差 <span\nclass=\"math inline\">\\(I_{res}\\)</span> 是<span\nclass=\"math inline\">\\(I_{in}\\)</span> 和 <span\nclass=\"math inline\">\\(I_0\\)</span> 之间的差异（<span\nclass=\"math inline\">\\(I_{res} = I_{in} - I_{0}\\)</span>）\n，而两个独立的系数调度 <span class=\"math inline\">\\(\\alpha_t\\)</span> 和\n<span class=\"math inline\">\\(\\beta_t\\)</span>\n分别控制残差和噪声扩散。事实上，从 <span\nclass=\"math inline\">\\(I_0\\)</span> 中采样 <span\nclass=\"math inline\">\\(I_t\\)</span> 更简单。 <span\nclass=\"math display\">\\[\nI_t = I_{t-1} + \\alpha_tI_{res} + \\beta_t\\epsilon_{t-1} ,\\\\=I_{t-2} +\n(\\alpha_{t-1} + \\alpha_t)I_{res} +\n(\\sqrt{\\beta^2_{t-1}+\\beta^2_t})\\epsilon_{t-2} \\\\ =\\cdots\\\\=I_0 +\n\\bar{\\alpha_t}I_{res} + \\bar{\\beta_t}\\epsilon, \\tag{7}\n\\]</span> 其中，<span class=\"math inline\">\\(\\epsilon_{t-1},\\dots\n,\\epsilon \\sim \\mathcal{N(0,I)}\\)</span> ， ${}<em>t=^t</em>{i=1}_i ,\n{}_t = $ 如果 <span class=\"math inline\">\\(t= T, \\bar{\\alpha}_T = 1\nI_T=I_{in}+\\bar{\\beta}_T\\epsilon\\)</span> 。<span\nclass=\"math inline\">\\(\\bar{\\beta}_T\\)</span>\n可以控制图像恢复中噪声扰动的强度（例如，<span\nclass=\"math inline\">\\(\\bar{\\beta}^2_T=0.01\\)</span> 用于阴影消除）然而\n<span class=\"math inline\">\\(\\bar{\\beta}^2_T=1\\)</span>\n用于图像生成，从方程6中，可以定义正向过程中的联合概率分布如下： <span\nclass=\"math display\">\\[\nq(I_{1:T}|I_0,I_{res}):=\\Pi^T_{t=1}q(I_t|I_{t-1},I_{res}), \\tag{8} \\\\\nq(I_t|I_{t-1},I_{res}):=\\mathcal{N}(I_t;I_{t-1}+\\alpha_tI_{res},\\beta^2_tI).\n\\]</span> 方程7定义了边缘概率分布 <span\nclass=\"math inline\">\\(q(I_t|I_0,I_{res})=\\mathcal{N}(I_t;I_0+\\bar{\\alpha}_tI_{res},\\bar{\\beta}^2_tI)\\)</span>\n事实上，我们的RDDM的正向扩散是三个项（即<span\nclass=\"math inline\">\\(I_0,I_{res},\\epsilon\\)</span> ）\n的混合，扩展了广泛使用的去噪扩散模型，后者是两个项（即 <span\nclass=\"math inline\">\\(I_0,\\epsilon\\)</span> ）\n的混合，类似的混合形式在几个并行的工作中也可以看到，例如 InDI, I2SB,\nIRSDE, REsShift。</p>\n<p><strong>4.2. Generation Process and Training Objective</strong></p>\n<p>在正向过程中，残差 <span class=\"math inline\">\\(I_{res}\\)</span>\n和噪声 <span class=\"math inline\">\\(\\epsilon\\)</span> 逐渐添加到 <span\nclass=\"math inline\">\\(I_0\\)</span> 中，然后合成为 <span\nclass=\"math inline\">\\(I_t\\)</span> 而从 <span\nclass=\"math inline\">\\(I_T\\)</span> 到 <span\nclass=\"math inline\">\\(I_0\\)</span>\n的逆过程及对在正向过程中注入的残差和噪声的估计。我们可以训练一个残差网络\n<span class=\"math inline\">\\(I^{\\theta}_{res}(I_t,t,I_{in})\\)</span>\n来预测 <span class=\"math inline\">\\(I_{res}\\)</span> ，以及一个噪声网络\n<span class=\"math inline\">\\(\\epsilon_{\\theta}(I_t,t,I_{in})\\)</span>\n来估计 <span class=\"math inline\">\\(\\epsilon\\)</span> 。使用公式 7\n我们获得了估计的目标图像 <span class=\"math inline\">\\(I^{\\theta}_{0} =\nI_t - \\bar{\\alpha}_tI^{\\theta}_{res} -\n\\bar{\\beta}_t\\epsilon_{\\theta}\\)</span> 。如果给定了 <span\nclass=\"math inline\">\\(I^{\\theta}_{0}\\)</span> 和 <span\nclass=\"math inline\">\\(I^{\\theta}_{res}\\)</span> ，则生成过程定义为：\n<span class=\"math display\">\\[\np_{\\theta} (I_{t-1}|I_t) := q_{\\sigma} (I_{t-1}|I_t,\nI^{\\theta}_0,I^{\\theta}_{res}) \\tag{10}\n\\]</span> 其中，从<span class=\"math inline\">\\(I_t\\)</span>到<span\nclass=\"math inline\">\\(I_{t-1}\\)</span>的传递概率. <span\nclass=\"math inline\">\\(q_{\\sigma}(I_{t-1}|I_t, I_0, I_{res})^2\\)</span>\n为：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-05-11 11.33.28.png\" alt=\"截屏2024-05-11 11.33.28\" style=\"zoom:50%;\" /></p>\n<p>其中，<span class=\"math inline\">\\(\\sigma ^2_t =\n\\eta\\beta^2_t\\bar{\\beta}^2_{t-1} / \\bar{\\beta}^2_t\\)</span> , <span\nclass=\"math inline\">\\(\\eta\\)</span> 控制生成过程是随机的 <span\nclass=\"math inline\">\\((\\eta = 1)\\)</span> 还是确定性的 <span\nclass=\"math inline\">\\(\\eta=0\\)</span> 利用公式 10 和 公式 11\n，可以通过以下方式从 <span class=\"math inline\">\\(I_t\\)</span> 中采样\n<span class=\"math inline\">\\(I_{t-1}\\)</span> 。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/截屏2024-05-11 11.45.49.png\" alt=\"截屏2024-05-11 11.45.49\" style=\"zoom:50%;\" /></p>\n<p>其中， <span class=\"math inline\">\\(\\epsilon_t \\sim\n\\mathcal{N}(0,I)\\)</span> 。当 <span class=\"math inline\">\\(\\eta =\n1\\)</span> ，我们的 RDDM 具有受限制的总方差，而DDPM具有保持方差，当\n<span class=\"math inline\">\\(\\eta = 0\\)</span> 采样过程是确定性的。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/截屏2024-05-11 11.56.46.png\" alt=\"截屏2024-05-11 11.56.46\" style=\"zoom:50%;\" /></p>\n<p>我们推导出以下简化的损失函数用于训练（附录 A.1）：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-05-11 11.57.45.png\" alt=\"截屏2024-05-11 11.57.45\" style=\"zoom:50%;\" /></p>\n<p>其中，超参数 <span\nclass=\"math inline\">\\(\\lambda_{res},lambda_{\\epsilon}\\in\n\\{0,1\\}\\)</span> ，以及训练输入图像 <span\nclass=\"math inline\">\\(I_t\\)</span> 是通过 <span\nclass=\"math inline\">\\(I_0, I_{res}, \\epsilon\\)</span>\n综合得到的。也可以使用 <span class=\"math inline\">\\(I_{in}\\)</span>\n综合生成 <span class=\"math inline\">\\(I_t\\)</span> <span\nclass=\"math display\">\\[\nI_t = I_{in} + (\\bar{\\alpha}_t  - 1 )I_{res} + \\bar{\\beta}_t\\epsilon\n\\]</span> <strong>5.Decoupled Dual Diffusion\nFramework（解耦双重扩散框架）</strong></p>\n<p>在对RDDM和DDPM进行对比分析后，我们发现DDPM确实涉及到了残差和噪音的同时扩散，这在附录A.3中的方程48等价于方程44时显而易见。我们发现可以将这两种扩散方式解耦。第5.1节介绍了解耦的前向扩散过程。在第5.2节中，我们提出了一种部分路径独立的生成过程，并将同时采样解耦为先移除残差，然后移除噪音（参见图6(d)和图17）。这种解耦的双重扩散框架揭示了DDPM生成过程中残差去除和去噪的作用。</p>\n<p>该模型提出了一种残差去噪模型\n（RDDM）可用于图像生成和图像修复。该文最大的特点是提出一种双扩散模型，在扩散过程中不仅包含噪声\n<span class=\"math inline\">\\(\\epsilon\\)</span> 扩散，还包含残差信息 <span\nclass=\"math inline\">\\(I_{res}\\)</span>\n的扩散，这里的残差信息就是退化图像 <span\nclass=\"math inline\">\\(I_{in}\\)</span> 和 <span\nclass=\"math inline\">\\(I_0\\)</span> 之间的差值 （<span\nclass=\"math inline\">\\(I_{res} = I_{in} - I_0\\)</span>）\n。<strong>接下来我只讨论在引入条件的过程中的图像修复内容。</strong></p>\n<p>首先，在传统的扩散模型中，我们的正向扩散过程是： <span\nclass=\"math display\">\\[\nI_t = \\sqrt{\\bar{\\alpha}_t} I_0+\\sqrt{1-\\bar{\\alpha}_t} \\epsilon \\tag{1}\n\\]</span> 本文中的正向扩散过程： <span class=\"math display\">\\[\nI_t = I_0 + \\bar{\\alpha}_tI_{res} + \\bar{\\beta}_t\\epsilon   \\tag{2}\n\\]</span> 其中，<span class=\"math inline\">\\(1-\\bar{\\alpha}_t =\n\\bar{\\beta}_t\\)</span>\n。这样我们可以看到两个正向扩散的过程十分相近。那么作者这点在代码中的体现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 随机符合正态分布的噪声</span></span><br><span class=\"line\">noise = default(noise, <span class=\"keyword\">lambda</span>: torch.randn_like(x_start))</span><br><span class=\"line\"><span class=\"comment\"># 残差 为 退化图像和清晰图像的差</span></span><br><span class=\"line\">x_res = x_input - x_start</span><br><span class=\"line\"></span><br><span class=\"line\">x_t = self.q_sample(x_start, x_res, t, noise=noise)</span><br></pre></td></tr></table></figure>\n<p><code>q_sample()</code>\n是封装好的正向扩散过程，这也是与原始<code>DDPM</code>\n不同的点。我们可以列出两者代码对比一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">q_sample</span>(<span class=\"params\">self, x_start, continuous_sqrt_alpha_cumprod, noise=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">\t\tnoise = default(noise, <span class=\"keyword\">lambda</span>: torch.randn_like(x_start))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># random gama</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        continuous_sqrt_alpha_cumprod * x_start +</span><br><span class=\"line\">        (<span class=\"number\">1</span> - continuous_sqrt_alpha_cumprod**<span class=\"number\">2</span>).sqrt() * noise</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">q_sample</span>(<span class=\"params\">self, x_start, x_res, t, noise=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">    noise = default(noise, <span class=\"keyword\">lambda</span>: torch.randn_like(x_start))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        x_start+extract(self.alphas_cumsum, t, x_start.shape) * x_res +</span><br><span class=\"line\">        extract(self.betas_cumsum, t, x_start.shape) * noise</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n<p>可以明显看出两者之间的区别，当然不仅仅是空格缩进的区别（哈哈）</p>\n<p>其次，<code>RDDM</code> 在扩散过程中需要同时训练两个模型 <span\nclass=\"math inline\">\\(I^{\\theta}_{res}(I_t,t,I_{in})\\)</span> 和 <span\nclass=\"math inline\">\\(\\epsilon_{\\theta}(I_t,t,I_{in})\\)</span>\n来分别预测每一步中应该存在的残差 <span\nclass=\"math inline\">\\(I^{\\theta}_{res}\\)</span> 和每一步中添加的噪声\n<span class=\"math inline\">\\(\\epsilon_{\\theta}\\)</span>\n。其中，模型训练的目标函数分别为： <span class=\"math display\">\\[\nL_{res}(\\theta):=\\mathbb{E}[\\lambda_{res}\\|I_{res} -\nI^{\\theta}_{res}(I_t,t,I_{in}) \\|^2]\\\\\nL_{\\epsilon}(\\theta):=\\mathbb{E}[\\lambda_{\\epsilon}\\| \\epsilon -\n\\epsilon_{\\theta}(I_t,t,I_{in}) \\|^2] \\tag{3}\n\\]</span> 这一部分在代码中体现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model_out = self.model(x_in,</span><br><span class=\"line\">                       [self.alphas_cumsum[t]*self.num_timesteps,</span><br><span class=\"line\">                       self.betas_cumsum[t]*self.num_timesteps],</span><br><span class=\"line\">                       x_self_cond)</span><br><span class=\"line\"><span class=\"comment\"># 这里 x_in 是 torch.cat((x_t, x_input, x_input_condition), dim=1) </span></span><br><span class=\"line\"><span class=\"comment\"># 后续是时间步</span></span><br><span class=\"line\"><span class=\"comment\"># x_self_cond 是与自注意力机制有关，目前不太清楚</span></span><br><span class=\"line\"><span class=\"comment\"># 这里的 model_out 是两个张量</span></span><br><span class=\"line\"><span class=\"comment\"># pred_res = model_out[0]</span></span><br><span class=\"line\"><span class=\"comment\"># pred_noise = model_out[1]</span></span><br><span class=\"line\"><span class=\"comment\"># 这里作者是通过创建两个 unet 模型来实现</span></span><br></pre></td></tr></table></figure>\n<p>紧接着是通过模型训练的目标函数进行损失计算，达到训练模型的目的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x_u = self.q_posterior_from_res_noise(pred_res, pred_noise, x, t)</span><br><span class=\"line\">u_gt = self.q_posterior_from_res_noise(x_res, noise, x, t)</span><br><span class=\"line\">loss = <span class=\"number\">10000</span>*self.loss_fn(x_u, u_gt, reduction=<span class=\"string\">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>这里主要是拆解一下 <code>self.q_posterior_from_res_noise()</code>\n这个函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">q_posterior_from_res_noise</span>(<span class=\"params\">self, x_res, noise, x_t, t</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x_t-extract(self.alphas, t, x_t.shape) * x_res -</span><br><span class=\"line\">           (extract(self.betas2, t, x_t.shape)/extract(self.betas_cumsum, t, x_t.shape)) * noise)</span><br></pre></td></tr></table></figure>\n<p>这里先引入一下原始的 <code>DDPM</code> 是如何计算损失的。 <span\nclass=\"math display\">\\[\nL(\\theta):=\\mathbb{E}_{I_0\\sim q(I_0),\\epsilon\\sim\n\\mathcal{N}(0,I)}[\\|\\epsilon - \\epsilon_{\\theta}(I_t,t)  \\|^2] \\tag{4}\n\\]</span> 可以看出，原始<code>DDPM</code>\n的损失计算十分简单，只需要计算模型预测出来的噪声和原始的噪声的差值即可。但是在\n<code>RDDM</code>\n中，引入了一个新的需要计算的损失，即残差之间的损失。<code>DDPM</code>\n的损失计算：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x_recon = self.denoise_fn(torch.cat([x_in[<span class=\"string\">&#x27;Input&#x27;</span>], x_noisy], dim=<span class=\"number\">1</span>), continuous_sqrt_alpha_cumprod)</span><br><span class=\"line\">loss = self.loss_func(noise, x_recon)</span><br></pre></td></tr></table></figure>\n<p>我们从代码比较中可以看出，<code>RDDM</code>\n并没有采用将两者损失分别计算然后相加的方法进行计算，而是通过函数\n<code>q_posterior_from_res_noise</code>\n计算出一个值，之后计算两个值之间的差值来进行损失计算和模型训练。通过代码分析，<code>q_posterior_from_res_noise</code>\n计算的是 <code>x_t - x_res - noise</code>\n，即应该是当前时间步下添加了残差和噪声的图像 <code>x_t</code>\n去除模型预测的残差和噪声的值。（⚠️这里其实我也不太确定，没有找的依据）</p>\n<p>至此，正向扩散过程和模型训练过程结束。</p>\n<p>后续，我们就可以利用训练好的网络预测得到的 <span\nclass=\"math inline\">\\(I^{\\theta}_{res}\\)</span> 和噪声 <span\nclass=\"math inline\">\\(\\epsilon_{\\theta}\\)</span> 从 <span\nclass=\"math inline\">\\(I_t\\)</span> 中 恢复 <span\nclass=\"math inline\">\\(I_{t-1}\\)</span> 。 <span class=\"math display\">\\[\nI_{t-1} = I_{t} - (\\bar{\\alpha}_t - \\bar{\\alpha}_{t-1})I^{\\theta}_{res}\n-\n(\\bar{\\beta}_{t}-\\sqrt{\\bar{\\beta}^2_{t-1}-\\sigma^2_t})\\epsilon_{\\theta}\n+ \\sigma_t\\epsilon_t,where\\quad \\epsilon_t\\sim \\mathcal{N}(0,I) \\\\\n\\sigma^2_t = \\eta \\beta^2_t \\bar{\\beta}^2_{t-1} / \\bar{\\beta}^2_{t}\n\\tag{5}\n\\]</span></p>\n<blockquote>\n<p>​ <code>RDDM</code> 其实是在正向扩散过程中加入了 <span\nclass=\"math inline\">\\(I_{in} - I_0 = I_{res}\\)</span>\n残差，意味着，原本正向扩散过程中只有 <span\nclass=\"math inline\">\\(I_0\\)</span> 变成了 有 <span\nclass=\"math inline\">\\(I_0,I_{res}\\)</span> 。也就是说网络从只学习 <span\nclass=\"math inline\">\\(I_0\\)</span> 分布变成了现在学习 <span\nclass=\"math inline\">\\(I_0,I_res\\)</span>\n分布。在这之后分别训练两个模型，一个专注于预测 <span\nclass=\"math inline\">\\(I_{res}\\)</span> 另一个专注于预测 <span\nclass=\"math inline\">\\(\\epsilon\\)</span>\n。作者指出，残差扩散代表了从退化图像 <span\nclass=\"math inline\">\\(I_{in}\\)</span> 到 <span\nclass=\"math inline\">\\(I_0\\)</span>\n的过程。代表了确定性。噪声扩散代表了从杂环无序的噪声 <span\nclass=\"math inline\">\\(\\epsilon\\)</span> 到 <span\nclass=\"math inline\">\\(I_0\\)</span> 的过程，代表了多样性。两者统一。</p>\n</blockquote>\n<h3 id=\"色彩空间\">26. 色彩空间</h3>\n<p>好的，下面是一个示例，展示了如何将彩色图像转换到频率空间进行处理，然后再转换回图像空间。这个过程将包括使用傅立叶变换和逆傅立叶变换。</p>\n<p>步骤概述</p>\n<ol type=\"1\">\n<li><strong>傅立叶变换</strong>：将图像从空间域转换到频率域。</li>\n<li><strong>频率域处理</strong>：在频率域中进行随机化处理。</li>\n<li><strong>逆傅立叶变换</strong>：将频率域图像转换回空间域。</li>\n</ol>\n<p>代码实现</p>\n<p>以下是一个Python示例代码，展示了如何完成这些步骤：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fft2_image</span>(<span class=\"params\">image</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 对图像的每个通道进行傅立叶变换</span></span><br><span class=\"line\">    channels = cv2.split(image)</span><br><span class=\"line\">    f_channels = [np.fft.fft2(channel) <span class=\"keyword\">for</span> channel <span class=\"keyword\">in</span> channels]</span><br><span class=\"line\">    fshift_channels = [np.fft.fftshift(f) <span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> f_channels]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fshift_channels</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ifft2_image</span>(<span class=\"params\">fshift_channels</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 对频率域的每个通道进行逆傅立叶变换</span></span><br><span class=\"line\">    ishift_channels = [np.fft.ifftshift(fshift) <span class=\"keyword\">for</span> fshift <span class=\"keyword\">in</span> fshift_channels]</span><br><span class=\"line\">    img_back_channels = [np.fft.ifft2(ishift) <span class=\"keyword\">for</span> ishift <span class=\"keyword\">in</span> ishift_channels]</span><br><span class=\"line\">    img_back_channels = [np.<span class=\"built_in\">abs</span>(img_back) <span class=\"keyword\">for</span> img_back <span class=\"keyword\">in</span> img_back_channels]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cv2.merge(img_back_channels)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">randomize_frequency</span>(<span class=\"params\">fshift_channels</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 对频率域的每个通道进行随机化处理</span></span><br><span class=\"line\">    randomized_channels = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> fshift <span class=\"keyword\">in</span> fshift_channels:</span><br><span class=\"line\">        magnitude = np.<span class=\"built_in\">abs</span>(fshift)</span><br><span class=\"line\">        phase = np.angle(fshift)</span><br><span class=\"line\">        randomized_phase = np.random.uniform(-np.pi, np.pi, phase.shape)</span><br><span class=\"line\">        randomized_fshift = magnitude * np.exp(<span class=\"number\">1j</span> * randomized_phase)</span><br><span class=\"line\">        randomized_channels.append(randomized_fshift)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomized_channels</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取图像</span></span><br><span class=\"line\">image = cv2.imread(<span class=\"string\">&#x27;path_to_your_image.jpg&#x27;</span>)</span><br><span class=\"line\">image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将图像转换到频率域</span></span><br><span class=\"line\">fshift_channels = fft2_image(image)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在频率域中进行随机化处理</span></span><br><span class=\"line\">randomized_fshift_channels = randomize_frequency(fshift_channels)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将频率域图像转换回空间域</span></span><br><span class=\"line\">reconstructed_image = ifft2_image(randomized_fshift_channels)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示结果</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">12</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Original Image&#x27;</span>)</span><br><span class=\"line\">plt.imshow(image)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Reconstructed Image&#x27;</span>)</span><br><span class=\"line\">plt.imshow(np.uint8(reconstructed_image))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p>解释</p>\n<ol type=\"1\">\n<li><strong>fft2_image</strong>：将图像的每个颜色通道进行傅立叶变换并移到频率中心。</li>\n<li><strong>ifft2_image</strong>：将每个通道从频率域转换回空间域。</li>\n<li><strong>randomize_frequency</strong>：在频率域中随机化相位信息。</li>\n<li>读取图像并转换到频率域。</li>\n<li>对频率域进行随机化处理。</li>\n<li>将随机化后的频率域图像转换回空间域。</li>\n<li>显示原始图像和处理后的图像。</li>\n</ol>\n<p>通过这种方法，我们可以看到如何在频率域中处理图像，并将处理结果转换回空间域。这样可以应用于图像去雾等任务。</p>\n<p><strong>但是这种直接应用的方法会带来大量的颜色失真</strong></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240707153639899.png\"\nalt=\"image-20240707153639899\" />\n<figcaption aria-hidden=\"true\">image-20240707153639899</figcaption>\n</figure>\n<p>在图像处理中，使用傅立叶变换将图像转到频率域，然后进行相位随机化，再转换回空间域，可能会引入颜色失真。这主要是因为在频率域随机化相位信息时，原始图像的色彩关系被破坏。以下是更详细的原因：</p>\n<p>原因</p>\n<ol type=\"1\">\n<li><p><strong>相位信息的影响</strong>：傅立叶变换将图像表示为频率成分，包含幅度和相位。幅度表示信号的强度，相位表示信号的位置。图像的颜色和细节主要由相位信息决定。随机化相位信息会导致颜色和结构信息失真，从而在重构图像时引入原始图像中没有的颜色。</p></li>\n<li><p><strong>颜色通道的独立处理</strong>：每个颜色通道（红、绿、蓝）被独立地进行傅立叶变换和随机化处理。由于通道间的相位关系被破坏，结果图像中的颜色可能不再准确反映原始图像的颜色。</p></li>\n</ol>\n<p>为了减少颜色失真，可以考虑只在亮度通道上进行处理，保持色彩信息不变。这样可以保留图像的颜色特征，减少颜色失真。以下是改进后的代码示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fft2_image</span>(<span class=\"params\">channel</span>):</span><br><span class=\"line\">    f = np.fft.fft2(channel)</span><br><span class=\"line\">    fshift = np.fft.fftshift(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fshift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ifft2_image</span>(<span class=\"params\">fshift</span>):</span><br><span class=\"line\">    ishift = np.fft.ifftshift(fshift)</span><br><span class=\"line\">    img_back = np.fft.ifft2(ishift)</span><br><span class=\"line\">    img_back = np.<span class=\"built_in\">abs</span>(img_back)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> img_back</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">randomize_frequency</span>(<span class=\"params\">fshift</span>):</span><br><span class=\"line\">    magnitude = np.<span class=\"built_in\">abs</span>(fshift)</span><br><span class=\"line\">    phase = np.angle(fshift)</span><br><span class=\"line\">    randomized_phase = np.random.uniform(-np.pi, np.pi, phase.shape)</span><br><span class=\"line\">    randomized_fshift = magnitude * np.exp(<span class=\"number\">1j</span> * randomized_phase)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomized_fshift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取图像</span></span><br><span class=\"line\">image = cv2.imread(<span class=\"string\">&#x27;path_to_your_image.jpg&#x27;</span>)</span><br><span class=\"line\">image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转换到HSV颜色空间</span></span><br><span class=\"line\">hsv_image = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)</span><br><span class=\"line\">v_channel = hsv_image[:, :, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对亮度通道进行傅立叶变换和随机化处理</span></span><br><span class=\"line\">fshift_v = fft2_image(v_channel)</span><br><span class=\"line\">randomized_fshift_v = randomize_frequency(fshift_v)</span><br><span class=\"line\">reconstructed_v_channel = ifft2_image(randomized_fshift_v)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新亮度通道并转换回RGB颜色空间</span></span><br><span class=\"line\">hsv_image[:, :, <span class=\"number\">2</span>] = reconstructed_v_channel</span><br><span class=\"line\">reconstructed_image = cv2.cvtColor(hsv_image, cv2.COLOR_HSV2RGB)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示结果</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">12</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Original Image&#x27;</span>)</span><br><span class=\"line\">plt.imshow(image)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Reconstructed Image&#x27;</span>)</span><br><span class=\"line\">plt.imshow(np.uint8(np.clip(reconstructed_image, <span class=\"number\">0</span>, <span class=\"number\">255</span>)))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p>解释</p>\n<ol type=\"1\">\n<li><p><strong>HSV颜色空间</strong>：转换图像到HSV颜色空间，分别处理色调（H），饱和度（S）和亮度（V）。这样可以只对亮度通道进行频率域处理，而不影响颜色信息。</p></li>\n<li><p><strong>亮度通道处理</strong>：对亮度通道进行傅立叶变换、相位随机化和逆变换，保持色调和饱和度通道不变。</p></li>\n</ol>\n<p>这样，重建后的图像会更好地保持原始图像的颜色特征，减少颜色失真。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240707153724375.png\"\nalt=\"image-20240707153724375\" />\n<figcaption aria-hidden=\"true\">image-20240707153724375</figcaption>\n</figure>\n<p>只对饱和度（S）和亮度（V）通道进行傅立叶变换、相位随机化和逆变换，可以减少对色调（H）信息的破坏，从而尽量保留颜色信息。以下是只处理饱和度和亮度通道的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fft2_image</span>(<span class=\"params\">channel</span>):</span><br><span class=\"line\">    f = np.fft.fft2(channel)</span><br><span class=\"line\">    fshift = np.fft.fftshift(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fshift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ifft2_image</span>(<span class=\"params\">fshift</span>):</span><br><span class=\"line\">    ishift = np.fft.ifftshift(fshift)</span><br><span class=\"line\">    img_back = np.fft.ifft2(ishift)</span><br><span class=\"line\">    img_back = np.<span class=\"built_in\">abs</span>(img_back)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> img_back</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">randomize_frequency</span>(<span class=\"params\">fshift</span>):</span><br><span class=\"line\">    magnitude = np.<span class=\"built_in\">abs</span>(fshift)</span><br><span class=\"line\">    phase = np.angle(fshift)</span><br><span class=\"line\">    randomized_phase = np.random.uniform(-np.pi, np.pi, phase.shape)</span><br><span class=\"line\">    randomized_fshift = magnitude * np.exp(<span class=\"number\">1j</span> * randomized_phase)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomized_fshift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取图像</span></span><br><span class=\"line\">image = cv2.imread(<span class=\"string\">&#x27;path_to_your_image.jpg&#x27;</span>)</span><br><span class=\"line\">image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转换到HSV颜色空间</span></span><br><span class=\"line\">hsv_image = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对饱和度和亮度通道进行傅立叶变换和随机化处理</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>):  <span class=\"comment\"># 只处理S和V通道</span></span><br><span class=\"line\">    channel = hsv_image[:, :, i]</span><br><span class=\"line\">    fshift = fft2_image(channel)</span><br><span class=\"line\">    randomized_fshift = randomize_frequency(fshift)</span><br><span class=\"line\">    reconstructed_channel = ifft2_image(randomized_fshift)</span><br><span class=\"line\">    hsv_image[:, :, i] = reconstructed_channel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转换回RGB颜色空间</span></span><br><span class=\"line\">reconstructed_image = cv2.cvtColor(hsv_image, cv2.COLOR_HSV2RGB)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示结果</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">12</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Original Image&#x27;</span>)</span><br><span class=\"line\">plt.imshow(image)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Reconstructed Image&#x27;</span>)</span><br><span class=\"line\">plt.imshow(np.uint8(np.clip(reconstructed_image, <span class=\"number\">0</span>, <span class=\"number\">255</span>)))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p>解释</p>\n<ol type=\"1\">\n<li><strong>转换到HSV颜色空间</strong>：将图像转换到HSV颜色空间，以便分别处理色调（H）、饱和度（S）和亮度（V）通道。</li>\n<li><strong>只处理饱和度和亮度通道</strong>：对饱和度和亮度通道（S和V）进行傅立叶变换、相位随机化和逆变换，保留色调（H）信息不变。</li>\n<li><strong>重建图像</strong>：将处理后的HSV图像转换回RGB颜色空间。</li>\n</ol>\n<p>这种方法只对饱和度和亮度通道进行处理，保留了色调信息，减少了颜色失真，效果会比处理所有通道更自然。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240707154232783.png\"\nalt=\"image-20240707154232783\" />\n<figcaption aria-hidden=\"true\">image-20240707154232783</figcaption>\n</figure>\n<h3\nid=\"contributions-of-shape-texture-and-color-in-visual-recognition\">5.Contributions\nof Shape, Texture, and Color in Visual Recognition</h3>\n<p><strong>摘要：</strong>\n我们研究了人类视觉系统（HVS）的三个重要特征——形状、纹理和颜色——对对象分类的贡献。我们构建了一个类人视觉引擎（HVE），该引擎从图像中明确且分别计算形状、纹理和颜色特征。然后将生成的特征向量连接起来，以支持最终的分类。我们展示了HVE能够总结和排名这三个特征对对象识别的贡献。我们使用人类实验来确认HVE和人类主要使用某些特定特征来支持特定类别的分类（例如，纹理是区分斑马与其他四足动物的主导特征，对于人类和HVE都是如此）。借助HVE的帮助，我们可以总结出任何环境（数据集）中整个任务（任务特定；例如，颜色是在CUB数据集上进行分类的整体最重要特征）以及每个类别（类别特定；例如，形状是在iLab-20M数据集中识别船只的最重要特征）的最重要特征。为了展示HVE的更多用途，我们使用它来模拟人类的开放世界零样本学习能力，而无需属性标记。最后，我们展示HVE还可以模拟人类的想象力，通过不同特征的组合。我们将开源HVE引擎和相应的数据集。</p>\n<p><strong>1 Introduction</strong></p>\n<p>人类视觉系统（HVS）是许多当前计算机视觉算法的黄金标准，用于各种具有挑战性的任务：零/少样本学习\n[37,32,52,42,50]，元学习 [2,30]，持续学习 [45,54,60]，新颖视角想象\n[62,17]等。了解HVS的机制、功能和决策流程变得越来越重要。人类和其他灵长类动物的视觉系统高度分化。尽管HVS为我们提供了一个统一的世界图像，但这幅图像具有多个方面或特征，如形状、深度、运动、颜色、纹理等\n[16,23]。为了理解在视觉识别中最重要的三个特征——形状、纹理和颜色——的贡献，一些研究将HVS与人工卷积神经网络（CNN）进行了比较。有关CNN在感知任务上取得成功的一个广泛接受的直觉是，CNN是人类腹侧通道物体识别的最具预测性的模型\n[7,61]。为了理解在基于CNN的识别中哪个特征更重要，最近的研究显示了令人鼓舞的结果：在ImageNet上训练的CNN对纹理具有偏好，而增加形状偏好会提高准确性和鲁棒性\n[33]。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/截屏2024-01-20%2019.52.42.png\"\nalt=\"截屏2024-01-20 19.52.42\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-20 19.52.42</figcaption>\n</figure>\n<p>左图：在不同的场景/任务中，形状、纹理和颜色的贡献可能不同。在这里，纹理对于区分斑马和马是最重要的，但对于斑马和斑马车，形状是最重要的。右图：人形视觉引擎以数据集为输入，以纯学习方式总结形状、纹理和颜色在给定识别任务中的贡献（例如，在ImageNet分类中，形状是最具有判别性的特征，对视觉识别的贡献最大）。</p>\n<p>由于HVS在各种复杂任务上取得了卓越的成功[37，2，45，62，19]，人类偏见也可能代表解决视觉任务的最有效方法。而且它可能取决于任务（图1）。在这里，受HVS的启发，我们希望找到一种通用的方法，通过纯粹的数据驱动学习来理解形状、纹理和颜色如何对识别任务做出贡献。总结的特征贡献对深度学习社区（指导准确性驱动模型的设计[33，22，15，6]）和神经科学社区（理解人类视觉识别的贡献或偏差）都很重要[35，59]。</p>\n<p>神经科学家已经证明，有单独的神经通路以处理灵长类动物的这些不同视觉特征[1，11]。在对人类视觉识别至关重要的多种特征中，形状特性是我们在静态对象识别中主要依赖的特性[16]。同时，先前的一些研究表明，基于表面的线索在我们的视觉系统中也起着关键作用。例如，[21]表明，与灰度图像相比，彩色图像的场景识别更快，并且[40，38]在我们的大脑中发现了一个特殊区域来分析纹理。总之，[9，8]提出形状、颜色和纹理是识别物体的三个独立组成部分。</p>\n<p>为了更好地理解这些功能的任务相关贡献，我们建立一个类人视觉引擎（HVE），通过显式和单独地计算形状、纹理和颜色特征来模拟HVS，以支持客观学习管道中的图像分类。HVE有以下主要贡献：(1)\n受到人脑在形状、质地和颜色等不同特征上的专业分离的启发\n[1,11]，我们针对每个特征设计了特定的特征提取流程和表示学习模型。(2)\n为了总结端到端学习中特征的贡献，我们设计了一个可解释的人形神经网络（HNN），它聚合了三个特征的学习表示，并实现了对象识别，同时显示了每个特征在决策过程中的贡献。(3)\n我们使用HVE分析了形状、质地和颜色在从ImageNet子采样的三个不同任务中的贡献。我们对相同任务进行了人类实验，并展示了HVE和人类在支持特定类别的对象识别时主要使用某些特定特征。(4)\n我们使用HVE探讨了形状、质地和颜色在视觉识别中的贡献、关系和互动。在任何环境（数据集）中，HVE都可以总结出整个任务（任务特定）和每个类别（类别特定）中最重要的特征（在形状、质地和颜色之间）。据我们所知，我们提供了首个完全客观、数据驱动且确实是一阶的定量度量各自贡献的方法。(5)\nHVE可以帮助指导以准确度为驱动的模型设计，并作为模型偏差的评估指标。在更多应用方面，我们使用HVE来模拟人类的开放世界零样本学习能力，该能力无需属性标签。HVE还可以模拟跨特征的人类想象力能力。我们开源了HVE引擎和相应的数据集。</p>\n<p><strong>2.Related Works</strong></p>\n<p>近年来，越来越多的研究人员关注计算机视觉模型的可解释性和泛化能力，如卷积神经网络（CNN）[48,24]和视觉Transformer\n[12]。对于CNN，许多研究人员试图探索模型识别对象时最重要的信息是什么。一些论文表明，在ImageNet上训练的CNN对纹理信息更为敏感[22,15,6]。但这些工作未能在各种数据集和情境中全面定量地解释形状、质地、颜色等不同特征的贡献。虽然最近的研究主要关注神经网络的偏差，探索人类或人形学习方式的偏差仍然是未被充分探讨且具有启发性的。此外，许多研究人员致力于改进计算机视觉模型的泛化能力，并关注零/少样本学习[37,32,57,50,18,10]、新颖视角的想象[62,17,20]、开放世界识别[3,28,27]等。其中一些通过特征学习来解决这些问题——通过不同特征表示对象，并在这一领域取得了重大进展[55,39,62]。但是，仍然缺乏对这些属性是什么样子或者一个可以执行类似泛化识别和想象的人形任务的系统的清晰定义。</p>\n<p><strong>3.Humanoid Vision Engine</strong></p>\n<p>人形视觉引擎（HVE）的目标是通过分别计算形状、质地和颜色三个特征来总结它们在给定任务（数据集）中的贡献，以支持图像分类，类似于人类识别对象的方式。在流程和模型设计过程中，我们借鉴了神经科学研究人员关于人类视觉系统（HVS）结构、机制和功能的发现[1,11,16,21,40,38]。我们使用端到端学习和反向传播来模拟人类的学习过程，并总结形状、质地和颜色的贡献。端到端训练的优势在于我们可以避免引入可能影响贡献归因目标的人类偏见（例如，我们不像在“Recognition\nby\nComponents”中那样引入手工制作的基本形状）。我们只使用数据驱动的学习，这是一种从有效性角度理解每个特征贡献的直接方式，而且我们可以轻松将HVE推广到不同的任务（数据集）。如图2所示，HVE包括（1）一个人形图像预处理流程，（2）形状、质地和颜色的特征表示，以及（3）一个聚合每个特征表示并实现可解释对象识别的人形神经网络。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/截屏2024-01-20%2020.11.19.png\"\nalt=\"截屏2024-01-20 20.11.19\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-20 20.11.19</figcaption>\n</figure>\n<blockquote>\n<p>步骤：</p>\n<p>首先显著图算法得到人眼主动关注的区域的图像，同时对图像进行实体分割。综合这两种将图像内的主要物体凸显出来。之后再进行图像的形状、纹理和颜色特征提取。</p>\n</blockquote>\n<p>图2. 人形视觉引擎（HVE）的流程图。 (a)\n展示了人类视觉系统如何处理图像。在人类眼睛感知到物体后，大脑的不同部分将被激活。人脑将组织和总结这些信息以得出结论。\n(b) 展示了我们如何设计HVE来对应人类视觉系统的每个部分。</p>\n<p><strong>3.1 Humanoid Image Preprocessing and Feature\nExtraction</strong></p>\n<p>如图2(a)所示，人类（或灵长类动物）能够在复杂场景中直观地定位一个物体，即使在我们识别出这个物体是什么之前[29]。此外，在我们的初级视觉皮层中存在不同类型的细胞或感受器，它们从图像中提取特定信息（如颜色、形状、质地、阴影、运动等）[16]。在我们的HVE中，对于一个输入的图像\n<span class=\"math inline\">\\(I\\in \\mathbb{R}^{H\\times W\\times C}\\)</span>\n，我们首先解析从场景中提取对象作为预处理，然后提取我们定义的形状、纹理和颜色特征\n<span class=\"math inline\">\\(I_s,I_t,I_c\\)</span>\n，用于下面的类人神经网络。</p>\n<p><strong>图像解析和前景识别。</strong>如图2(b)的预处理部分所示，我们使用实体分割方法[41]来模拟从大脑中的场景中解析对象的过程。实体分割是一种开放世界模型，可以在没有标签的情况下从图像中分割对象。这种方法符合人类的行为，人类可以（至少在某些情况下；例如，自动立体图[29]）在不确定对象是什么的情况下分割对象。在获得图像分割后，我们使用预训练的CNN和GradCam\n[47]来找到所有掩码中的前景对象。（更多细节请参见补充材料。）在确定前景对象段之后，我们设计了三个不同的特征提取器：形状提取器、质地提取器和颜色提取器，类似于人脑中专注于特定属性的不同神经通路[1,11]。这三个提取器仅关注相应的特征，并且提取的形状特征Is、质地特征It和颜色特征Ic之间是分离的。</p>\n<p><strong>Shape Feature\nExtractor</strong>对于形状提取器，我们希望保留二维和三维形状信息，同时消除纹理和颜色的信息。\n我们首先使用一个<strong>三维深度预测模型</strong>[44,43]来获得整个图像的三维深度信息。将三维深度估计和物体的二维遮罩进行元素相乘后，我们得到形状特征I_s\n^{H\nW}。我们可以注意到，这个特征只包含二维形状和三维结构信息（三维深度），没有颜色和纹理信息（图2（b））。</p>\n<p><strong>质地特征提取器：</strong>在质地提取器中，我们希望保留局部和全局的质地信息，同时消除形状和颜色信息。图3可视化了提取过程。首先，为了去除颜色信息，我们将RGB对象分割转换为灰度图像。接下来，我们使用自适应策略将这个图像切割成几个正方形补丁（补丁的大小和位置会随着对象的大小自适应变化，以覆盖更多的质地信息）。如果补丁与原始的2D对象分割之间的重叠比例大于一个阈值\nτ，我们将该补丁添加到一个补丁池中（在我们的实验中，我们将 τ\n设置为0.99，这意味着补丁的99%以上的区域属于对象）。由于我们希望提取局部（一个补丁）和全局（整个图像）的质地信息，我们随机从补丁池中选择4个补丁，并将它们连接成一个新的质地图像（It）。（更多细节请参见补充材料。）</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/截屏2024-01-20%2021.03.12.png\"\nalt=\"截屏2024-01-20 21.03.12\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-20 21.03.12</figcaption>\n</figure>\n<p><strong>颜色特征提取器：</strong>我们使用两种方法来表示给定图像 I\n的颜色特征。第一种方法是相位混沌，这在心理物理学和信号处理中很流行[36,53]。相位混沌将图像转换为频域，使用快速傅里叶变换（FFT）。在频域中，信号的相位被随机混乱，这会破坏形状信息同时保留颜色统计信息。随后我们使用IFFT转换回图像空间。并且得到\n<span class=\"math inline\">\\(I_c\\in \\mathbb{R}^{H\\times W \\times\nC}\\)</span> 。Ic和I有相同的像素颜色值的分布。</p>\n<blockquote>\n<p><strong>首先，通过快速傅里叶变换将图像转换为频域，这个过程破坏了图像的形状信息，但保留了图像的颜色统计信息。然后，通过逆傅里叶变换将频域中的图像转换回图像空间，得到了经过相位混沌处理的图像。这个过程使得图像在形状上发生了变化，但颜色分布在像素级别上保持相似。</strong></p>\n</blockquote>\n<p>我们还使用了简单的颜色直方图（详见补充材料）作为一种替代方法，但结果并不理想，因此我们在这里集中讨论相位混乱方法作为颜色表示的方式。</p>\n<blockquote>\n<p>颜色块：第二种方法使用统计的颜色直方图表示[56,14]。原始的RGB颜色空间是一个三维的立方体{(r,\ng, b)|r, g, b ∈ [0,\n255]}。为了表示每个图像的颜色分布，我们首先选择了27个均匀分布在整个颜色空间中的中心点。我们选择的颜色如图12所示。对于输入图像，我们通过计算它们的曼哈顿距离，将每个像素分配到最近的中心点。通过计算属于每个颜色中心的像素数量并计算百分比，我们可以将结果总结为一个尺寸为224×224的颜色块图像作为我们的颜色特征Ic（示例见图13）。颜色块由不同宽度和颜色的各种条纹组成。条纹的颜色来自于颜色中心，宽度表示该中心在输入图像中覆盖了多少百分比的像素。例如，如果有10%的像素分配给白色，90%的像素分配给黑色，我们将生成一个图像，其中10%的像素是RGB（255,\n255, 255），90%的像素是RGB（0, 0,\n0）。这个图像（Ic）不包含任何形状或质地信息。图13展示了一些颜色块的示例。</p>\n<p>与相位混沌相比，这种方法更直观易懂，但在将颜色空间中的RGB值近似为颜色中心时可能会丢失信息。</p>\n</blockquote>\n<p><strong>3.2 Humanoid Neural Network</strong></p>\n<p>经过上述过程后，我们得到三个特征：图像 <span\nclass=\"math inline\">\\(I\\)</span> 的形状特征 <span\nclass=\"math inline\">\\(I_s\\)</span> 和 纹理特征 <span\nclass=\"math inline\">\\(I_t\\)</span> 以及颜色特征 <span\nclass=\"math inline\">\\(I_c\\)</span>\n。为了模拟人类大脑中不同特征信息的独立神经通路[1，11]，我们分别为形状、纹理和颜色设计了三个特征表示编码器。形状特征编码器\nEs 接受 3D 形状特征 Is 作为输入，并输出形状表示（Vs =\nEs(Is)）。类似地，质地编码器 Et 和颜色编码器 Ec 接受质地图像 It\n或颜色相位混乱图像 Ic 作为输入，经过 Et（或 Ec）嵌入后，我们得到质地特征\nVt 和颜色特征 Vc。</p>\n<p>我们使用ResNet-18\n[24]作为所有特征编码器的骨干网络，将三种类型的特征投影到相应的良好分离的嵌入空间。定义特征之间距离的地面实况标签很难。鉴于同一类别的对象在形状、质地和颜色上相对一致，编码器可以独立于分类问题中进行训练，以类别标签的监督进行。在将编码器训练为分类器后，最后一个卷积层的特征图将作为最终的特征表示。（更多细节请参见附录。）</p>\n<p>为了聚合分离的特征表示并进行对象识别，我们冻结三个编码器并训练一个贡献可解释的聚合模块\nAggrθ，该模块由两个全连接层组成（图2(b)右侧）。\n（在附录B.3中进行更多探索）。我们将 Vs、Vt、Vc 连接起来并发送给\nAggrθ。输出用 p ∈ Rn 表示，其中 n 是类别的数量。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-20 21.18.59.png\" alt=\"截屏2024-01-20 21.18.59\" style=\"zoom:50%;\" /></p>\n<p>我们还提出了一种基于梯度的贡献归因方法，以解释形状、质地和颜色对分类决策的贡献。以形状特征为例，给定一个预测\np 和类别 k 的概率 pk，我们计算 pk 相对于形状特征 Vs\n的梯度。我们将梯度定义为形状重要性权重 αsk：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-20 21.19.47.png\" alt=\"截屏2024-01-20 21.19.47\" style=\"zoom:50%;\" /></p>\n<p>然后，我们可以计算Vs和αsk之间的逐元素乘积，得到最终的形状贡献\nSsk。换句话说，Ssk表示形状特征对将此图像分类为类别 k 的“贡献”。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-01-20 21.20.26.png\" alt=\"截屏2024-01-20 21.20.26\" style=\"zoom:50%;\" /></p>\n<p>我们可以做相同的操作得到质地贡献 Stk 和颜色贡献\nSck。在获得每个图像的特征贡献后，我们可以计算该类别中所有图像的平均值，将特征贡献分配给每个类别（类别特定偏差），并计算所有类别的平均值，将特征贡献分配给整个数据集（任务特定偏差）。</p>\n<h3\nid=\"building-bridges-across-spatial-and-temporal-resolutions-reference-based-super-resolution-via-change-priors-and-conditional-diffusion-model\">27.Building\nBridges across Spatial and Temporal Resolutions: Reference-Based\nSuper-Resolution via Change Priors and Conditional Diffusion Model</h3>\n<p>基于参考的超分辨率（RefSR）在跨越遥感图像的空间和时间分辨率方面具有潜力。然而，现有的RefSR方法在大缩放因子下的内容重建的真实性和纹理传递的有效性方面存在局限性。条件扩散模型为生成逼真的高分辨率图像开辟了新的机会，但如何在这些模型中有效利用参考图像仍然是一个需要进一步探索的领域。此外，在没有相关参考信息的区域，内容保真度难以保证。为了解决这些问题，我们提出了一种名为Ref-Diff的变化感知扩散模型，用于RefSR，利用土地覆盖变化先验知识显式地指导去噪过程。具体来说，我们将这些先验知识注入去噪模型，以提高在未变化区域中对参考信息的利用，并调节在变化区域中语义相关内容的重建。通过这种强大的指导，我们解耦了语义引导去噪和参考纹理引导去噪过程，以提高模型性能。大量实验表明，与最新的RefSR方法相比，所提出的方法在定量和定性评估中具有卓越的效果和鲁棒性。代码和数据可在https://github.com/dongrunmin/RefDiff获取。</p>\n<h3\nid=\"boosting-image-restoration-via-priors-from-pre-trained-models\">28.Boosting\nImage Restoration via Priors from Pre-trained Models</h3>\n<p>大规模训练数据的预训练模型，如CLIP和Stable\nDiffusion，在各种高层次计算机视觉任务（如图像理解和基于语言描述的图像生成）中表现出了显著的性能。然而，它们在图像修复等低层次任务中的潜力尚未被充分探索。在本文中，我们探索了这些模型来增强图像修复。由于预训练模型的现成特征（OSF）不能直接用于图像修复，我们提出了一个额外的轻量级模块，称为预训练引导修复模块（PTG-RM），以利用OSF对目标修复网络的修复结果进行优化。PTG-RM由两个组件组成：预训练引导的空间可变增强（PTG-SVE）和预训练引导的通道-空间注意（PTG-CSA）。PTG-SVE实现了最佳的短程和长程神经操作，而PTG-CSA则增强了与修复相关的空间-通道注意。大量实验表明，PTG-RM凭借其紧凑的尺寸（&lt;1M参数），有效地增强了各种模型在不同任务中的修复性能，包括低光增强、去雨、去模糊和去噪。</p>\n<p><strong>引言：</strong> 本文探索了利用预训练模型（如CLIP和Stable\nDiffusion）的特征来增强图像修复任务的潜力。传统的预训练模型在高层次任务（如图像理解和生成）中表现优异，但在图像修复等低层次任务中的直接应用仍然相对较少。</p>\n<p><strong>提出的方法：</strong>\n为了解决这一问题，作者提出了预训练指导的细化模块（PTG-RM），包括： -\n<strong>预训练指导的空间变化增强（PTG-SVE）：</strong>\n实现最佳的短程和长程神经操作。 -\n<strong>预训练指导的通道-空间注意力（PTG-CSA）：</strong>\n增强与修复相关的空间通道注意力学习。</p>\n<p>这些组件旨在利用预训练模型的现成特征（OSF）来细化目标修复网络的修复结果。</p>\n<p><strong>主要特点：</strong> 1. <strong>PTG-SVE 和 PTG-CSA\n机制：</strong>\n这些机制统一了预训练特征的形状，并制定了由这些特征引导的最佳操作范围和注意策略。\n2. <strong>轻量化设计：</strong> PTG-RM 结构紧凑，参数少于 100\n万，使其高效地集成到各种修复网络中。</p>\n<p><strong>实验和结果：</strong> -\n作者在包括低光增强、去雨、去模糊和去噪在内的不同任务上进行了广泛的实验。\n- 结果表明，PTG-RM 能有效提升各种修复模型的性能。 - 一项包含 80\n名参与者的大规模用户研究证实了用户对 PTG-RM 增强结果的主观偏好。</p>\n<p><strong>结论：</strong>\n研究表明，可以利用预训练特征显著改善图像修复任务。所提出的\nPTG-RM，通过其 PTG-SVE 和 PTG-CSA\n组件，提供了一种整合这些特征的新方法，从而提高了修复性能。该方法具有通用性，可以潜在地应用于其他领域。</p>\n<p><strong>未来工作：</strong> 论文指出，尽管 PTG-RM\n提升了性能，但提升的程度各不相同。未来的工作将致力于开发更有效的方法，针对特定的修复任务进行优化，并创建相应的技术产品</p>\n<p>这篇论文的主要思路是通过利用预训练模型（如CLIP和Stable\nDiffusion）的大规模训练数据所获得的特征，来提升图像恢复任务的性能。以下是论文的全文思路概要：</p>\n<ol type=\"1\">\n<li><strong>研究背景</strong>：\n<ul>\n<li>大规模预训练模型在高层次计算机视觉任务（如图像理解和从语言描述生成图像）中表现出色。</li>\n<li>但在低层次任务（如图像恢复）中的潜力尚未得到充分探索。</li>\n</ul></li>\n<li><strong>问题陈述</strong>：\n<ul>\n<li>直接使用预训练模型提取的特征（OSF）不能很好地服务于图像恢复任务。</li>\n<li>需要一个轻量级模块来精细化这些特征，以提升图像恢复的效果。</li>\n</ul></li>\n<li><strong>提出的解决方案</strong>：\n<ul>\n<li>设计了一个名为预训练引导细化模块（PTG-RM）的轻量级模块，用于精细化目标恢复网络的结果。</li>\n<li>PTG-RM包含两个子组件：预训练引导的空间变化增强（PTG-SVE）和预训练引导的通道空间注意力（PTG-CSA）。</li>\n<li>PTG-SVE提供了最优的短程和长程神经操作，而PTG-CSA增强了与恢复学习相关的空间通道注意力。</li>\n</ul></li>\n<li><strong>具体实现</strong>：\n<ul>\n<li>PTG-RM模块通过两个子组件来处理图像特征。</li>\n<li>PTG-SVE模块实现空间上的增强，优化神经操作。</li>\n<li>PTG-CSA模块增强了通道和空间上的注意力机制，提高图像恢复的效果。</li>\n</ul></li>\n<li><strong>实验结果</strong>：\n<ul>\n<li>通过广泛的实验验证了PTG-RM的有效性和紧凑性（参数少于1M）。</li>\n<li>在不同的图像恢复任务（包括低光增强、去雨、去模糊和去噪）中，PTG-RM显著提升了各种模型的恢复性能。</li>\n</ul></li>\n<li><strong>结论</strong>：\n<ul>\n<li>预训练模型中的特征可以有效地用于低层次的图像恢复任务。</li>\n<li>PTG-RM模块通过精细化预训练特征，显著提高了图像恢复的效果。</li>\n</ul></li>\n</ol>\n<p>该论文的创新点在于提出了PTG-RM模块，通过预训练模型中的特征来提升图像恢复任务的性能，并在多个任务中验证了其有效性。</p>\n<p><strong>1.Introduction</strong></p>\n<p>图像恢复在现实场景中发挥着重要作用，旨在通过消除退化现象来重建高质量图像。它在多个领域有广泛应用，例如在去噪[43,\n44]和低光增强[41, 42]中，用于提高手机拍摄的照片质量。</p>\n<p>尽管已有有效的恢复网络被提出[19,\n52]，但图像恢复固有的病态特性使得单纯通过修改网络结构难以实现显著的改善。简单地增加模型参数并不保证更好的结果，因为模型可能会倾向于对训练数据过拟合。恢复性能依赖于强大的图像先验信息，例如去噪的新颖级别[38]或去模糊中的模糊核[14,\n50]。然而，估计这些先验信息具有挑战性，特别是在处理真实世界数据时。有些方法利用物理变量作为先验，例如深度信息[46]和从预训练网络中提取的语义特征[1,\n36,\n41]。然而，这些物理变量的鲁棒性不足，因为密集的深度/语义预测网络在恢复任务中对不同场景的泛化能力不够。因此，使用这些变量需要复杂且特定的机制，限制了它们在各种任务中的适用性。在本文中，我们提出了一种新方法，<strong>从预训练模型中提取与退化相关的信息</strong>（这些模型在预训练过程中暴露于各种退化情况中），而不需要显式的标注。</p>\n<p>动机。两类预训练模型在训练期间可能包含与退化相关的信息：恢复模型和在大规模数据上预训练的模型（例如，CLIP\n[27]、BLIP [16]和BLIP2\n[17]）。使用前者是显而易见的，但在某些类型退化下训练的模型可能无法有效地帮助恢复其他类型退化的图像。使用后者仍未被探索。CLIP-IQA\n[33]发现CLIP特征包含退化相关信息，因此对图像评估有用，但尚未提出任何恢复方法。现有的预训练多模态模型可能已经在各种退化图像上进行训练。假设在预训练期间没有恢复相关的标注，其生成的特征可能包含对图像恢复有价值的信息。关键是利用这些信息来帮助目标恢复学习。然而，预训练模型和恢复模型的异质性使得使用预训练模型提取的现成特征存在困难。</p>\n<p>技术创新。我们引入了一种新颖的预训练指导细化模块（PTG-RM），利用预训练模型G计算的现成特征（OSF）来改善图像恢复任务。PTG-RM\nR是一个轻量级插件（图2）（额外的R总共少于100万参数）。PTG-RM使我们能够确定最佳操作范围和空间-通道注意力，从而促进图像恢复。它将来自F的初步增强图像、输入图像及其由预训练模型提取的OSF作为输入。PTG-RM与F一起训练（使用与F相同的损失）并自适应地增强它。PTG-RM\nR由两个组件组成：预训练指导的空间变化增强（PTG-SVE）和预训练指导的通道-空间注意力（PTG-CSA）。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/截屏2024-07-23%2015.14.17.png\"\nalt=\"截屏2024-07-23 15.14.17\" />\n<figcaption aria-hidden=\"true\">截屏2024-07-23 15.14.17</figcaption>\n</figure>\n<p>图2。我们提出了一个轻量级插件，即预训练指导细化模块（PTG-RM），以利用预训练模型来增强图像恢复。所需的先验是OFS\nG(Id)。它有两个组成部分，分别是PTG空间变化增强（PTG-SVE）和PTG通道-空间注意力（PTG-CSA）。图3展示了它们的详细信息。我们的PTG-RM在各种任务中的恢复效果显著提高，如右上角所列（参见图1中的定量结果预览）。</p>\n<p>PTG-SVE\n采用空间变化操作来细化初步增强的结果，不同区域的处理方式有所不同。与之前依赖固定参考来确定最佳操作范围的方法[42]不同，我们建立了一个空间感知的可学习映射用于OSF，并利用映射后的特征作为空间指导。这种方法自适应地融合了从短距离和长距离操作中提取的特征，使不同区域能够得到适当的细化，从而实现更有效的增强。在\nPTG-SVE 之后，PTG-CSA 通过与 OSF\n形成有效的通道和空间注意力机制进一步增强结果。我们注意到，不同区域可能需要不同程度的特征正确性，因此我们提出生成空间变化的卷积核来合成空间权重。我们的方法针对不同区域定制了注意力处理过程。</p>\n<p>贡献：我们做出了三项主要贡献。 -\n我们提出了一种新颖且通用的方法，利用预训练模型来增强各种恢复任务。我们的工作为在各个领域提高性能开辟了可能性。\n-\n我们提出了一种新颖的范式，利用预训练的先验来制定有效的神经操作范围和注意力机制。\n-\n我们通过对不同数据集、网络和任务的广泛实验验证了我们的方法，展示了相对于以前方法的显著改进（参见图1）。</p>\n<p><strong>2.Related Work</strong></p>\n<p>图像恢复中的先验信息。不同的恢复任务需要不同的图像先验信息，例如用于去噪的噪声水平和用于去模糊的模糊核。由于恢复任务的病态性质，估计这些先验信息非常困难。在实际场景中，这些先验信息通常是交织在一起的，这进一步增加了恢复过程的复杂性。近期的文献介绍了几种方法，通过利用多模态图作为统一的先验信息来改善恢复效果。这些方法主要依赖预先计算的物理多模态图。例如，SKF\n[41] 使用语义图来优化低光增强的特征空间。SMG [46]\n采用生成框架，将边缘、深度和语义信息整合在一起，以增强低光场景的初始外观建模。此外，一些方法使用近红外（NIR）信息来改进成像结果\n[12, 32]。这些先验信息也应用于其他恢复任务，如图像去噪 [20] 和去雨\n[18]。然而，使这些先验信息与输入图像对齐可能具有挑战性，并且先验信息中的错误可能会对性能产生不利影响。与现有工作不同，我们提出利用预训练模型作为先验信息来增强图像恢复。</p>\n<p>预训练模型在下游任务中的应用。近年来，一系列基于大规模训练数据集的预训练模型不断涌现，特别是多模态模型，如\nCLIP [27]、BLIP [16] 和 BLIP2\n[17]。这些模型学习到的特征空间提供了丰富的知识，能够为各种任务带来益处。尽管先前的工作已经证明了\nCLIP 在高层次任务中的有效性，例如零样本分类 [6, 53]、图像编辑 [4,\n25]、开放世界分割 [39, 60] 和 3D 分类 [47,\n59]，但其在辅助低层次恢复任务中的潜力仍未被探索。目前，仅在图像质量评估方面展示了这种能力，如在\nCLIP-IQA\n中。我们提出了一个通用框架，以利用预训练模型来改进各种恢复任务。</p>\n<p>在浓雾方向我只有一种做法，就是让模型自己根据已有背景生成那些区域！！！</p>\n<h3\nid=\"structure-matters-tackling-the-semantic-discrepancy-in-diffusion-models-for-image-inpainting结构很重要解决扩散模型在图像修复中语义差异的问题\">29.Structure\nMatters: Tackling the Semantic Discrepancy in Diffusion Models for Image\nInpainting(结构很重要：解决扩散模型在图像修复中语义差异的问题)</h3>\n<p><strong>用于图像修复的去噪扩散概率模型（DDPMs）旨在通过正向过程将噪声添加到图像的纹理中，并通过反向去噪过程利用未被遮盖的纹理恢复被遮盖的区域。尽管生成了有意义的语义，但现有方法在遮盖区域和未遮盖区域之间存在语义差异问题，因为在扩散过程中，语义密集的未遮盖纹理无法被完全降解，而被遮盖的区域则变成了纯噪声，从而导致它们之间的巨大差异。在本文中，我们旨在回答未遮盖的语义如何指导纹理去噪过程；以及如何解决语义差异问题，以促进一致且有意义的语义生成。为此，我们提出了一种用于图像修复的新型结构引导扩散模型，称为StrDiffusion，该模型在结构指导下重新定义了传统的纹理去噪过程，以得出简化的图像修复去噪目标，同时揭示出：1）语义稀疏的结构有助于在早期阶段解决语义差异，而密集的纹理则在后期生成合理的语义；2）未遮盖区域的语义本质上为纹理去噪过程提供了时间依赖的结构指导，受益于结构语义的时间依赖稀疏性。对于去噪过程，我们训练了一个结构引导的神经网络，通过利用遮盖区域和未遮盖区域之间去噪结构的一致性来估计简化的去噪目标。此外，我们设计了一种自适应重采样策略，作为结构是否有能力指导纹理去噪过程的正式标准，同时调节它们的语义相关性。大量实验证明，StrDiffusion在与现有最先进方法的对比中具有优势。我们的代码可在<a\nhref=\"https://github.com/htyjers/StrDiffusion\">https://github.com/htyjers/StrDiffusion</a>上获取。</strong></p>\n<blockquote>\n<p>利用遮盖区域和未遮盖区域之间去噪结构一致性来估计简化的去噪目标</p>\n</blockquote>\n<p><strong>1.Introduction</strong></p>\n<hr />\n<p>最近，图像修复在许多应用中得到了\n广泛支持，例如照片修复和图像编辑，其目标是利用未遮盖区域的语义信息来恢复图像的被遮盖区域。这个过程主要涉及两个方面：为被遮盖区域生成合理的语义，并确保这些语义与未遮盖区域的语义一致。先前的研究主要包括基于扩散的方案【2,\n8】和基于补丁的方案【1, 4,\n10】，这些方法倾向于通过简单的色彩信息修复图像中的小遮罩或重复模式，但无法处理不规则或复杂的遮罩。为了解决这个问题，大量研究【15,\n17, 31,\n36】转向了卷积神经网络（CNN），这些网络致力于对被遮盖区域周围的局部语义进行编码，但忽略了未遮盖区域的全局信息，导致距离遮罩边界较远的区域依然模糊。最近，自注意力机制【5,\n14, 16, 32,\n35】被提出，通过分割后的图像补丁的形式将被遮盖区域与未遮盖区域全局关联起来，增强了它们之间的语义一致性。然而，这些策略在处理遮罩区域内不同补丁的语义关联性时表现不佳。为此，语义稀疏结构【3,\n7, 9, 13, 18, 20, 27, 28, 33,\n34】被用于加强这些关联性，但这意味着对结构与纹理之间语义一致性的高度依赖，因此不可避免地在修复后的输出中会产生伪影。</p>\n<p>幸运的是，去噪扩散概率模型（DDPMs）【12,\n25】作为强大的生成模型，已经在语义生成和模式收敛方面取得了显著进展，因此很好地弥补了图像修复中的语义生成不足【22,\n23, 29,\n39】。具体来说，与专注于训练过程不同，文献【22】提出采用预训练的DDPMs作为先验，并开发了一种重采样策略，以在推理过程中条件化逆向去噪过程。此外，文献【23】尝试通过利用未遮盖区域的语义来对图像修复的扩散过程进行建模，从而为去噪过程提供了最优的逆向解决方案。这些方法大多在DDPMs的优势下展示了语义上有意义的修复结果，但忽视了被遮盖区域与未遮盖区域之间的语义一致性。直观上，语义密集的未遮盖纹理被退化为未遮盖纹理与高斯噪声的组合，而被遮盖区域在扩散过程中则变成纯噪声，从而导致它们之间存在较大的差异（见图1(a)和图2(a)），这也激发了以下研究动机：</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240805220640592.png\" alt=\"image-20240805220640592\" style=\"zoom:50%;\" /></p>\n<p>图1.\n现有的研究方法，如IR-SDE【23】(a)，尽管在去噪过程中为被遮盖区域生成了有意义的语义，但仍然面临被遮盖区域和未遮盖区域之间的语义差异问题（⃝）。我们的StrDiffusion\n(b)通过辅助稀疏结构的指导，解决了语义差异问题，从而产生了一致且有意义的去噪结果。实验是在PSV【6】数据集上进行的。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/论文阅读/image-20240805220832421.png\"\nalt=\"image-20240805220832421\" />\n<figcaption aria-hidden=\"true\">image-20240805220832421</figcaption>\n</figure>\n<p>图2.\n关于稀疏结构是否有助于缓解图像修复中去噪过程中的语义差异问题的动机实验示例。除了IR-SDE【23】(a)中的密集纹理外，还将未遮盖的语义与高斯噪声结合设置为稀疏结构，例如灰度图(b)和边缘图(c)。我们的StrDiffusion\n(d)能够通过逐步稀疏的结构解决语义差异问题。阴影区域表示在去噪过程中被遮盖区域和未遮盖区域之间的差异。PSNR（越高越好）通过计算它们之间的语义相似度，反映了被遮盖（未遮盖）区域相比于完整图像（即真实值）的语义恢复情况。修复后的结果是通过将去噪结果的遮挡区域与原始遮挡图像结合得到的。</p>\n<ol type=\"1\">\n<li><p>未遮盖的语义如何指导图像修复中的纹理去噪过程？我们的动机实验（见图2）表明，当未遮盖的语义与噪声结合后变得更稀疏，例如，利用被遮盖图像的灰度图或边缘图作为替代时，语义差异问题得到了极大缓解，但同时，在修复结果中出现了较大的语义信息损失（见图2(b)(c)）。因此，未遮盖区域的恒定语义在时间上无法很好地指导纹理去噪过程。</p></li>\n<li><p>继(1)之后，人们自然会问，如何生成语义一致且有意义的去噪结果？显然，稀疏结构在去噪过程的早期阶段有助于语义一致性，而密集纹理在后期阶段倾向于生成有意义的语义，这意味着在去噪结果的语义一致性和合理性之间需要找到平衡。为了进一步产生理想的结果，我们考虑在纹理去噪过程中引入结构作为辅助指导（见图1(b)）。</p></li>\n</ol>\n<p>为了解答上述问题，我们提出了一种新的结构引导纹理扩散模型，称为StrDiffusion，用于图像修复，旨在解决遮盖区域与未遮盖区域之间的语义差异，同时生成合理的遮盖区域语义；在技术上，我们在结构的指导下重新制定了传统的纹理去噪过程，以得出简化的图像修复去噪目标。在去噪过程中，训练了一个结构引导的神经网络，用于估计简化的去噪目标，通过利用遮盖区域与未遮盖区域之间去噪结构的时间一致性来缓解语义差异问题。我们的StrDiffusion模型揭示了：</p>\n<ol type=\"1\">\n<li>语义稀疏的结构在早期阶段有助于去噪结果的语义一致性，而密集的纹理在后期阶段进行语义生成；</li>\n<li>未遮盖区域的语义本质上为纹理去噪过程提供了时间依赖的结构指导，从中受益的是结构语义的时间依赖稀疏性。</li>\n</ol>\n<p>同时，我们指出，结构是否能够很好地指导纹理在很大程度上取决于它们之间的语义关联性。受此启发，我们提出了一种自适应重采样策略，用于监控语义关联性，并通过重采样迭代对其进行调节。对典型数据集的大量实验验证了StrDiffusion相对于现有技术的优越性。</p>\n<p><strong>2.Structure-Guided Texture Diffusion Models</strong></p>\n<p>我们方法的核心在于三个方面：</p>\n<ol type=\"1\">\n<li>如何解决遮盖区域与未遮盖区域之间的语义差异（第2.2节）；</li>\n<li>结构引导的图像修复去噪网络（第2.3节）；以及</li>\n<li>更深入的探讨结构是否能够良好地引导纹理（第2.4节）。</li>\n</ol>\n<p>在详细说明我们的技术之前，我们将首先介绍用于图像修复的DDPMs（去噪扩散概率模型）。</p>\n<p><strong>2.1.Preliminaries:Denoising Diffusion Probabilistic Models\nfor Image Inpainting</strong></p>\n<p>以下是这段内容的中文翻译：</p>\n<hr />\n<p>给定一张完整的图像 $I_{gt} ^{3 H W}) <span\nclass=\"math inline\">\\(和二值掩码 \\(\\)</span>M {0, 1}^{1 H W}<span\nclass=\"math inline\">\\(\\)（0表示被遮盖的区域，1表示未被遮盖的区域），图像修复的目标是通过恢复被遮盖的图像\n\\(\\)</span>I_m = I_{gt} M$)\n来生成修复后的图像。对于扩散模型，修复结果是通过将去噪结果中的遮盖区域与原始遮盖图像合并而得到的。用于修复的典型DDPMs（去噪扩散概率模型）[23]\n基本上包括前向纹理扩散过程和反向纹理去噪过程：</p>\n<p><strong>前向纹理扩散过程：</strong>\n在前向扩散过程中，利用未被遮盖区域的语义信息来引导图像修复的纹理去噪过程。具体来说，对于具有T个时间步的扩散过程，我们将初始纹理状态设为\n(<span class=\"math inline\">\\(y_0 = I_{gt}\\)</span>) ，终端纹理状态\n(<span class=\"math inline\">\\(y_T\\)</span>) 是被遮盖的图像 (μ_y = I_m)\n与高斯噪声 (ε) 的组合。对于任意状态 (t )，扩散过程 ({y_t}_{t=0}^{T})\n通过均值回复随机微分方程 (SDE) [26] 定义为： [ dy = θ_t(μ_y − y)dt +\nη_tdW， ] 其中 (θ_t) 和 (η_t)\n是时间相关的正参数，分别表征扩散过程中的均值回复速度和随机波动性。由于\n(λ) 被固定为应用于 (y_T) 的噪声水平，因此 (η_t^2/θ_t = 2λ^2)\n是用于描述平稳方差的约束。特别地，(θ_t)\n可以被调整以构造不同的纹理噪声计划；(w) 是标准的Wiener过程\n[25]（即布朗运动），它为微分方程引入了随机性。</p>\n<p><strong>反向纹理去噪过程：</strong> 为了从终端纹理状态 (y_T)\n恢复出完整图像\n(y_0)，我们通过在时间上反向模拟SDE来逆转扩散过程，其公式为： [ dy =\n[θ_t(μ_y − y) − η_t^2∇_y q_t(y)]dt + η_tdW， ] 其中 (wˆ)\n是反向时间的Wiener过程，(q_t(y)) 表示在时间t时的纹理 (y_t)\n的边际概率密度函数。分数函数 (_y p_t(y))\n是未知的，可以通过训练一个条件时间相关神经网络 (ϵϕ(y_t, t)) [12]\n来近似。或者，我们可以通过最大似然学习，从(t-1) 时间步中的 (y_t)\n中找到最优的反向纹理状态\n(y_t^{*−1})，这可以通过最小化负对数似然实现：</p>\n<h3 id=\"ddim\">DDIM</h3>\n<p>是的，DDIM（Denoising Diffusion Implicit\nModels）是一种基于扩散模型（Diffusion\nModels）的生成模型，与DDPM（Denoising Diffusion Probabilistic\nModels）类似，但具有一些显著的不同之处。</p>\n<p>主要特点：</p>\n<ol type=\"1\">\n<li><p><strong>确定性生成过程</strong>：与DDPM不同，DDIM不需要随机采样过程中的每个时间步，而是采用确定性的迭代方法来生成样本。它通过直接从扩散过程中的中间状态生成样本，而不是逐步去噪。这个过程显著减少了生成样本的步骤数量。</p></li>\n<li><p><strong>更高效的采样</strong>：由于DDIM不依赖于随机性，因此可以通过较少的时间步数生成高质量的样本。这使得它在生成图像等任务时更加高效。</p></li>\n<li><p><strong>与DDPM的兼容性</strong>：DDIM与DDPM共享相同的训练过程，因此可以从已经使用DDPM训练过的模型中推断出DDIM的生成过程。</p></li>\n<li><p><strong>生成质量</strong>：由于采样过程的确定性，DDIM能够生成质量较高且更加一致的图像。这使得它在某些应用场景中比DDPM表现更好。</p></li>\n</ol>\n<p>工作原理：</p>\n<p>DDIM的生成过程基于一个确定性的反向过程，通过解决特定的偏微分方程来生成目标样本。它可以被视为DDPM的一个改进版本，通过简化和优化去噪过程来提高生成效率和质量。</p>\n<p>应用：</p>\n<p>DDIM被广泛应用于图像生成、图像修复（如你提到的图像填充）、以及其他需要高质量生成样本的任务中。</p>\n<p>DDPM是一个马尔科夫的过程，而DDIM是通过去马尔科夫化，但是又和DDPM有一个同样的训练目标，也就是说如果你已经有一个训练好的DDPM模型了，你就可以通过DDIM的这种采样方式来加速已经训练好的DDPM的采样，所以说DDIM更像是提出了一个新的采样方式，因为他的训练过程跟DDPM是一样的，只不过DDIM改进了采样过程。但是DDIM的这种采样方式也有一些缺点，虽然加快了模型的推理速度，但是由于DDIM的整个生成过程是确定性的（deterministic）过程，这就导致了DDIM的多样性相比于DDPM比较差（鱼和熊掌不可兼得）</p>\n<p><strong>Denoising Diffusion Implicit Models (DDIM)</strong>\n是扩散模型的一种变体，通过优化采样过程，使得生成图像更加高效和高质量。DDIM\n是对 <strong>Denoising Diffusion Probabilistic Models (DDPM)</strong>\n的改进，解决了DDPM采样过程中的一些局限性。</p>\n<p>核心思想</p>\n<p>DDIM通过构建一个确定性（implicit）的采样过程，减少生成样本的时间步数。与DDPM的随机采样不同，DDIM提供了一种确定性的、可控的方式来从噪声中生成数据。其基本思想是通过一种新的反向过程，在减少时间步数的同时保持生成样本的质量。</p>\n<p>工作原理</p>\n<p>DDIM的核心在于它重新定义了从噪声到数据的反向过程，而不是像DDPM那样逐步减少噪声。DDIM的反向过程基于以下两个关键点：</p>\n<ol type=\"1\">\n<li><strong>确定性反向过程</strong>：\n<ul>\n<li>DDIM采用了一个确定性的反向过程，这意味着在生成过程中，每一步都是由确定的公式计算得出的，而不是通过随机采样。这样，生成过程更加稳定，并且可以使用较少的时间步数生成样本。</li>\n</ul></li>\n<li><strong>修改后的去噪过程</strong>：\n<ul>\n<li>DDIM通过引入一个新参数\n()，允许用户在从噪声中生成数据时对步长进行控制。这个参数可以调节生成图像的多样性和质量之间的权衡。</li>\n</ul></li>\n<li><strong>与DDPM的兼容性</strong>：\n<ul>\n<li>DDIM的训练过程与DDPM完全相同，可以使用现有的DDPM模型进行推断。DDIM的生成过程是通过对DDPM的Markov链进行改进得出的，因此它在速度和样本质量上都表现得更好。</li>\n</ul></li>\n</ol>\n<p>公式表示</p>\n<p>DDIM的核心公式为： - Forward process (正向过程)： <span\nclass=\"math inline\">\\(q(x_t \\mid x_{t-1}) = \\mathcal{N}(x_t;\n\\sqrt{\\alpha_t} x_{t-1}, (1 - \\alpha_t) I)\\)</span> 这里的 (<span\nclass=\"math inline\">\\(\\alpha_t\\)</span>) 是时间步t的缩放因子。</p>\n<ul>\n<li>Reverse process (反向过程)： <span\nclass=\"math inline\">\\(p_{\\theta}(x_{t-1} \\mid x_t) =\n\\mathcal{N}(x_{t-1}; \\mu_{\\theta}(x_t, t), \\sigma_{\\theta}(t)\nI)\\)</span> DDIM通过一个线性插值公式在 (<span\nclass=\"math inline\">\\(\\mu\\)</span>) 和 (<span\nclass=\"math inline\">\\(\\sigma\\)</span>)\n之间引入确定性因素，从而可以确定地计算每一步的结果。</li>\n</ul>\n<p>优势</p>\n<ul>\n<li><strong>采样速度更快</strong>：相比于DDPM，DDIM可以在更少的时间步内生成样本。</li>\n<li><strong>生成质量高</strong>：由于确定性采样，DDIM的生成图像更加一致和精细。</li>\n<li><strong>灵活性强</strong>：通过调整参数，DDIM可以在图像多样性和保真度之间进行灵活的权衡。</li>\n</ul>\n<p>应用场景</p>\n<p>DDIM已经在多个图像生成和修复任务中展现了其潜力，如图像去噪、图像填充、图像超分辨率等，成为了扩散模型中的一个重要工具。</p>\n<p>DDIM展示了如何通过优化扩散过程的反向步骤来提高生成模型的效率和效果，这是对现有扩散模型的一个重要改进。</p>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2024/05/05/%E9%9F%B3%E8%A7%86%E9%A2%91/",
            "url": "https://chnhqz.github.io/2024/05/05/%E9%9F%B3%E8%A7%86%E9%A2%91/",
            "title": "音视频",
            "date_published": "2024-05-05T05:07:50.000Z",
            "content_html": "<p><img loading=\"lazy\" data-src=\"截屏2024-05-05 23.17.47.png\" alt=\"截屏2024-05-05 23.17.47\" style=\"zoom:50%;\" /></p>\n<h4 id=\"将mp4转化为flv格式\">将MP4转化为FLV格式</h4>\n<ul>\n<li><p><code>avformat_alloc_output_context2()</code> 和\n<code>avformat_free_context()</code> 是 FFmpeg\n中用于操作输出格式上下文（output format context）的函数。</p>\n<ul>\n<li><code>avformat_alloc_output_context2()</code>\n用于分配并初始化一个输出格式上下文。</li>\n<li><code>avformat_free_context()</code>\n用于释放一个输出格式上下文及其相关资源。</li>\n</ul></li>\n<li><p><code>avformat_new_stream()</code>\n用于创建新的流（stream）。这个函数允许你在一个封装器（如\nAVFormatContext）中添加一个新的音频或视频流。</p></li>\n<li><p><code>avcodec_parameters_copy()</code>\n是一个函数，用于复制编解码器参数（codec\nparameters）。它可以将源编解码器参数复制到目标编解码器参数，确保目标参数与源参数具有相同的属性和配置。</p></li>\n<li><p><code>avformat_write_header()</code>\n是一个函数，用于向输出容器（output container）写入容器头（container\nheader）。在使用 FFmpeg\n编码或封装媒体文件时，通常需要在写入数据流之前调用此函数。</p></li>\n<li><p><code>av_write_frame()</code> 和\n<code>av_interleaved_write_frame()</code>\n是用于将音视频帧写入输出文件的函数。</p>\n<ul>\n<li><code>av_write_frame()</code>\n用于将音视频帧写入输出文件，但不进行交错写入（interleaved\nwriting）。</li>\n<li><code>av_interleaved_write_frame()</code>\n则是进行交错写入的版本，确保音频和视频帧以交错的方式写入输出文件，以便播放器能够按照正确的顺序解码和播放。</li>\n</ul></li>\n<li><p><code>av_write_trailer()</code>\n是一个函数，用于写入封装器（muxer）的尾部（trailer），完成媒体文件的封装过程。在使用\nFFmpeg\n编码或封装媒体文件时，通常需要在写入所有数据流并关闭文件之前调用此函数。</p></li>\n</ul>\n<blockquote>\n<p>错误记录：</p>\n<p><code>error C2065: “INTMAX_MAX”: 未声明的标识符 (编译源文件 src\\main.cpp)</code></p>\n<p>打开项目属性-&gt; C/C++ -&gt; 预处理器-&gt; 预处理器定义</p>\n<p>添加： **__STDC_LIMIT_MACROS**</p>\n<p>遇到\n<code>不能将 const AVOutputformat * 类型的值分配到 AVOutputformat * 类型的实体</code>\n错误</p>\n<p>这个错误可能是因为试图将一个 <code>const AVOutputFormat</code>\n类型的值分配给一个 <code>AVOutputFormat</code>\n类型的变量，而这两个类型不完全相同。</p>\n<p>通常情况下，可以通过使用类型转换来解决这个问题。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> AVOutputFormat *const_format_ptr = ...; <span class=\"comment\">// 指向常量 AVOutputFormat 的指针</span></span><br><span class=\"line\">AVOutputFormat *format_ptr = (AVOutputFormat *)const_format_ptr; <span class=\"comment\">// 转换为普通 AVOutputFormat 指针</span></span><br></pre></td></tr></table></figure>\n<p>但是，确保应用程序逻辑和安全性不受影响，因为在将常量指针转换为非常量指针时可能会引入潜在的错误。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">log_packet</span><span class=\"params\">(<span class=\"type\">const</span> AVFormatContext* fmt_ctx, <span class=\"type\">const</span> AVPacket* pkt, <span class=\"type\">const</span> <span class=\"type\">char</span>* tag)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tAVRational* time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mp42flv</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tAVOutputFormat* ofmt = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tAVFormatContext* ifmt_ctx = <span class=\"literal\">NULL</span>, * ofmt_ctx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tAVPacket pkt;</span><br><span class=\"line\">\t<span class=\"type\">char</span> src[] = <span class=\"string\">&quot;input.mp4&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> dst[] = <span class=\"string\">&quot;output.flv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret, i;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stream_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> *stream_mapping = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stream_mapping_size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((ret = <span class=\"built_in\">avformat_open_input</span>(&amp;ifmt_ctx, src, <span class=\"number\">0</span>, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 打开输入的多媒体文件，生成多媒体上下文</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Could not open input file &#x27;%s&#x27;.\\n&quot;</span>, src);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((ret = <span class=\"built_in\">avformat_find_stream_info</span>(ifmt_ctx, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Failed to retrieve input stream information.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">av_dump_format</span>(ifmt_ctx, <span class=\"number\">0</span>, src, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">avformat_alloc_output_context2</span>(&amp;ofmt_ctx, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, dst);\t<span class=\"comment\">// 输出的上下文</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ofmt_ctx) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Could not create output context.\\n&quot;</span>);</span><br><span class=\"line\">\t\tret = AVERROR_UNKNOWN;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstream_mapping_size = ifmt_ctx-&gt;nb_streams;</span><br><span class=\"line\">\tstream_mapping = (<span class=\"type\">int</span>*)<span class=\"built_in\">av_malloc_array</span>(stream_mapping_size, <span class=\"built_in\">sizeof</span>(*stream_mapping));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!stream_mapping) &#123;</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">AVERROR</span>(ENOMEM);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;-1.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tofmt = (AVOutputFormat*)ofmt_ctx-&gt;oformat;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class=\"line\">\t\tAVStream* out_stream;</span><br><span class=\"line\">\t\tAVStream* in_stream = ifmt_ctx-&gt;streams[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tAVCodecParameters* in_codecpar = in_stream-&gt;codecpar;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (in_codecpar-&gt;codec_type != AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class=\"line\">\t\t\tin_codecpar-&gt;codec_type != AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class=\"line\">\t\t\tin_codecpar-&gt;codec_type != AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class=\"line\">\t\t\tstream_mapping[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tstream_mapping[i] = stream_index++;</span><br><span class=\"line\">\t\tout_stream = <span class=\"built_in\">avformat_new_stream</span>(ofmt_ctx, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!out_stream) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Failed allocating output stream.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\tret = AVERROR_UNKNOWN;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tret = <span class=\"built_in\">avcodec_parameters_copy</span>(out_stream-&gt;codecpar, in_codecpar);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Failed to copy codec parameters.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tout_stream-&gt;codecpar-&gt;codec_tag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"built_in\">av_dump_format</span>(ofmt_ctx, <span class=\"number\">0</span>, dst, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">avio_open</span>(&amp;ofmt_ctx-&gt;pb, dst, AVIO_FLAG_WRITE);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Could not open file &#x27;%s&#x27;.\\n&quot;</span>, dst);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = <span class=\"built_in\">avformat_write_header</span>(ofmt_ctx, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Error occurred when opening output file.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tAVStream* in_stream, * out_stream;</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">av_read_frame</span>(ifmt_ctx, &amp;pkt);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tin_stream = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pkt.stream_index &gt;= stream_mapping_size || stream_mapping[pkt.stream_index] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">av_packet_unref</span>(&amp;pkt);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpkt.stream_index = stream_mapping[pkt.stream_index];</span><br><span class=\"line\">\t\tout_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class=\"line\">\t\t<span class=\"built_in\">log_packet</span>(ifmt_ctx, &amp;pkt, <span class=\"string\">&quot;in&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* copy packet*/</span></span><br><span class=\"line\">\t\tpkt.pts = <span class=\"built_in\">av_rescale_q_rnd</span>(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base,</span><br><span class=\"line\">\t\t\tAV_ROUND_PASS_MINMAX);</span><br><span class=\"line\">\t\tpkt.dts = <span class=\"built_in\">av_rescale_q_rnd</span>(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base,</span><br><span class=\"line\">\t\t\tAV_ROUND_PASS_MINMAX);</span><br><span class=\"line\">\t\tpkt.duration = <span class=\"built_in\">av_rescale_q</span>(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class=\"line\">\t\tpkt.pos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">log_packet</span>(ofmt_ctx, &amp;pkt, <span class=\"string\">&quot;out&quot;</span>);</span><br><span class=\"line\">\t\tret = <span class=\"built_in\">av_interleaved_write_frame</span>(ofmt_ctx, &amp;pkt);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;Error muxing packet.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">av_packet_unref</span>(&amp;pkt);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">av_write_trailer</span>(ofmt_ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">end:</span><br><span class=\"line\">\t<span class=\"built_in\">avformat_close_input</span>(&amp;ifmt_ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">avio_closep</span>(&amp;ofmt_ctx-&gt;pb);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">avformat_free_context</span>(ofmt_ctx);</span><br><span class=\"line\">\t<span class=\"built_in\">av_freep</span>(&amp;stream_mapping);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"ffmpeg文件与目录操作\">FFmpeg文件与目录操作</h4>\n<p>文件的删除与重命名</p>\n<ul>\n<li><code>avpriv_io_delete()</code> 是 FFmpeg\n中的一个私有函数，用于删除指定的文件或目录。它可以删除本地文件系统上的文件或目录，并提供了一些选项来控制删除操作的行为。由于\n<code>avpriv_io_delete()</code> 是一个私有函数，它并不是 FFmpeg 公共 API\n的一部分，因此在正式的应用程序中使用它可能会有一些风险，因为它的行为和接口可能随时发生变化。通常情况下，您应该尽量避免使用私有函数，而是使用\nFFmpeg 提供的公共 API。</li>\n<li><code>avpriv_io_move()</code> 是 FFmpeg\n中的一个私有函数，用于移动文件或目录。它可以将文件或目录从一个位置移动到另一个位置，并提供了一些选项来控制移动操作的行为。</li>\n</ul>\n<h4 id=\"实现一个简单的小咖秀\">实现一个简单的小咖秀</h4>\n<p>实现步骤：</p>\n<ol type=\"1\">\n<li>从两个媒体文件中分别抽取音频与视频轨</li>\n<li>将音频与视频轨合并成一个新文件</li>\n<li>对音频与视频轨进行裁剪</li>\n</ol>\n<h4 id=\"libavcodecavcodec.h\">libavcodec/avcodec.h</h4>\n<ul>\n<li><p><code>AVCodec</code> 编码器结构体</p></li>\n<li><p><code>AVCodecContext</code> 编码器上下文</p></li>\n<li><p><code>AVFrame</code> 解码后的帧</p></li>\n<li><p><code>av_frame_alloc()</code> 和 <code>av_frame_free()</code> 是\nFFmpeg 中用于操作帧（frame）的函数。</p>\n<ul>\n<li><p><code>av_frame_alloc()</code>\n用于分配一个新的帧，并返回一个指向该帧的指针。您可以使用此函数来创建一个空的帧，然后填充数据。</p></li>\n<li><p><code>av_frame_free()</code>\n用于释放先前分配的帧。当您完成对帧的使用后，应该调用此函数来释放相关的内存，并避免内存泄漏。</p></li>\n</ul>\n<p>这两个函数通常在编解码过程中用于分配和释放帧内存。</p></li>\n<li><p><code>avcodec_alloc_context3()</code>\n分配一个<code>AVCodecContext</code>结构体的实例，用于存储编解码器的参数和状态。</p></li>\n<li><p><code>avcodec_free_context()</code> 释放上下文</p></li>\n</ul>\n<p><strong>解码步骤</strong></p>\n<ol type=\"1\">\n<li>查找解码器 <code>avcodec_find_decoder</code></li>\n<li>打开解码器 <code>avcodec_open2</code></li>\n<li>解码 <code>avcodec_decode_video2</code></li>\n</ol>\n<p><strong>编码步骤</strong></p>\n<ol type=\"1\">\n<li>查找编码器\n<code>avcodec_find_encoder_by_name/avcodec_find_encoder</code> 在 FFmpeg\n中，<code>avcodec_find_encoder_by_name()</code> 和\n<code>avcodec_find_encoder()</code> 都是用于查找编码器的函数。\n<ul>\n<li><p><code>avcodec_find_encoder_by_name()</code>\n根据编码器的名称查找编码器。您需要传递编码器的名称作为参数，函数将返回一个指向\n<code>AVCodec</code> 结构体的指针，该结构体包含了编码器的信息。</p></li>\n<li><p><code>avcodec_find_encoder()</code> 则是根据编码器的\nID（编码器的枚举值）来查找编码器。您需要传递编码器的 ID\n作为参数，函数将返回一个指向 <code>AVCodec</code>\n结构体的指针，该结构体包含了编码器的信息。</p></li>\n</ul></li>\n<li>设置编码参数（分辨率、帧率、...），并打开编码器\n<code>avcodec_open2</code></li>\n<li>编码 <code>avcodec_encode_video2</code></li>\n</ol>\n<p><strong>注意：音频，视频的编解码大概类似，大体都分为三步：找到编解码器、（设置参数）打开编解码器、进行编解码。</strong></p>\n<h4 id=\"从mp4截取一段视频\">从MP4截取一段视频</h4>\n<ul>\n<li><p><code>av_seek_frame</code>\n函数用于在媒体文件中定位到指定的帧。</p>\n<p>参数解释：</p>\n<ul>\n<li><code>AVFormatContext *s</code>：表示输入或输出媒体文件的格式上下文。</li>\n<li><code>int stream_index</code>：表示要寻找的媒体流的索引。</li>\n<li><code>int64_t timestamp</code>：表示要寻找的时间戳，以媒体流的基本时间单位为单位（通常是微秒）。</li>\n<li><code>int flags</code>：表示定位的标志位，可以是\n<code>AVSEEK_FLAG_BACKWARD</code>（向后定位）、<code>AVSEEK_FLAG_BYTE</code>（以字节为单位定位）等。</li>\n</ul>\n<p>该函数将在媒体文件中定位到距离给定时间戳最近的关键帧，并更新\n<code>AVFormatContext</code> 中的信息以反映新的位置。</p></li>\n</ul>\n<blockquote>\n<p>avformat_new_stream 的用法：</p>\n<p>AVStream 即是流通道。例如我们将 H264 和 AAC\n码流存储为MP4文件的时候，就需要在\nMP4文件中增加两个流通道，一个存储Video：H264，一个存储Audio：AAC。（假设H264和AAC只包含单个流通道）。</p>\n<p>AVStream包含很多参数，用于记录通道信息，其中最重要的是 :</p>\n<p>AVCodecParameters * codecpar\n：用于记录编码后的流信息，即通道中存储的流的编码信息。</p>\n<p>AVRational time_base\n：AVStream通道的时间基，时间基是个相当重要的概念。（可参考之后的关于ffmpeg时间的文章）</p>\n<p>需要注意的是：现在的 ffmpeg 3.1.4版本已经使用AVCodecParameters *\ncodecpar替换了原先的CodecContext* codec !</p>\n<p>avformat_new_stream 在 AVFormatContext中创建 Stream 通道</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AVFormatContext:</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> nb_streams; <span class=\"comment\">// 记录stream通道数目</span></span><br><span class=\"line\">AVStream **streams;      <span class=\"comment\">// 存储stream通道</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AVStream</span></span><br><span class=\"line\"><span class=\"type\">int</span> index;\t\t\t\t\t\t\t<span class=\"comment\">// 在AVFormatContext 中所处的通道索引</span></span><br></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/音视频/截屏2024-05-07%2016.22.19.png\"\nalt=\"截屏2024-05-07 16.22.19\" />\n<figcaption aria-hidden=\"true\">截屏2024-05-07 16.22.19</figcaption>\n</figure>\n<p><code>avformat_new_stream</code>之后便在<code>AVFormatContext</code>里增加了<code>AVStream</code>增加了<code>AVStream</code>通道（相关的<code>index</code>已经被设置了）。之后我们就可以自行设置<code>AVStream</code>的一些信息。例如\n<code>codec_id,format,bit_rate,width,heoght.....</code></p>\n<p>avformat_new_stream(AVFormatContext * s, const AVCodec * c)</p>\n<p>AVCodec ：s需要通信的视频对应的编码方式。\n在已知codec_id的情况下可以通过\ncodec=avcodec_find_decoder(codec_id)；的方式得到。</p>\n<p>原文：https://blog.csdn.net/u014162133/article/details/82258488</p>\n<p>https://blog.csdn.net/Kami_Jiang/article/details/106784580</p>\n</blockquote>\n<h4 id=\"sdl事件基本原理\">SDL事件基本原理</h4>\n<ol type=\"1\">\n<li>SDL将所有事件都存放在一个队列中</li>\n<li>所有对事件的操作，其实就是对队列的操作</li>\n</ol>\n<p><strong>SDL事件种类</strong></p>\n<ol type=\"1\">\n<li><code>SDL_WindowEvent</code>：窗口事件</li>\n<li><code>SDL_KeyboardEvent</code> ：键盘事件</li>\n<li><code>SDL_MouseMotionEvent</code> ：鼠标事件</li>\n<li>自定义事件</li>\n</ol>\n<p><code>SDL_PollEvent</code> DL\n库中的一个函数，用于检查是否有任何事件发生。它会检查事件队列，并返回队列中的下一个事件（如果有）。轮询操作，要等待一段时间。如果不等待时间，CPU过载</p>\n<p><code>SDL_WaitEvent</code>\n事件触发机制，用于等待事件的发生。如果当前事件队列为空，则该函数将会一直等待，直到有事件发生。</p>\n<p><strong>纹理渲染</strong></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/音视频/截屏2024-05-08%2014.22.58.png\"\nalt=\"截屏2024-05-08 14.22.58\" />\n<figcaption aria-hidden=\"true\">截屏2024-05-08 14.22.58</figcaption>\n</figure>\n<ul>\n<li><code>SDL_CreateTexture()</code>\n<ul>\n<li><code>format:YUV,RGB</code></li>\n<li><code>access:Texture类型,Target,Stream</code></li>\n</ul></li>\n<li><code>SDL_DestroyTexture()</code></li>\n<li><code>SDL_SetRenderTarget()</code>用于设置渲染目标，即指定在哪个渲染器上进行绘制。你可以将渲染目标设置为一个纹理或者窗口。</li>\n<li><code>SDL_RenderClear()</code>用于清除当前渲染目标上的所有内容，将其填充为指定的颜色。</li>\n<li><code>SDL_RenderCopy()</code>用于将纹理复制到当前渲染目标上。</li>\n<li><code>SDL_RenderPresent</code>用于更新窗口显示，将之前所有的渲染操作绘制到窗口上。</li>\n</ul>\n<h4 id=\"yuv播放器\">YUV播放器</h4>\n<p><strong>创建线程</strong></p>\n<ul>\n<li><code>SDL_CreateThread()</code>函数用于创建一个新的线程。它接受两个参数：一个指向函数的指针，这个函数将作为新线程的入口点；以及一个可选的参数，将传递给新线程的入口函数。函数返回一个指向新线程的\n<code>SDL_Thread</code> 结构体的指针。\n<ul>\n<li><code>fn</code> 线程执行函数</li>\n<li><code>name</code> 线程名</li>\n<li><code>data</code> 执行函数参数</li>\n</ul></li>\n</ul>\n<p><strong>更新纹理</strong></p>\n<ul>\n<li><code>SDL_UpdateTexture()</code>\n函数用于更新纹理的像素数据。它接受纹理、矩形区域和像素数据作为参数，以更新纹理的一部分或全部像素。</li>\n<li><code>SDL_UpdateYUVTexture</code>\n函数用于更新YUV格式的纹理像素数据。它接受纹理、矩形区域、Y、U和V平面的像素数据作为参数，以更新纹理的一部分或全部像素。</li>\n</ul>\n<h4 id=\"sdl音频api\">SDL音频API</h4>\n<ul>\n<li><code>SDL_OpenAudio/SDL_CloseAudio</code>\n<code>SDL_OpenAudio()</code>函数用于初始化音频子系统，并打开音频设备以进行音频播放或录制。而<code>SDL_CloseAudio()</code>函数用于关闭音频设备并释放音频子系统的资源。</li>\n<li><code>SDL_PauseAudio</code> <code>SDL_PauseAudio</code>\n用于暂停或继续音频回放。</li>\n<li><code>SDL_MixAudio</code> 用于将音频数据混合到音频缓冲区中。</li>\n</ul>\n<h4 id=\"pcm-音频播放器\">PCM 音频播放器</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SDL_MAIN_HANDLED</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;SDL2/SDL.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BLOCK_SIZE 4096000</span></span><br><span class=\"line\"><span class=\"type\">static</span> Uint8* audio_buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">size_t</span> buffer_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> Uint8* audio_pos = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">read_audio_data</span><span class=\"params\">(<span class=\"type\">void</span>* udata, Uint8* stream, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (buffer_len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SDL_memset</span>(stream, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">\tlen = (len &lt; buffer_len) ? len : buffer_len;</span><br><span class=\"line\">\t<span class=\"built_in\">SDL_MixAudio</span>(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span><br><span class=\"line\"></span><br><span class=\"line\">\taudio_pos += len;</span><br><span class=\"line\">\tbuffer_len -= len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PCM_play</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pcm_player</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// SDL 初始化</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> path[] = <span class=\"string\">&quot;NULL&quot;</span>;</span><br><span class=\"line\">\t\tFILE* audio_fd = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">SDL_Init</span>(SDL_INIT_AUDIO)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_Log</span>(<span class=\"string\">&quot;Failed to initial.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\taudio_fd = <span class=\"built_in\">fopen</span>(path, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!audio_fd) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_Log</span>(<span class=\"string\">&quot;Failed to open pcm file!\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 分配内存空间</span></span><br><span class=\"line\">\t\taudio_buf = (Uint8*)<span class=\"built_in\">malloc</span>(BLOCK_SIZE);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!audio_buf) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_Log</span>(<span class=\"string\">&quot;Failed to alloc memory!\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// spec 音频参数 采样率</span></span><br><span class=\"line\">\t\tSDL_AudioSpec spec;</span><br><span class=\"line\">\t\tspec.freq = <span class=\"number\">44100</span>;</span><br><span class=\"line\">\t\tspec.channels = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tspec.format = AUDIO_S16SYS;</span><br><span class=\"line\">\t\tspec.silence = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tspec.callback = read_audio_data;</span><br><span class=\"line\">\t\tspec.userdata = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">SDL_OpenAudio</span>(&amp;spec, <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_Log</span>(<span class=\"string\">&quot;Failed to open audio device!\\n&quot;</span>);\\</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_PauseAudio</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tbuffer_len = <span class=\"built_in\">fread</span>(audio_buf, <span class=\"number\">1</span>, BLOCK_SIZE, audio_fd);</span><br><span class=\"line\">\t\t\taudio_pos = audio_buf;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (audio_pos &lt; (audio_buf + buffer_len)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">SDL_Delay</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (buffer_len != <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_CloseAudio</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__FAIL:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (audio_buf) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(audio_buf);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (audio_fd) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">fclose</span>(audio_fd);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_Quit</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"简单视频播放器\">简单视频播放器</h4>\n<p>利用<code>FFmpeg</code>\n将<code>h264</code>等数据解码成<code>YUV</code>数据，通过<code>SDL</code>渲染。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sws_ctx = <span class=\"built_in\">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class=\"line\">\tpCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class=\"line\">\tAV_PIX_FMT_YUV420P, SWS_BILINEAR,</span><br><span class=\"line\">\t<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这段代码使用了 libswscale 库中的 <code>sws_getContext</code>\n函数来创建一个图像转换上下文（sws_ctx）。这个上下文用于将一个像素格式的图像转换成另一种像素格式的图像，以便在播放或处理视频时进行必要的格式转换。</p>\n<p>具体来说，这段代码的作用是将视频帧从输入编解码器上下文（pCodecCtx）的像素格式（pCodecCtx-&gt;pix_fmt）转换为\nYUV420P 格式。在大多数情况下，YUV420P\n是视频处理中常用的一种格式，因为它包含了亮度（Y）和色度（U、V）信息，而且是压缩视频格式的一种常见格式。</p>\n<p>下面是这段代码的参数解释： - <code>pCodecCtx-&gt;width</code> 和\n<code>pCodecCtx-&gt;height</code>: 输入视频帧的宽度和高度。 -\n<code>pCodecCtx-&gt;pix_fmt</code>: 输入视频帧的像素格式。 -\n<code>pCodecCtx-&gt;width</code> 和 <code>pCodecCtx-&gt;height</code>:\n输出视频帧的宽度和高度，通常与输入视频帧的尺寸相同。 -\n<code>AV_PIX_FMT_YUV420P</code>: 输出视频帧的像素格式，这里选择了\nYUV420P 格式。 - <code>SWS_BILINEAR</code>:\n像素转换的算法，这里选择了双线性插值算法，用于平滑图像。</p>\n<p>最后三个参数是用于设置特殊选项的，通常情况下可以设为 NULL。</p>\n<p>总之，这段代码的目的是创建一个图像转换上下文，以便在播放视频时将输入的像素格式转换为\nYUV420P 格式，以便后续处理或显示。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pict = (AVPicture*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(AVPicture));</span><br><span class=\"line\"><span class=\"built_in\">avpicture_alloc</span>(pict, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这段代码分配了一个大小合适的内存块来存储 YUV420P\n格式的图像数据，并使用 <code>avpicture_alloc</code> 函数来初始化\n<code>pict</code> 指针所指向的内存块，使其可以存储 YUV420P\n格式的图像数据。</p>\n<p>具体来说，<code>avpicture_alloc</code>\n函数会根据指定的像素格式（AV_PIX_FMT_YUV420P）、宽度（pCodecCtx-&gt;width）和高度（pCodecCtx-&gt;height），为\n<code>pict</code>\n指向的内存块分配足够的空间，并根据像素格式的要求对内存块进行初始化，以便后续存储\nYUV420P 格式的图像数据。</p>\n<p>这段代码的目的是为后续的视频解码和处理准备一个用于存储图像数据的缓冲区，以便于在播放或处理视频时使用。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sws_scale</span>(sws_ctx, (<span class=\"type\">uint8_t</span> <span class=\"type\">const</span>* <span class=\"type\">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class=\"number\">0</span>, pCodecCtx-&gt;height, pict-&gt;data, pict-&gt;linesize);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这段代码使用 <code>sws_scale</code> 函数将解码后的视频帧数据转换为\nYUV420P 格式，并将结果存储在 <code>pict</code> 所指向的内存块中。</p>\n<p>具体来说，<code>sws_scale</code>\n函数会将输入的视频帧数据（<code>pFrame-&gt;data</code>）按照指定的转换参数（<code>sws_ctx</code>）进行转换，转换后的数据存储在输出缓冲区（<code>pict-&gt;data</code>）中。参数\n<code>pFrame-&gt;linesize</code> 表示输入数据每行的字节数，而\n<code>pict-&gt;linesize</code>\n表示输出数据每行的字节数。函数还会根据输入和输出的图像大小进行缩放和裁剪操作，以确保输出数据的正确性和一致性。</p>\n<p>这段代码的作用是将解码后的视频帧数据转换为 YUV420P\n格式，并存储在指定的内存块中，以便后续的视频处理和显示。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">player</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> filepath[] = <span class=\"string\">&quot;input.mp4&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 多媒体文件上下文</span></span><br><span class=\"line\">\tAVFormatContext* pFormatCtx = <span class=\"literal\">NULL</span>;\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, videoStream;</span><br><span class=\"line\">\t<span class=\"comment\">// 编解码上下文</span></span><br><span class=\"line\">\tAVCodecContext* pCodecCtxOrig = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tAVCodecContext* pCodecCtx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 图像裁剪上下文</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">SwsContext</span>* sws_ctx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 编解码器</span></span><br><span class=\"line\">\tAVCodec* pCodec = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 解码后的数据帧</span></span><br><span class=\"line\">\tAVFrame* pFrame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 解码前的数据包</span></span><br><span class=\"line\">\tAVPacket packet;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> frameFinished;</span><br><span class=\"line\">\t<span class=\"type\">float</span> aspect_ratio;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 解码出来的YUV数据存放在</span></span><br><span class=\"line\">\tAVPicture* pict = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tSDL_Rect rect;</span><br><span class=\"line\">\tUint32 pixformat;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// render</span></span><br><span class=\"line\">\tSDL_Window* win = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tSDL_Renderer* renderer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tSDL_Texture* texture = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置默认的窗口大小</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> w_width = <span class=\"number\">640</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> w_height = <span class=\"number\">480</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">SDL_Init</span>(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Could not initialize SDL - %s.\\n&quot;</span>, <span class=\"built_in\">SDL_GetError</span>());</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">av_register_all</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avformat_open_input</span>(&amp;pFormatCtx, filepath, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Could not open video file\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avformat_find_stream_info</span>(pFormatCtx, <span class=\"literal\">NULL</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to find stream information.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">av_dump_format</span>(pFormatCtx, <span class=\"number\">0</span>, filepath, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 找到第一个视频流</span></span><br><span class=\"line\">\tvideoStream = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class=\"line\">\t\t\tvideoStream = i;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;视频流编号：%d\\n&quot;</span>, i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (videoStream == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Din&#x27;t find a video stream.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 这行代码的目的是获取视频流的编解码上下文（`AVCodecContext`）。</span></span><br><span class=\"line\"><span class=\"comment\">\t`pFormatCtx` 是输入格式上下文，`streams[videoStream]` 表示视频流，</span></span><br><span class=\"line\"><span class=\"comment\">\t然后通过 `codec` 成员获取该流的编解码上下文。*/</span></span><br><span class=\"line\">\tpCodecCtxOrig = pFormatCtx-&gt;streams[videoStream]-&gt;codec;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 找到视频流的解码器</span></span><br><span class=\"line\">\tpCodec = <span class=\"built_in\">avcodec_find_decoder</span>(pCodecCtxOrig-&gt;codec_id);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pCodec == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Unsupported codec.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 复制 上下文 为了不破坏原来的流</span></span><br><span class=\"line\">\tpCodecCtx = <span class=\"built_in\">avcodec_alloc_context3</span>(pCodec);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avcodec_copy_context</span>(pCodecCtx, pCodecCtxOrig) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Couldn&#x27;t copy codec context.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打开解码器</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avcodec_open2</span>(pCodecCtx, pCodec, <span class=\"literal\">NULL</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to open decoder!\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 分配视频帧</span></span><br><span class=\"line\">\tpFrame = <span class=\"built_in\">av_frame_alloc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tw_width = pCodecCtx-&gt;width;</span><br><span class=\"line\">\tw_height = pCodecCtx-&gt;height;</span><br><span class=\"line\"></span><br><span class=\"line\">\twin = <span class=\"built_in\">SDL_CreateWindow</span>(<span class=\"string\">&quot;Media Player&quot;</span>,</span><br><span class=\"line\">\t\tSDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">\t\tSDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">\t\tw_width, w_height,</span><br><span class=\"line\">\t\tSDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!win) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to create window by SDL&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trenderer = <span class=\"built_in\">SDL_CreateRenderer</span>(win, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!renderer) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to create Renderer by SDL&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class=\"line\">\ttexture = <span class=\"built_in\">SDL_CreateTexture</span>(renderer, pixformat,</span><br><span class=\"line\">\t\tSDL_TEXTUREACCESS_STREAMING, w_width, w_height);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsws_ctx = <span class=\"built_in\">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class=\"line\">\t\tpCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class=\"line\">\t\tAV_PIX_FMT_YUV420P, SWS_BILINEAR,</span><br><span class=\"line\">\t\t<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpict = (AVPicture*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(AVPicture));</span><br><span class=\"line\">\t<span class=\"built_in\">avpicture_alloc</span>(pict, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">av_read_frame</span>(pFormatCtx, &amp;packet) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (packet.stream_index == videoStream) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 解码视频帧</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">avcodec_decode_video2</span>(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 得到解码后的视频帧</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (frameFinished) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将图片转化为 SDL 使用的 YUV 格式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sws_scale</span>(sws_ctx, (<span class=\"type\">uint8_t</span> <span class=\"type\">const</span>* <span class=\"type\">const</span>*)pFrame-&gt;data,</span><br><span class=\"line\">\t\t\t\t\tpFrame-&gt;linesize, <span class=\"number\">0</span>, pCodecCtx-&gt;height, pict-&gt;data, pict-&gt;linesize);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">SDL_UpdateYUVTexture</span>(texture, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t\t\t\t\tpict-&gt;data[<span class=\"number\">0</span>], pict-&gt;linesize[<span class=\"number\">0</span>],</span><br><span class=\"line\">\t\t\t\t\tpict-&gt;data[<span class=\"number\">1</span>], pict-&gt;linesize[<span class=\"number\">1</span>],</span><br><span class=\"line\">\t\t\t\t\tpict-&gt;data[<span class=\"number\">2</span>], pict-&gt;linesize[<span class=\"number\">2</span>]</span><br><span class=\"line\">\t\t\t\t\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\trect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\trect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\trect.w = pCodecCtx-&gt;width;</span><br><span class=\"line\">\t\t\t\trect.h = pCodecCtx-&gt;height;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">SDL_RenderClear</span>(renderer);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">SDL_RenderCopy</span>(renderer, texture, <span class=\"literal\">NULL</span>, &amp;rect);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">SDL_RenderPresent</span>(renderer);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">av_free_packet</span>(&amp;packet);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">__FAIL:</span><br><span class=\"line\">\t<span class=\"comment\">// Free the YUV frame</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pFrame) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">av_frame_free</span>(&amp;pFrame);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Close the codec</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pCodecCtx) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">avcodec_close</span>(pCodecCtx);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pCodecCtxOrig) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">avcodec_close</span>(pCodecCtxOrig);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Close the video file</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pFormatCtx) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">avformat_close_input</span>(&amp;pFormatCtx);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pict) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">avpicture_free</span>(pict);</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(pict);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (win) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_DestroyWindow</span>(win);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (renderer) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_DestroyRenderer</span>(renderer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (texture) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_DestroyTexture</span>(texture);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SDL_Quit</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用队列存放音频包-播放器\">使用队列存放音频包-播放器</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SDL_MAIN_HANDLED</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;SDL2/SDL.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libavutil/log.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libavcodec/version.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libavutil/mem.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BLOCK_SIZE 4096000</span></span><br><span class=\"line\"><span class=\"type\">static</span> Uint8* audio_buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">size_t</span> buffer_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> Uint8* audio_pos = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55, 28, 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> av_frame_alloc avcodec_alloc_frame</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> av_frame_free avcodec_free_frame</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_AUDIO_FRAME_SIZE 192000</span></span><br><span class=\"line\"><span class=\"type\">int</span> quit = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">SwrContext</span>* audio_convert_ctx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">PacketQueue</span> &#123;</span><br><span class=\"line\">\tAVPacketList* first_pkt, * last_pkt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> nb_packets;</span><br><span class=\"line\">\t<span class=\"type\">int</span> size;</span><br><span class=\"line\">\tSDL_mutex* mutex;</span><br><span class=\"line\">\tSDL_cond* cond;</span><br><span class=\"line\">&#125; PacketQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">PacketQueue audioq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">packet_queue_init</span><span class=\"params\">(PacketQueue* q)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(q, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(PacketQueue));</span><br><span class=\"line\">\tq-&gt;mutex = <span class=\"built_in\">SDL_CreateMutex</span>();</span><br><span class=\"line\">\tq-&gt;cond = <span class=\"built_in\">SDL_CreateCond</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">packet_queue_put</span><span class=\"params\">(PacketQueue* q, AVPacket* pkt)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAVPacketList* pkt1;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">av_dup_packet</span>(pkt) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpkt1 = (AVPacketList*)<span class=\"built_in\">av_malloc</span>(<span class=\"built_in\">sizeof</span>(AVPacketList));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!pkt1)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tpkt1-&gt;pkt = *pkt;</span><br><span class=\"line\">\tpkt1-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SDL_LockMutex</span>(q-&gt;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!q-&gt;last_pkt) &#123;</span><br><span class=\"line\">\t\tq-&gt;first_pkt = pkt1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tq-&gt;last_pkt-&gt;next = pkt1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tq-&gt;last_pkt = pkt1;</span><br><span class=\"line\">\tq-&gt;nb_packets++;</span><br><span class=\"line\">\tq-&gt;size += pkt1-&gt;pkt.size;</span><br><span class=\"line\">\t<span class=\"built_in\">SDL_CondSignal</span>(q-&gt;cond);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SDL_UnlockMutex</span>(q-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">packet_queue_get</span><span class=\"params\">(PacketQueue* q, AVPacket* pkt, <span class=\"type\">int</span> block)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tAVPacketList* pkt1;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SDL_LockMutex</span>(q-&gt;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (quit) &#123;</span><br><span class=\"line\">\t\t\tret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpkt1 = q-&gt;first_pkt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pkt1) &#123;</span><br><span class=\"line\">\t\t\tq-&gt;first_pkt = pkt1-&gt;next;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!q-&gt;first_pkt)</span><br><span class=\"line\">\t\t\t\tq-&gt;last_pkt = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\tq-&gt;nb_packets--;</span><br><span class=\"line\">\t\t\tq-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class=\"line\">\t\t\t*pkt = pkt1-&gt;pkt;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">av_free</span>(pkt1);</span><br><span class=\"line\">\t\t\tret = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!block) &#123;</span><br><span class=\"line\">\t\t\tret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_CondWait</span>(q-&gt;cond, q-&gt;mutex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">SDL_UnlockMutex</span>(q-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">audio_decode_frame</span><span class=\"params\">(AVCodecContext* aCodecCtx, <span class=\"type\">uint8_t</span>* audio_buf, <span class=\"type\">int</span> buf_size)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">static</span> AVPacket pkt;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span>* audio_pkt_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> audio_pkt_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">static</span> AVFrame frame;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> len1, data_size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (audio_pkt_size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> got_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tlen1 = <span class=\"built_in\">avcodec_decode_audio4</span>(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (len1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\taudio_pkt_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\taudio_pkt_data += len1;</span><br><span class=\"line\">\t\t\taudio_pkt_size -= len1;</span><br><span class=\"line\">\t\t\tdata_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (got_frame) &#123;</span><br><span class=\"line\">\t\t\t\tdata_size = <span class=\"number\">2</span> * <span class=\"number\">2</span> * frame.nb_samples;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">assert</span>(data_size &lt;= buf_size);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swr_convert</span>(audio_convert_ctx,</span><br><span class=\"line\">\t\t\t\t\t&amp;audio_buf,</span><br><span class=\"line\">\t\t\t\t\tMAX_AUDIO_FRAME_SIZE * <span class=\"number\">3</span> / <span class=\"number\">2</span>,</span><br><span class=\"line\">\t\t\t\t\t(<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>**)frame.data,</span><br><span class=\"line\">\t\t\t\t\tframe.nb_samples);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (data_size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> data_size;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pkt.data)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">av_free_packet</span>(&amp;pkt);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (quit) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">packet_queue_get</span>(&amp;audioq, &amp;pkt, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\taudio_pkt_data = pkt.data;</span><br><span class=\"line\">\t\taudio_pkt_size = pkt.size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">audio_callback</span><span class=\"params\">(<span class=\"type\">void</span>* userdata, Uint8* stream, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAVCodecContext* aCodecCtx = (AVCodecContext*)userdata;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len1, audio_size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class=\"number\">3</span>) / <span class=\"number\">2</span>];</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> audio_buf_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> audio_buf_index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (audio_buf_index &gt;= audio_buf_size) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* We have already sent all our data; get more*/</span></span><br><span class=\"line\">\t\t\taudio_size = <span class=\"built_in\">audio_decode_frame</span>(aCodecCtx, audio_buf, <span class=\"built_in\">sizeof</span>(audio_buf));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (audio_size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\taudio_buf_size = <span class=\"number\">1024</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">memset</span>(audio_buf, <span class=\"number\">0</span>, audio_buf_size);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\taudio_buf_size = audio_size;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\taudio_buf_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlen1 = audio_buf_size - audio_buf_index;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (len1 &gt; len) len1 = len;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memcpy</span>(stream, (<span class=\"type\">uint8_t</span>*)audio_buf + audio_buf_index, len1);</span><br><span class=\"line\">\t\tlen -= len1;</span><br><span class=\"line\">\t\tstream += len1;</span><br><span class=\"line\">\t\taudio_buf_index += len1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PCM_play</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">player</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> filepath[] = <span class=\"string\">&quot;input.mp4&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 多媒体文件上下文</span></span><br><span class=\"line\">\t\tAVFormatContext* pFormatCtx = <span class=\"literal\">NULL</span>;\t\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i, videoStream, audioStream;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 编解码上下文 视频流</span></span><br><span class=\"line\">\t\tAVCodecContext* pCodecCtxOrig = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tAVCodecContext* pCodecCtx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 图像裁剪上下文</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"title class_\">SwsContext</span>* sws_ctx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 音频流</span></span><br><span class=\"line\">\t\tAVCodecContext* aCodecCtxtOrig = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tAVCodecContext* aCodecCtx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tAVCodec* aCodec = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">int64_t</span> in_channel_layout;</span><br><span class=\"line\">\t\t<span class=\"type\">int64_t</span> out_channel_layout;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 编解码器</span></span><br><span class=\"line\">\t\tAVCodec* pCodec = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 解码后的数据帧</span></span><br><span class=\"line\">\t\tAVFrame* pFrame = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 解码前的数据包</span></span><br><span class=\"line\">\t\tAVPacket packet;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> frameFinished;</span><br><span class=\"line\">\t\t<span class=\"type\">float</span> aspect_ratio;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 解码出来的YUV数据存放在</span></span><br><span class=\"line\">\t\tAVPicture* pict = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tSDL_Rect rect;</span><br><span class=\"line\">\t\tUint32 pixformat;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// render</span></span><br><span class=\"line\">\t\tSDL_Window* win = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tSDL_Renderer* renderer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tSDL_Texture* texture = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置默认的窗口大小</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> w_width = <span class=\"number\">640</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> w_height = <span class=\"number\">480</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 事件</span></span><br><span class=\"line\">\t\tSDL_Event event;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 音频 指定音频播放的参数</span></span><br><span class=\"line\">\t\tSDL_AudioSpec wanted_spec, spec;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">SDL_Init</span>(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Could not initialize SDL - %s.\\n&quot;</span>, <span class=\"built_in\">SDL_GetError</span>());</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">av_register_all</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avformat_open_input</span>(&amp;pFormatCtx, filepath, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Could not open video file\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avformat_find_stream_info</span>(pFormatCtx, <span class=\"literal\">NULL</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to find stream information.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">av_dump_format</span>(pFormatCtx, <span class=\"number\">0</span>, filepath, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到 视频流 音频流</span></span><br><span class=\"line\">\t\tvideoStream = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\taudioStream = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class=\"line\">\t\t\t\tvideoStream = i;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;视频流编号：%d\\n&quot;</span>, i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class=\"line\">\t\t\t\taudioStream = i;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;音频流编号：%d\\n&quot;</span>, i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (videoStream == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Din&#x27;t find a video stream.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (audioStream == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Din&#x27;t find a audio stream.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 音频</span></span><br><span class=\"line\">\t\taCodecCtxtOrig = pFormatCtx-&gt;streams[audioStream]-&gt;codec;</span><br><span class=\"line\">\t\taCodec = <span class=\"built_in\">avcodec_find_decoder</span>(aCodecCtxtOrig-&gt;codec_id);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!aCodec) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Unsupported codec.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\taCodecCtx = <span class=\"built_in\">avcodec_alloc_context3</span>(aCodec);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avcodec_copy_context</span>(aCodecCtx, aCodecCtxtOrig) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Couldn&#x27;t copy codec context.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置音频参数</span></span><br><span class=\"line\">\t\twanted_spec.freq = aCodecCtx-&gt;sample_rate;</span><br><span class=\"line\">\t\twanted_spec.format = AUDIO_S16SYS;</span><br><span class=\"line\">\t\twanted_spec.channels = aCodecCtx-&gt;channels;</span><br><span class=\"line\">\t\twanted_spec.silence = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\twanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class=\"line\">\t\twanted_spec.callback = audio_callback;</span><br><span class=\"line\">\t\twanted_spec.userdata = aCodecCtx;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">SDL_OpenAudio</span>(&amp;wanted_spec, &amp;spec) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to open audio device -%s.\\n&quot;</span>, <span class=\"built_in\">SDL_GetError</span>());</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 打开音频解码器</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">avcodec_open2</span>(aCodecCtx, aCodec, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">packet_queue_init</span>(&amp;audioq);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tin_channel_layout = <span class=\"built_in\">av_get_default_channel_layout</span>(aCodecCtx-&gt;channels);</span><br><span class=\"line\">\t\tout_channel_layout = in_channel_layout;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;in layout:%lld, out layout:%lld \\n&quot;</span>, in_channel_layout, out_channel_layout);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\taudio_convert_ctx = <span class=\"built_in\">swr_alloc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (audio_convert_ctx) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swr_alloc_set_opts</span>(audio_convert_ctx,</span><br><span class=\"line\">\t\t\t\tout_channel_layout,</span><br><span class=\"line\">\t\t\t\tAV_SAMPLE_FMT_S16,</span><br><span class=\"line\">\t\t\t\taCodecCtx-&gt;sample_rate,</span><br><span class=\"line\">\t\t\t\tin_channel_layout,</span><br><span class=\"line\">\t\t\t\taCodecCtx-&gt;sample_fmt,</span><br><span class=\"line\">\t\t\t\taCodecCtx-&gt;sample_rate,</span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"literal\">NULL</span></span><br><span class=\"line\">\t\t\t\t);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">swr_init</span>(audio_convert_ctx);</span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_PauseAudio</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* 这行代码的目的是获取视频流的编解码上下文（`AVCodecContext`）。</span></span><br><span class=\"line\"><span class=\"comment\">\t\t`pFormatCtx` 是输入格式上下文，`streams[videoStream]` 表示视频流，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t然后通过 `codec` 成员获取该流的编解码上下文。*/</span></span><br><span class=\"line\">\t\tpCodecCtxOrig = pFormatCtx-&gt;streams[videoStream]-&gt;codec;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到视频流的解码器</span></span><br><span class=\"line\">\t\tpCodec = <span class=\"built_in\">avcodec_find_decoder</span>(pCodecCtxOrig-&gt;codec_id);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pCodec == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Unsupported codec.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 复制 上下文 为了不破坏原来的流</span></span><br><span class=\"line\">\t\tpCodecCtx = <span class=\"built_in\">avcodec_alloc_context3</span>(pCodec);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avcodec_copy_context</span>(pCodecCtx, pCodecCtxOrig) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Couldn&#x27;t copy codec context.\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 打开解码器</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">avcodec_open2</span>(pCodecCtx, pCodec, <span class=\"literal\">NULL</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to open decoder!\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 分配视频帧</span></span><br><span class=\"line\">\t\tpFrame = <span class=\"built_in\">av_frame_alloc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tw_width = pCodecCtx-&gt;width;</span><br><span class=\"line\">\t\tw_height = pCodecCtx-&gt;height;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\twin = <span class=\"built_in\">SDL_CreateWindow</span>(<span class=\"string\">&quot;Media Player&quot;</span>,</span><br><span class=\"line\">\t\t\tSDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">\t\t\tSDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">\t\t\t<span class=\"number\">500</span>, <span class=\"number\">500</span>,</span><br><span class=\"line\">\t\t\tSDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!win) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION, <span class=\"string\">&quot;Failed to create window by SDL&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\trenderer = <span class=\"built_in\">SDL_CreateRenderer</span>(win, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!renderer) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_LogError</span>(SDL_LOG_CATEGORY_APPLICATION , <span class=\"string\">&quot;Failed to create Renderer by SDL&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class=\"line\">\t\ttexture = <span class=\"built_in\">SDL_CreateTexture</span>(renderer, pixformat,</span><br><span class=\"line\">\t\t\tSDL_TEXTUREACCESS_STREAMING, w_width, w_height);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsws_ctx = <span class=\"built_in\">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class=\"line\">\t\t\tpCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class=\"line\">\t\t\tAV_PIX_FMT_YUV420P, SWS_BILINEAR,</span><br><span class=\"line\">\t\t\t<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpict = (AVPicture*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(AVPicture));</span><br><span class=\"line\">\t\t<span class=\"built_in\">avpicture_alloc</span>(pict, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"built_in\">av_read_frame</span>(pFormatCtx, &amp;packet) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (packet.stream_index == videoStream) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 解码视频帧</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">avcodec_decode_video2</span>(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 得到解码后的视频帧</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (frameFinished) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将图片转化为 SDL 使用的 YUV 格式</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">sws_scale</span>(sws_ctx, (<span class=\"type\">uint8_t</span> <span class=\"type\">const</span>* <span class=\"type\">const</span>*)pFrame-&gt;data,</span><br><span class=\"line\">\t\t\t\t\t\tpFrame-&gt;linesize, <span class=\"number\">0</span>, pCodecCtx-&gt;height, pict-&gt;data, pict-&gt;linesize);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">SDL_UpdateYUVTexture</span>(texture, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">\t\t\t\t\t\tpict-&gt;data[<span class=\"number\">0</span>], pict-&gt;linesize[<span class=\"number\">0</span>],</span><br><span class=\"line\">\t\t\t\t\t\tpict-&gt;data[<span class=\"number\">1</span>], pict-&gt;linesize[<span class=\"number\">1</span>],</span><br><span class=\"line\">\t\t\t\t\t\tpict-&gt;data[<span class=\"number\">2</span>], pict-&gt;linesize[<span class=\"number\">2</span>]</span><br><span class=\"line\">\t\t\t\t\t\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\trect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\trect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\trect.w = pCodecCtx-&gt;width;</span><br><span class=\"line\">\t\t\t\t\trect.h = pCodecCtx-&gt;height;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">SDL_RenderClear</span>(renderer);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">SDL_RenderCopy</span>(renderer, texture, <span class=\"literal\">NULL</span>, &amp;rect);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">SDL_RenderPresent</span>(renderer);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">SDL_Delay</span>(<span class=\"number\">40</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">av_free_packet</span>(&amp;packet);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (packet.stream_index == audioStream) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">packet_queue_put</span>(&amp;audioq, &amp;packet);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">av_free_packet</span>(&amp;packet);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_PollEvent</span>(&amp;event);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (event.type) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> SDL_QUIT:</span><br><span class=\"line\">\t\t\t\tquit = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> __QUIT;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">SDL_Log</span>(<span class=\"string\">&quot;event type is %d&quot;</span>, event.type);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__QUIT:</span><br><span class=\"line\">\t\tret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t__FAIL:</span><br><span class=\"line\">\t\t<span class=\"comment\">// Free the YUV frame</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pFrame) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">av_frame_free</span>(&amp;pFrame);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Close the codec</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pCodecCtx) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">avcodec_close</span>(pCodecCtx);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pCodecCtxOrig) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">avcodec_close</span>(pCodecCtxOrig);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Close the video file</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pFormatCtx) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">avformat_close_input</span>(&amp;pFormatCtx);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pict) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">avpicture_free</span>(pict);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(pict);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (win) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_DestroyWindow</span>(win);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (renderer) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_DestroyRenderer</span>(renderer);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (texture) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_DestroyTexture</span>(texture);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">SDL_Quit</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure>\n<img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/音视频/黄秋钊.jpg\"\nalt=\"黄秋钊\" />\n<figcaption aria-hidden=\"true\">黄秋钊</figcaption>\n</figure>\n<h4 id=\"多线程与锁音视频的同步\">多线程与锁（音视频的同步）</h4>\n<p>实现音视频同步的本质就是多线程之间的同步。</p>\n<ul>\n<li><code>SDL_CreateThread</code>\n用于创建一个新的线程。它接受一个函数指针和一个指向函数参数的指针作为参数，然后创建一个新的线程来执行指定的函数，并将指定的参数传递给该函数。</li>\n<li><code>SDL_WaitThread</code>函数用于等待一个指定线程的结束。它接受一个指向线程的指针作为参数，并在该线程结束后返回。</li>\n<li><code>SDL_CteateMutex/SDL_DestroyMutex</code>\n<code>SDL_CreateMutex</code>函数用于创建一个互斥锁（mutex），用于线程间的同步。而<code>SDL_DestroyMutex</code>函数用于销毁互斥锁。</li>\n<li><code>SDL_LockMutex/SDL_UnlockMutex</code>\n<code>SDL_LockMutex</code>函数用于尝试锁定互斥锁，如果互斥锁已经被锁定，则该函数会阻塞直到锁可用。<code>SDL_UnlockMutex</code>函数用于释放已经锁定的互斥锁。</li>\n<li><code>SDL_CreateCond/SDL_DestroyCond</code>\n<code>SDL_CreateCond</code>函数用于创建条件变量，而<code>SDL_DestroyCond</code>函数用于销毁条件变量。条件变量通常与互斥锁一起使用，用于在线程之间等待某个条件的发生或通知其他线程。</li>\n<li><code>SDL_CondWait/SDL_CondSignal</code>\n<code>SDL_CondWait</code>函数用于等待条件变量的信号。当线程调用该函数时，它会阻塞并等待条件变量的信号。在等待期间，该函数会释放传入的互斥锁，以允许其他线程修改共享数据。一旦条件变量被另一个线程发送信号，当前线程将重新获取互斥锁并继续执行。<code>SDL_CondSignal</code>函数用于向等待某个条件的线程发送信号，通知它们条件已经满足，可以继续执行。这个函数通常与<code>SDL_CondWait</code>配合使用，用于唤醒一个等待该条件的线程。</li>\n</ul>\n<h4 id=\"播放器线程模型\">播放器线程模型</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/音视频/截屏2024-05-11%2016.50.12.png\"\nalt=\"截屏2024-05-11 16.50.12\" />\n<figcaption aria-hidden=\"true\">截屏2024-05-11 16.50.12</figcaption>\n</figure>\n<p>一共有四个线程：</p>\n<ol type=\"1\">\n<li>主线程，主要用于一些参数的检查，事件的处理，视频的渲染，主线程会定时从视频解码队列中取出视频帧。</li>\n<li>第二个线程，解复用线程，在这个线程中会创建一个视频解码线程，紧接着对多媒体文件进行解复用，将视频包存放在视频流队列，将音频包存放在音频流队列中</li>\n<li>第三个线程是视频解码线程，首先去视频流队列中取出一个个视频包，进行解码，解码后的视频帧，存放在解码视频队列。</li>\n<li>最后一个线程是<code>SDL</code>\n在打开音频设备时创建的，在这个线程中，它会调用我们的回调函数，最终时从音频队列中取出一个个音频包，进行解码，解码后就交给声卡。</li>\n</ol>\n<blockquote>\n<p>为什么要进行重采样？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">SwrContext</span> *audio_swr_ctx;</span><br></pre></td></tr></table></figure>\n<p>这是因为我们的音频设备的音频参数是固定的（采样率、通道数、采样大小等等）。这些都是我们已经固定的。也就是我们一旦初始化音频设备以后，这些参数就不能改变了，而在多媒体文件中，他就存在各种各样的音频格式，比如采样大小，有的是32位的，有的是16位的，有的是浮点的，有的是非浮点的。最终放到我们的音频设备中，统一的播放出来，我们应该对音频进行重采样。将我们见到的所有的音频格式统一到一个格式中，也就是我们打开音频设备时定义的。</p>\n</blockquote>\n<h4 id=\"音视频同步\">音视频同步</h4>\n<p><strong>时间戳</strong></p>\n<ul>\n<li><p><code>PTS (Presentation timestamp)</code>\n：表示在解码视频时应该在特定时间显示帧的时间戳。PTS告诉解码器何时将帧呈现给用户，以确保视频按照正确的顺序和时间显示。PTS通常以时间基为单位（例如，以毫秒为单位）进行表示。</p></li>\n<li><p><code>DTS (Decoding timestamp)</code>：指解码器开始解码帧的时间戳。它指示视频帧何时应该开始解码，以确保在正确的时间呈现帧。DTS通常以时间基为单位（例如，以毫秒为单位）进行表示。\nDTS和PTS之间的差异可以表示解码器需要多长时间来解码视频帧。</p></li>\n<li><p><code>I (intra) / B (bidirectional) / P (predicted) 帧</code>\n：视频编码中常见的帧类型。它们用于表示视频序列中的不同类型的帧。</p>\n<ol type=\"1\">\n<li><p>I帧（Intra\nFrame）：I帧是视频序列中的关键帧或帧间隔。每个I帧都是独立的，不依赖于其他帧。它包含完整的图像信息，可以作为其他帧的参考点。通常，视频序列的开始和切换点（例如场景变化）会包含I帧。</p></li>\n<li><p>P帧（Predicted\nFrame）：P帧是通过对前向参考帧（通常是前一个I帧或P帧）进行运动补偿来编码的。它只包含自身与前一帧之间的差异信息。P帧依赖于之前的帧进行解码，并且可以用来预测未来帧的内容。</p></li>\n<li><p>B帧（Bidirectional\nFrame）：B帧是通过对前后两个参考帧（通常是前一个和后一个I帧或P帧）进行运动补偿来编码的。它包含自身与前后两个参考帧之间的差异信息。B帧通常具有最高的压缩率，因为它可以利用未来和过去帧之间的关联来减少信息冗余。</p></li>\n</ol>\n<p>这些帧类型通常在视频编码标准（如H.264 / AVC或H.265 /\nHEVC）中使用，并且在压缩视频时起着重要作用。</p></li>\n</ul>\n<p><strong>时间戳顺序</strong></p>\n<p>实际帧顺序： <code>I B B P</code></p>\n<p>存放帧顺序： <code>I P B B</code></p>\n<p>解码时间戳： <code>1 4 2 3</code> <code>DTS</code></p>\n<p>展示时间戳： <code>1 2 3 4</code> <code>PTS</code></p>\n<p><strong>从哪里获得PTS</strong></p>\n<ul>\n<li><code>AVPacket PTS</code></li>\n<li><code>AVFrame PTS</code></li>\n<li><code>av_frame_get_best_effort_timestamp()</code> 当\n<code>PTS</code> 无效时，我们可以调用推算出合适的 <code>PTS</code></li>\n</ul>\n<p><strong>时间基</strong></p>\n<ul>\n<li><code>tbr</code> : 帧率\n指在视频中每秒显示的帧数。帧速率决定了视频的流畅度，更高的帧速率通常会产生更加流畅的视频效果。通常，帧速率以每秒帧数（fps）的形式表示。</li>\n<li><code>tbn (time base of stream)</code>：指流的时间基准（time base of\nstream），它表示流中时间单位的基准。在视频处理中，时间单位通常以分数形式表示，例如1/1000秒。这个时间基准用于确定时间戳的单位，以及在视频流中的时间度量。</li>\n<li><code>tbc (time base of codec)</code>：编解码器的时间基准（time base\nof\ncodec），它是指编解码器内部使用的时间单位的基准。与流的时间基准不同，编解码器的时间基准可能与流的时间基准不同，尤其是在处理不同类型的视频或音频流时。编解码器的时间基准用于确定编码器内部时间单位的度量，通常以分数形式表示，例如1/1000秒。</li>\n</ul>\n<p><strong>计算当前帧的 PTS</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTS = PTS * <span class=\"built_in\">av_q2d</span>(video_stream-&gt;time_base);</span><br><span class=\"line\"><span class=\"built_in\">av_q2d</span>(AVRotional a) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.num / (<span class=\"type\">double</span>)a.den;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>计算下一帧的 PTS</strong></p>\n<p><code>video_clock</code>：预测的下一帧视频的 <code>PTS</code>\n上一帧的 <code>PTS</code> 加上 <code>frame_delay</code></p>\n<p><code>frame_delay</code>：<code>1 / tbr</code></p>\n<p><code>audio_clock</code>：音频当前播放的时间戳</p>\n<p><strong>音视频同步方式</strong></p>\n<ol type=\"1\">\n<li><p>视频同步到音频：</p></li>\n<li><p>音频同步到视频：</p></li>\n<li><p>音频和视频都同步到系统时钟：</p></li>\n</ol>\n<p><strong>视频播放的基本思路</strong></p>\n<p>一般的做法，展示第一帧视频帧后，获得要显示的下一个视频帧的\n<code>PTS</code>\n，然后设置一个定时器，当定时器超时后，刷新新的视频帧，如此反复操作。</p>\n<h4 id=\"player\"><strong>player</strong></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">packet_queue_put</span><span class=\"params\">(PacketQueue *q, AVPacket *pkt)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  AVPacketList *pkt1;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">av_dup_packet</span>(pkt) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pkt1 = <span class=\"built_in\">av_malloc</span>(<span class=\"built_in\">sizeof</span>(AVPacketList));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!pkt1)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  pkt1-&gt;pkt = *pkt;</span><br><span class=\"line\">  pkt1-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">SDL_LockMutex</span>(q-&gt;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!q-&gt;last_pkt)</span><br><span class=\"line\">    q-&gt;first_pkt = pkt1;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class=\"line\">  q-&gt;last_pkt = pkt1;</span><br><span class=\"line\">  q-&gt;nb_packets++;</span><br><span class=\"line\">  q-&gt;size += pkt1-&gt;pkt.size;</span><br><span class=\"line\">  <span class=\"built_in\">SDL_CondSignal</span>(q-&gt;cond);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">SDL_UnlockMutex</span>(q-&gt;mutex);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>packet_queue_put</code> 函数用于将一个数据包放入\n<code>PacketQueue</code> 队列中。以下是该函数的详细解释：</p>\n<h3 id=\"函数原型\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">packet_queue_put</span><span class=\"params\">(PacketQueue *q, AVPacket *pkt)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数\">参数</h3>\n<ul>\n<li><code>PacketQueue *q</code>: 指向需要添加数据包的队列的指针。</li>\n<li><code>AVPacket *pkt</code>: 需要添加到队列中的数据包指针。</li>\n</ul>\n<h3 id=\"函数流程\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>复制数据包</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(av_dup_packet(pkt) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>av_dup_packet</code>\n函数复制一个数据包。如果复制失败，返回 -1。</p></li>\n<li><p><strong>分配新节点</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVPacketList *pkt1;</span><br><span class=\"line\">pkt1 = av_malloc(<span class=\"keyword\">sizeof</span>(AVPacketList));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!pkt1)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br></pre></td></tr></table></figure>\n为新的数据包节点分配内存。如果分配失败，返回 -1。</p></li>\n<li><p><strong>初始化新节点</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pkt1-&gt;pkt = *pkt;</span><br><span class=\"line\">pkt1-&gt;next = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n将传入的数据包内容复制到新分配的节点中，并将节点的 <code>next</code>\n指针设为 <code>NULL</code>，表示这是队列的末尾节点。</p></li>\n<li><p><strong>锁定互斥锁</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_LockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>将节点添加到队列</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!q-&gt;last_pkt)</span><br><span class=\"line\">  q-&gt;first_pkt = pkt1;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class=\"line\">q-&gt;last_pkt = pkt1;</span><br><span class=\"line\">q-&gt;nb_packets++;</span><br><span class=\"line\">q-&gt;size += pkt1-&gt;pkt.size;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果队列为空（<code>last_pkt</code> 为 <code>NULL</code>），将\n<code>first_pkt</code> 指向新节点。</li>\n<li>否则，将当前队列的最后一个节点的 <code>next</code>\n指针指向新节点。</li>\n<li>更新 <code>last_pkt</code> 指向新节点。</li>\n<li>增加队列中数据包的计数 <code>nb_packets</code>。</li>\n<li>增加队列的大小 <code>size</code>。</li>\n</ul></li>\n<li><p><strong>发出条件信号</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_CondSignal(q-&gt;cond);</span><br></pre></td></tr></table></figure>\n通知等待该条件的线程，队列中有新的数据包可用。</p></li>\n<li><p><strong>解锁互斥锁</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_UnlockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>返回成功</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"作用\">作用</h3>\n<p><code>packet_queue_put</code> 函数将一个数据包添加到\n<code>PacketQueue</code>\n队列中，同时使用互斥锁和条件变量确保线程安全和同步。该函数在多线程音视频处理应用中非常重要，确保多个线程可以安全地访问和修改数据包队列。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">packet_queue_get</span><span class=\"params\">(PacketQueue *q, AVPacket *pkt, <span class=\"type\">int</span> block)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  AVPacketList *pkt1;</span><br><span class=\"line\">  <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">  SDL_LockMutex(q-&gt;mutex);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(global_video_state-&gt;quit) &#123;</span><br><span class=\"line\">      ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pkt1 = q-&gt;first_pkt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pkt1) &#123;</span><br><span class=\"line\">      q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!q-&gt;first_pkt)</span><br><span class=\"line\">\t\t\t\tq-&gt;last_pkt = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">      q-&gt;nb_packets--;</span><br><span class=\"line\">      q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class=\"line\">      *pkt = pkt1-&gt;pkt;</span><br><span class=\"line\">      av_free(pkt1);</span><br><span class=\"line\">      ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!block) &#123;</span><br><span class=\"line\">      ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  SDL_UnlockMutex(q-&gt;mutex);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>packet_queue_get</code> 函数用于从 <code>PacketQueue</code>\n队列中获取一个数据包。以下是该函数的详细解释：</p>\n<h3 id=\"函数原型-1\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">packet_queue_get</span><span class=\"params\">(PacketQueue *q, AVPacket *pkt, <span class=\"type\">int</span> block)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-1\">参数</h3>\n<ul>\n<li><code>PacketQueue *q</code>: 指向要从中获取数据包的队列的指针。</li>\n<li><code>AVPacket *pkt</code>: 指向接收数据包的指针。</li>\n<li><code>int block</code>:\n指示函数是否应该阻塞等待数据包的标志。非零值表示阻塞，零值表示非阻塞。</li>\n</ul>\n<h3 id=\"函数流程-1\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVPacketList *pkt1;</span><br><span class=\"line\"><span class=\"type\">int</span> ret;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>锁定互斥锁</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_LockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>进入循环</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(;;) &#123;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>检查全局退出标志</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(global_video_state-&gt;quit) &#123;</span><br><span class=\"line\">  ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 如果全局状态\n<code>global_video_state</code> 的 <code>quit</code>\n标志被设置，则退出循环并返回 -1。</p></li>\n<li><p><strong>获取队列中的第一个数据包</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pkt1 = q-&gt;first_pkt;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pkt1) &#123;</span><br></pre></td></tr></table></figure>\n如果队列不为空，获取队列的第一个数据包。</p></li>\n<li><p><strong>更新队列状态</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!q-&gt;first_pkt)</span><br><span class=\"line\">  q-&gt;last_pkt = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">q-&gt;nb_packets--;</span><br><span class=\"line\">q-&gt;size -= pkt1-&gt;pkt.size;</span><br><span class=\"line\">*pkt = pkt1-&gt;pkt;</span><br><span class=\"line\">av_free(pkt1);</span><br><span class=\"line\">ret = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>将队列的 <code>first_pkt</code> 指针更新为下一个节点。</li>\n<li>如果队列现在为空（<code>first_pkt</code> 为\n<code>NULL</code>），更新 <code>last_pkt</code> 为\n<code>NULL</code>。</li>\n<li>更新队列中数据包的计数 <code>nb_packets</code> 和总大小\n<code>size</code>。</li>\n<li>将获取的数据包内容复制到参数 <code>pkt</code> 指向的结构体中。</li>\n<li>释放节点 <code>pkt1</code> 的内存。</li>\n<li>设置返回值为 1 表示成功获取数据包，并退出循环。</li>\n</ul></li>\n<li><p><strong>处理队列为空的情况</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!block) &#123;</span><br><span class=\"line\">  ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果队列为空且 <code>block</code> 标志为 0（非阻塞），设置返回值为 0\n并退出循环。</li>\n<li>如果 <code>block</code> 标志为非零（阻塞），等待条件变量\n<code>q-&gt;cond</code>，在有新数据包添加到队列时被唤醒。</li>\n</ul></li>\n<li><p><strong>解锁互斥锁</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_UnlockMutex(q-&gt;mutex);</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>返回结果</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ret;</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"作用-1\">作用</h3>\n<p><code>packet_queue_get</code> 函数用于从 <code>PacketQueue</code>\n队列中取出一个数据包。它使用互斥锁来确保线程安全，并根据\n<code>block</code>\n参数决定是否阻塞等待新数据包。该函数在多线程音视频处理应用中非常重要，确保多个线程可以安全地从数据包队列中获取数据包。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">get_audio_clock</span><span class=\"params\">(VideoState* is)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> pts;</span><br><span class=\"line\">\t<span class=\"type\">int</span> hw_buf_size, bytes_per_sec, n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpts = is-&gt;audio_clock;</span><br><span class=\"line\">\thw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class=\"line\">\tbytes_per_sec = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tn = is-&gt;audio_ctx-&gt;channels * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is-&gt;audio_st) &#123;</span><br><span class=\"line\">\t\tbytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (bytes_per_sec) &#123;</span><br><span class=\"line\">\t\tpts -= (<span class=\"type\">double</span>)hw_buf_size / bytes_per_sec;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pts;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>get_audio_clock</code>\n函数用于计算和返回当前音频时钟的值。音频时钟是音视频同步中的一个关键因素，用于确保音频和视频的播放保持一致。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-2\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">get_audio_clock</span><span class=\"params\">(VideoState* is)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-2\">参数</h3>\n<ul>\n<li><code>VideoState* is</code>: 指向管理视频播放状态的结构体\n<code>VideoState</code> 的指针。</li>\n</ul>\n<h3 id=\"函数流程-2\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> pts;</span><br><span class=\"line\"><span class=\"type\">int</span> hw_buf_size, bytes_per_sec, n;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>获取当前音频时钟</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pts = is-&gt;audio_clock;</span><br></pre></td></tr></table></figure>\n将当前的音频时钟值赋给 <code>pts</code>\n变量。<code>is-&gt;audio_clock</code>\n存储的是解码器更新的音频时钟。</p></li>\n<li><p><strong>计算音频硬件缓冲区的大小</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br></pre></td></tr></table></figure>\n<code>hw_buf_size</code>\n计算的是音频硬件缓冲区中尚未播放的音频数据量。<code>is-&gt;audio_buf_size</code>\n是音频缓冲区的总大小，<code>is-&gt;audio_buf_index</code>\n是当前缓冲区中已播放的位置。</p></li>\n<li><p><strong>初始化每秒字节数</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bytes_per_sec = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure> 初始化\n<code>bytes_per_sec</code> 为 0。</p></li>\n<li><p><strong>计算每个音频样本的字节数</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = is-&gt;audio_ctx-&gt;channels * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n每个音频样本的字节数 <code>n</code>\n由音频通道数乘以每个样本的字节数（假设每个样本是16位，即2字节）。</p></li>\n<li><p><strong>计算每秒的字节数</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (is-&gt;audio_st) &#123;</span><br><span class=\"line\">    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n如果音频流存在（<code>is-&gt;audio_st</code> 非空），则计算每秒的字节数\n<code>bytes_per_sec</code>。这是由音频采样率乘以每个音频样本的字节数得到的。</p></li>\n<li><p><strong>调整音频时钟</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (bytes_per_sec) &#123;</span><br><span class=\"line\">    pts -= (<span class=\"type\">double</span>)hw_buf_size / bytes_per_sec;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 如果\n<code>bytes_per_sec</code> 非零，则调整音频时钟\n<code>pts</code>。调整量是未播放的音频数据量（<code>hw_buf_size</code>）除以每秒的字节数（<code>bytes_per_sec</code>），这样可以得到未播放音频数据对应的时间，并从当前音频时钟中减去这个时间。</p></li>\n<li><p><strong>返回调整后的音频时钟</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> pts;</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"作用-2\">作用</h3>\n<p><code>get_audio_clock</code>\n函数用于返回当前准确的音频时钟值，通过考虑音频硬件缓冲区中尚未播放的数据量来调整音频时钟。这样可以确保在播放过程中音频和视频的同步。这在多媒体应用中非常重要，尤其是需要保持音视频同步的场景下。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">audio_decode_frame</span><span class=\"params\">(VideoState* is, <span class=\"type\">uint8_t</span>* audio_buf, <span class=\"type\">int</span> buf_size, <span class=\"type\">double</span>* pts_ptr)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len1, data_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tAVPacket* pkt = &amp;is-&gt;audio_pkt;</span><br><span class=\"line\">\t<span class=\"type\">double</span> pts;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (is-&gt;audio_pkt_size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> got_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tlen1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (len1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tis-&gt;audio_pkt_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdata_size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (got_frame) &#123;</span><br><span class=\"line\">\t\t\t\tdata_size = <span class=\"number\">2</span> * is-&gt;audio_frame.nb_samples * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\tassert(data_size &lt;= buf_size);</span><br><span class=\"line\">\t\t\t\tswr_convert(is-&gt;audio_swr_ctx,</span><br><span class=\"line\">\t\t\t\t\t&amp;audio_buf,</span><br><span class=\"line\">\t\t\t\t\tMAX_AUDIO_FRAME_SIZE * <span class=\"number\">3</span> / <span class=\"number\">2</span>,</span><br><span class=\"line\">\t\t\t\t\t(<span class=\"type\">const</span> <span class=\"type\">uint8_t</span> **)is-&gt;audio_frame.data,</span><br><span class=\"line\">\t\t\t\t\tis-&gt;audio_frame.nb_samples);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tis-&gt;audio_pkt_data += len1;</span><br><span class=\"line\">\t\t\tis-&gt;audio_pkt_size -= len1;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (data_size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tpts = is-&gt;audio_clock;</span><br><span class=\"line\">\t\t\t*pts_ptr = pts;</span><br><span class=\"line\">\t\t\tn = <span class=\"number\">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class=\"line\">\t\t\tis-&gt;audio_clock += (<span class=\"type\">double</span>)data_size / (<span class=\"type\">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> data_size;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pkt-&gt;data) &#123;</span><br><span class=\"line\">\t\t\tav_free_packet(pkt);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is-&gt;quit) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tis-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class=\"line\">\t\tis-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class=\"line\">\t\t\tis-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base) * pkt-&gt;pts;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>audio_decode_frame</code> 函数用于从 <code>VideoState</code>\n中解码音频数据，并将解码后的音频数据存储在 <code>audio_buf</code>\n中，同时返回解码的音频帧大小，并更新音频时钟。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-3\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">audio_decode_frame</span><span class=\"params\">(VideoState* is, <span class=\"type\">uint8_t</span>* audio_buf, <span class=\"type\">int</span> buf_size, <span class=\"type\">double</span>* pts_ptr)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-3\">参数</h3>\n<ul>\n<li><code>VideoState* is</code>: 指向管理视频播放状态的结构体\n<code>VideoState</code> 的指针。</li>\n<li><code>uint8_t* audio_buf</code>: 指向存储解码音频数据的缓冲区。</li>\n<li><code>int buf_size</code>: 缓冲区 <code>audio_buf</code>\n的大小。</li>\n<li><code>double* pts_ptr</code>: 指向存储音频帧时间戳的指针。</li>\n</ul>\n<h3 id=\"函数流程-3\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> len1, data_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">AVPacket* pkt = &amp;is-&gt;audio_pkt;</span><br><span class=\"line\"><span class=\"type\">double</span> pts;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>进入循环</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>处理音频数据包</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (is-&gt;audio_pkt_size &gt; <span class=\"number\">0</span>) &#123;</span><br></pre></td></tr></table></figure>\n当音频数据包中仍有未解码数据时，继续解码。</p></li>\n<li><p><strong>解码音频帧</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> got_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\">len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (len1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    is-&gt;audio_pkt_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">data_size = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>调用 <code>avcodec_decode_audio4</code>\n解码音频数据包。如果解码失败，设置 <code>audio_pkt_size</code> 为 0\n并退出循环。</li>\n<li>如果解码成功，<code>len1</code>\n是消耗的字节数，<code>got_frame</code>\n表示是否成功解码出一个完整的音频帧。</li>\n</ul></li>\n<li><p><strong>处理解码后的音频帧</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (got_frame) &#123;</span><br><span class=\"line\">    data_size = <span class=\"number\">2</span> * is-&gt;audio_frame.nb_samples * <span class=\"number\">2</span>;</span><br><span class=\"line\">    assert(data_size &lt;= buf_size);</span><br><span class=\"line\">    swr_convert(is-&gt;audio_swr_ctx,</span><br><span class=\"line\">        &amp;audio_buf,</span><br><span class=\"line\">        MAX_AUDIO_FRAME_SIZE * <span class=\"number\">3</span> / <span class=\"number\">2</span>,</span><br><span class=\"line\">        (<span class=\"type\">const</span> <span class=\"type\">uint8_t</span> **)is-&gt;audio_frame.data,</span><br><span class=\"line\">        is-&gt;audio_frame.nb_samples);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果成功解码出一个音频帧，计算 <code>data_size</code>。</li>\n<li>使用 <code>swr_convert</code> 函数将音频帧数据转换并存储到\n<code>audio_buf</code> 中。</li>\n</ul></li>\n<li><p><strong>更新数据包指针</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-&gt;audio_pkt_data += len1;</span><br><span class=\"line\">is-&gt;audio_pkt_size -= len1;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (data_size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>更新音频时钟</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pts = is-&gt;audio_clock;</span><br><span class=\"line\">*pts_ptr = pts;</span><br><span class=\"line\">n = <span class=\"number\">2</span> * is-&gt;audio_ctx-&gt;channels;</span><br><span class=\"line\">is-&gt;audio_clock += (<span class=\"type\">double</span>)data_size / (<span class=\"type\">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class=\"line\"><span class=\"keyword\">return</span> data_size;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>释放数据包</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (pkt-&gt;data) &#123;</span><br><span class=\"line\">    av_free_packet(pkt);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (is-&gt;quit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>读取下一个数据包</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class=\"line\">is-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class=\"line\">    is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base) * pkt-&gt;pts;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"作用-3\">作用</h3>\n<p><code>audio_decode_frame</code> 函数用于从 <code>VideoState</code>\n的音频包队列中解码音频数据并将其存储到 <code>audio_buf</code>\n中。该函数在解码过程中更新音频时钟，并返回解码后的音频帧大小。该函数确保音频数据的解码和处理，包括对音频时钟的更新，这对于音视频同步非常重要。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">audio_callback</span><span class=\"params\">(<span class=\"type\">void</span> *userdata, Uint8 *stream, <span class=\"type\">int</span> len)</span> &#123;</span><br><span class=\"line\">\tVideoState* is = (VideoState*)userdata;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len1, audio_size;</span><br><span class=\"line\">\t<span class=\"type\">double</span> pts;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSDL_memset(stream, <span class=\"number\">0</span>, len);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class=\"line\">\t\t\taudio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class=\"keyword\">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (audio_size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tis-&gt;audio_buf_size = <span class=\"number\">1024</span> * <span class=\"number\">2</span> * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">memset</span>(is-&gt;audio_buf, <span class=\"number\">0</span>, is-&gt;audio_buf_size);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tis-&gt;audio_buf_size = audio_size;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tis-&gt;audio_buf_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlen1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (len1 &gt; len) &#123;</span><br><span class=\"line\">\t\t\tlen1 = len;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSDL_MixAudio(stream, (<span class=\"type\">uint8_t</span>*)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br><span class=\"line\">\t\tlen -= len1;</span><br><span class=\"line\">\t\tstream += len1;</span><br><span class=\"line\">\t\tis-&gt;audio_buf_index += len1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>audio_callback</code>\n函数是音频回调函数，通常在多媒体播放中使用，用于将解码后的音频数据填充到音频输出缓冲区中。在使用\nSDL\n库进行音频播放时，会指定这个回调函数来处理音频数据。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-4\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">audio_callback</span><span class=\"params\">(<span class=\"type\">void</span> *userdata, Uint8 *stream, <span class=\"type\">int</span> len)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-4\">参数</h3>\n<ul>\n<li><code>void *userdata</code>:\n指向用户数据的指针，在此上下文中，它是一个 <code>VideoState</code>\n结构体的指针。</li>\n<li><code>Uint8 *stream</code>: 指向 SDL\n音频输出缓冲区的指针，音频数据将被写入这个缓冲区。</li>\n<li><code>int len</code>: 要填充的音频数据的长度，以字节为单位。</li>\n</ul>\n<h3 id=\"函数流程-4\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>获取 <code>VideoState</code> 结构体的指针</strong>：\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VideoState* is = (VideoState*)userdata;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> len1, audio_size;</span><br><span class=\"line\"><span class=\"type\">double</span> pts;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>清空输出缓冲区</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_memset(stream, <span class=\"number\">0</span>, len);</span><br></pre></td></tr></table></figure> 使用\n<code>SDL_memset</code> 函数将输出缓冲区 <code>stream</code>\n清零，确保缓冲区内没有旧的音频数据。</p></li>\n<li><p><strong>循环填充音频数据</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>检查并解码新的音频帧</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class=\"line\">    audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class=\"keyword\">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (audio_size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        is-&gt;audio_buf_size = <span class=\"number\">1024</span> * <span class=\"number\">2</span> * <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(is-&gt;audio_buf, <span class=\"number\">0</span>, is-&gt;audio_buf_size);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        is-&gt;audio_buf_size = audio_size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    is-&gt;audio_buf_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果音频缓冲区中没有未播放的数据（<code>audio_buf_index</code> 超过\n<code>audio_buf_size</code>），则调用 <code>audio_decode_frame</code>\n函数解码新的音频帧。</li>\n<li>如果解码失败，设定一个默认缓冲区大小并清零缓冲区。</li>\n<li>如果解码成功，更新缓冲区大小。</li>\n<li>重置 <code>audio_buf_index</code> 为 0。</li>\n</ul></li>\n<li><p><strong>计算需要拷贝的数据长度</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (len1 &gt; len) &#123;</span><br><span class=\"line\">    len1 = len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>计算当前缓冲区中未播放的数据长度 <code>len1</code>。</li>\n<li>如果 <code>len1</code> 大于剩余要填充的长度\n<code>len</code>，则只填充 <code>len</code> 的长度。</li>\n</ul></li>\n<li><p><strong>将音频数据拷贝到输出缓冲区</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_MixAudio(stream, (<span class=\"type\">uint8_t</span>*)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br></pre></td></tr></table></figure> 使用\n<code>SDL_MixAudio</code> 函数将音频数据从 <code>audio_buf</code> 拷贝到\n<code>stream</code>，并混音。</p></li>\n<li><p><strong>更新剩余长度和指针</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len -= len1;</span><br><span class=\"line\">stream += len1;</span><br><span class=\"line\">is-&gt;audio_buf_index += len1;</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"作用-4\">作用</h3>\n<p><code>audio_callback</code> 函数在音频设备需要更多数据时被调用。它从\n<code>VideoState</code> 结构体中获取音频数据，将其解码并填充到 SDL\n提供的音频缓冲区中。这保证了音频流的连续性和正确性，确保音频播放平滑且无间断。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> Uint32 <span class=\"title function_\">sdl_refresh_timer_cb</span><span class=\"params\">(Uint32 interval, <span class=\"type\">void</span>* opaque)</span> &#123;</span><br><span class=\"line\">\tSDL_Event event;</span><br><span class=\"line\">\tevent.type = FF_REFRESH_EVENT;</span><br><span class=\"line\">\tevent.user.data1 = opaque;</span><br><span class=\"line\">\tSDL_PushEvent(&amp;event);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个函数 <code>sdl_refresh_timer_cb</code> 是一个 SDL\n定时器回调函数，用于向 SDL\n事件队列中推送一个自定义事件，从而触发后续的事件处理。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-5\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> Uint32 <span class=\"title function_\">sdl_refresh_timer_cb</span><span class=\"params\">(Uint32 interval, <span class=\"type\">void</span>* opaque)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-5\">参数</h3>\n<ul>\n<li><code>Uint32 interval</code>: 定时器的间隔时间，单位是毫秒。</li>\n<li><code>void* opaque</code>:\n一个指向用户数据的指针，可以是任何类型的数据。在这个上下文中，它通常用于传递状态信息或上下文。</li>\n</ul>\n<h3 id=\"函数流程-5\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义一个 SDL 事件</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_Event event;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. **设置事件类型**：</span><br><span class=\"line\">   ```c</span><br><span class=\"line\">   event.type = FF_REFRESH_EVENT;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>FF_REFRESH_EVENT</code> 是一个自定义的 SDL\n事件类型，通常是通过 <code>#define</code> 语句定义的。</li>\n<li>例如： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FF_REFRESH_EVENT (SDL_USEREVENT + 1)</span></span><br></pre></td></tr></table></figure></li>\n</ul></li>\n<li><p><strong>设置事件数据</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event.user.data1 = opaque;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>event.user.data1</code> 是一个 <code>void*</code>\n类型的数据指针，可以存储传入的用户数据 <code>opaque</code>。</li>\n</ul></li>\n</ol>\n<ul>\n<li>这允许在事件处理函数中访问这个用户数据。</li>\n</ul>\n<ol start=\"4\" type=\"1\">\n<li><strong>将事件推送到 SDL 事件队列</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_PushEvent(&amp;event);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 <code>SDL_PushEvent</code> 函数将定义好的事件推送到 SDL\n事件队列中。</li>\n<li>这会触发事件处理机制，从而在事件循环中处理这个自定义事件。</li>\n</ul></li>\n<li><strong>返回值</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定时器回调函数返回 0\n表示一次性定时器，即不再重复触发。如果希望定时器重复触发，可以返回\n<code>interval</code> 的值。</li>\n</ul></li>\n</ol>\n<h3 id=\"作用-5\">作用</h3>\n<p><code>sdl_refresh_timer_cb</code>\n函数的主要作用是创建并推送一个自定义的刷新事件到 SDL\n事件队列中，以触发后续的图像刷新或其他需要处理的任务。这个机制常用于视频播放或其他需要定时刷新界面的应用中。</p>\n<h3 id=\"使用场景\">使用场景</h3>\n<p>假设在视频播放应用中，我们希望定期刷新视频帧。我们可以设置一个 SDL\n定时器，当定时器超时时，调用 <code>sdl_refresh_timer_cb</code>\n推送一个刷新事件，然后在事件循环中处理这个事件，更新视频显示。这样可以确保视频播放的平滑性和同步性。</p>\n<h3 id=\"示例\">示例</h3>\n<p>以下是一个可能的使用示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义自定义事件类型</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FF_REFRESH_EVENT (SDL_USEREVENT + 1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置定时器</span></span><br><span class=\"line\">SDL_AddTimer(<span class=\"number\">40</span>, sdl_refresh_timer_cb, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在事件循环中处理刷新事件</span></span><br><span class=\"line\">SDL_Event event;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (SDL_WaitEvent(&amp;event)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.type == FF_REFRESH_EVENT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用刷新函数，例如刷新视频帧</span></span><br><span class=\"line\">        refresh_video_frame();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，每 40 毫秒触发一次\n<code>sdl_refresh_timer_cb</code>，该函数向事件队列推送\n<code>FF_REFRESH_EVENT</code> 事件，从而定期刷新视频帧。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">video_display</span><span class=\"params\">(VideoState *is)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  SDL_Rect rect;</span><br><span class=\"line\">  VideoPicture *vp;</span><br><span class=\"line\">  <span class=\"type\">float</span> aspect_ratio;</span><br><span class=\"line\">  <span class=\"type\">int</span> w, h, x, y;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(vp-&gt;bmp) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SDL_UpdateYUVTexture( texture, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                          vp-&gt;bmp-&gt;data[<span class=\"number\">0</span>], vp-&gt;bmp-&gt;linesize[<span class=\"number\">0</span>],</span><br><span class=\"line\">                          vp-&gt;bmp-&gt;data[<span class=\"number\">1</span>], vp-&gt;bmp-&gt;linesize[<span class=\"number\">1</span>],</span><br><span class=\"line\">                          vp-&gt;bmp-&gt;data[<span class=\"number\">2</span>], vp-&gt;bmp-&gt;linesize[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    rect.w = is-&gt;video_ctx-&gt;width;</span><br><span class=\"line\">    rect.h = is-&gt;video_ctx-&gt;height;</span><br><span class=\"line\">    SDL_LockMutex(text_mutex);</span><br><span class=\"line\">    SDL_RenderClear( renderer );</span><br><span class=\"line\">    SDL_RenderCopy( renderer, texture, <span class=\"literal\">NULL</span>, &amp;rect);</span><br><span class=\"line\">    SDL_RenderPresent( renderer );</span><br><span class=\"line\">    SDL_UnlockMutex(text_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>video_display</code> 函数用于在 SDL\n窗口中显示视频帧。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-6\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">video_display</span><span class=\"params\">(VideoState *is)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-6\">参数</h3>\n<ul>\n<li><code>VideoState *is</code>:\n指向视频状态的指针，包含了视频播放所需的所有信息和状态。</li>\n</ul>\n<h3 id=\"函数流程-6\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_Rect rect;</span><br><span class=\"line\">VideoPicture *vp;</span><br><span class=\"line\"><span class=\"type\">float</span> aspect_ratio;</span><br><span class=\"line\"><span class=\"type\">int</span> w, h, x, y;</span><br><span class=\"line\"><span class=\"type\">int</span> i;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>获取当前显示的图片帧</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>从 <code>VideoState</code> 的 <code>pictq</code>\n队列中获取当前要显示的视频帧。</li>\n<li><code>is-&gt;pictq_rindex</code>\n是当前要显示的图片帧在队列中的索引。</li>\n</ul></li>\n<li><p><strong>检查视频帧是否有数据</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(vp-&gt;bmp) &#123;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>vp-&gt;bmp</code> 是一个指向 <code>AVFrame</code>\n的指针，包含了 YUV 格式的视频数据。</li>\n<li>如果 <code>vp-&gt;bmp</code> 不为空，说明有视频帧需要显示。</li>\n</ul></li>\n<li><p><strong>更新 YUV 纹理</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_UpdateYUVTexture(texture, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                     vp-&gt;bmp-&gt;data[<span class=\"number\">0</span>], vp-&gt;bmp-&gt;linesize[<span class=\"number\">0</span>],</span><br><span class=\"line\">                     vp-&gt;bmp-&gt;data[<span class=\"number\">1</span>], vp-&gt;bmp-&gt;linesize[<span class=\"number\">1</span>],</span><br><span class=\"line\">                     vp-&gt;bmp-&gt;data[<span class=\"number\">2</span>], vp-&gt;bmp-&gt;linesize[<span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>使用 <code>SDL_UpdateYUVTexture</code> 函数将 <code>AVFrame</code>\n中的 YUV 数据更新到 SDL 纹理 <code>texture</code> 中。</li>\n</ul></li>\n<li><p><strong>设置显示矩形</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">rect.w = is-&gt;video_ctx-&gt;width;</span><br><span class=\"line\">rect.h = is-&gt;video_ctx-&gt;height;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>设置显示区域 <code>rect</code>，使其大小与视频的宽高一致。</li>\n</ul></li>\n<li><p><strong>绘制视频帧</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_LockMutex(text_mutex);</span><br><span class=\"line\">SDL_RenderClear(renderer);</span><br><span class=\"line\">SDL_RenderCopy(renderer, texture, <span class=\"literal\">NULL</span>, &amp;rect);</span><br><span class=\"line\">SDL_RenderPresent(renderer);</span><br><span class=\"line\">SDL_UnlockMutex(text_mutex);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>锁定互斥锁 <code>text_mutex</code>，以确保线程安全。</li>\n<li>清除渲染器 <code>renderer</code>。</li>\n<li>使用 <code>SDL_RenderCopy</code> 函数将更新后的纹理\n<code>texture</code> 复制到渲染器 <code>renderer</code>，并按\n<code>rect</code> 定义的位置和大小显示。</li>\n<li>使用 <code>SDL_RenderPresent</code>\n函数将渲染器内容显示到窗口中。</li>\n<li>解锁互斥锁 <code>text_mutex</code>。</li>\n</ul></li>\n</ol>\n<h3 id=\"作用-6\">作用</h3>\n<p><code>video_display</code> 函数的主要作用是将解码后的视频帧显示在 SDL\n窗口中。通过从 <code>VideoState</code> 的图片队列中获取当前帧，然后使用\nSDL 提供的函数将 YUV\n数据更新到纹理中，再通过渲染器显示到窗口上，从而实现视频播放功能。</p>\n<h3 id=\"使用场景-1\">使用场景</h3>\n<p><code>video_display</code>\n函数通常在视频播放应用中使用，它被定期调用以刷新视频显示。可以在事件循环中或定时器回调中调用这个函数，以确保视频帧按正确的时间间隔显示。</p>\n<h3 id=\"示例-1\">示例</h3>\n<p>在实际使用中，<code>video_display</code>\n函数可能在一个事件处理或定时器回调中调用，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">on_video_refresh</span><span class=\"params\">(VideoState* is)</span> &#123;</span><br><span class=\"line\">    video_display(is);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在事件循环中处理自定义刷新事件</span></span><br><span class=\"line\">SDL_Event event;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (SDL_WaitEvent(&amp;event)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.type == FF_REFRESH_EVENT) &#123;</span><br><span class=\"line\">        on_video_refresh((VideoState*)event.user.data1);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，可以实现视频帧的定时刷新和显示，确保视频播放的平滑和同步。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">video_refresh_timer</span><span class=\"params\">(<span class=\"type\">void</span> *userdata)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  VideoState *is = (VideoState *)userdata;</span><br><span class=\"line\">  VideoPicture *vp;</span><br><span class=\"line\">  <span class=\"type\">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(is-&gt;video_st) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(is-&gt;pictq_size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      schedule_refresh(is, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class=\"line\"></span><br><span class=\"line\">      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class=\"comment\">/* the pts from last time */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(delay &lt;= <span class=\"number\">0</span> || delay &gt;= <span class=\"number\">1.0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* if incorrect delay, use previous one */</span></span><br><span class=\"line\">\tdelay = is-&gt;frame_last_delay;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">/* save for next time */</span></span><br><span class=\"line\">      is-&gt;frame_last_delay = delay;</span><br><span class=\"line\">      is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* update delay to sync to audio */</span></span><br><span class=\"line\">      ref_clock = get_audio_clock(is);</span><br><span class=\"line\">      diff = vp-&gt;pts - ref_clock;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* Skip or repeat the frame. Take delay into account</span></span><br><span class=\"line\"><span class=\"comment\">\t FFPlay still doesn&#x27;t &quot;know if this is the best guess.&quot; */</span></span><br><span class=\"line\">      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(diff &lt;= -sync_threshold) &#123;</span><br><span class=\"line\">\t  delay = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(diff &gt;= sync_threshold) &#123;</span><br><span class=\"line\">\t  delay = <span class=\"number\">2</span> * delay;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      is-&gt;frame_timer += delay;</span><br><span class=\"line\">      <span class=\"comment\">/* computer the REAL delay */</span></span><br><span class=\"line\">      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class=\"number\">1000000.0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(actual_delay &lt; <span class=\"number\">0.010</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* Really it should skip the picture instead */</span></span><br><span class=\"line\">\tactual_delay = <span class=\"number\">0.010</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      schedule_refresh(is, (<span class=\"type\">int</span>)(actual_delay * <span class=\"number\">1000</span> + <span class=\"number\">0.5</span>));</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* show the picture! */</span></span><br><span class=\"line\">      video_display(is);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* update queue for next picture! */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class=\"line\">\tis-&gt;pictq_rindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\">      is-&gt;pictq_size--;</span><br><span class=\"line\">      SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class=\"line\">      SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    schedule_refresh(is, <span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>video_refresh_timer</code>\n函数负责定期刷新视频帧，并确保视频帧与音频同步显示。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-7\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">video_refresh_timer</span><span class=\"params\">(<span class=\"type\">void</span> *userdata)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-7\">参数</h3>\n<ul>\n<li><code>void *userdata</code>: 指向 <code>VideoState</code>\n结构的指针，包含了视频播放所需的所有信息和状态。</li>\n</ul>\n<h3 id=\"函数流程-7\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VideoState *is = (VideoState *)userdata;</span><br><span class=\"line\">VideoPicture *vp;</span><br><span class=\"line\"><span class=\"type\">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>检查是否有视频流</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(is-&gt;video_st) &#123;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>判断 <code>is</code> 中是否有视频流。</li>\n</ul></li>\n<li><p><strong>检查图片队列是否为空</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(is-&gt;pictq_size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  schedule_refresh(is, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果图片队列为空，则调度下次刷新（1 毫秒后），并返回。</li>\n</ul></li>\n<li><p><strong>获取当前要显示的视频帧</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>计算当前帧的显示延迟</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class=\"comment\">/* the pts from last time */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(delay &lt;= <span class=\"number\">0</span> || delay &gt;= <span class=\"number\">1.0</span>) &#123;</span><br><span class=\"line\">  delay = is-&gt;frame_last_delay;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">is-&gt;frame_last_delay = delay;</span><br><span class=\"line\">is-&gt;frame_last_pts = vp-&gt;pts;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>同步音频和视频</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ref_clock = get_audio_clock(is);</span><br><span class=\"line\">diff = vp-&gt;pts - ref_clock;</span><br><span class=\"line\"></span><br><span class=\"line\">sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(diff &lt;= -sync_threshold) &#123;</span><br><span class=\"line\">    delay = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(diff &gt;= sync_threshold) &#123;</span><br><span class=\"line\">    delay = <span class=\"number\">2</span> * delay;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">is-&gt;frame_timer += delay;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>计算实际延迟</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actual_delay = is-&gt;frame_timer - (av_gettime() / <span class=\"number\">1000000.0</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(actual_delay &lt; <span class=\"number\">0.010</span>) &#123;</span><br><span class=\"line\">  actual_delay = <span class=\"number\">0.010</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">schedule_refresh(is, (<span class=\"type\">int</span>)(actual_delay * <span class=\"number\">1000</span> + <span class=\"number\">0.5</span>));</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>显示视频帧</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">video_display(is);</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>更新图片队列</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class=\"line\">  is-&gt;pictq_rindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\">is-&gt;pictq_size--;</span><br><span class=\"line\">SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class=\"line\">SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>处理没有视频流的情况</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  schedule_refresh(is, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"作用-7\">作用</h3>\n<p><code>video_refresh_timer</code>\n函数的主要作用是定期刷新视频帧，同时确保视频帧与音频的同步。通过计算帧的显示延迟，并根据音频时钟调整帧的显示时间，从而实现音视频同步播放。</p>\n<h3 id=\"使用场景-2\">使用场景</h3>\n<p><code>video_refresh_timer</code>\n函数通常在视频播放应用中使用，它通过定时器或事件循环定期调用，以确保视频帧按正确的时间间隔显示，同时与音频保持同步。</p>\n<h3 id=\"示例-2\">示例</h3>\n<p>在实际使用中，<code>video_refresh_timer</code>\n函数可能通过定时器或事件回调机制调用，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> Uint32 <span class=\"title function_\">sdl_refresh_timer_cb</span><span class=\"params\">(Uint32 interval, <span class=\"type\">void</span>* opaque)</span> &#123;</span><br><span class=\"line\">    SDL_Event event;</span><br><span class=\"line\">    event.type = FF_REFRESH_EVENT;</span><br><span class=\"line\">    event.user.data1 = opaque;</span><br><span class=\"line\">    SDL_PushEvent(&amp;event);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在事件循环中处理自定义刷新事件</span></span><br><span class=\"line\">SDL_Event event;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (SDL_WaitEvent(&amp;event)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.type == FF_REFRESH_EVENT) &#123;</span><br><span class=\"line\">        video_refresh_timer(event.user.data1);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，可以实现视频帧的定时刷新和显示，确保视频播放的平滑和同步。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">alloc_picture</span><span class=\"params\">(<span class=\"type\">void</span> *userdata)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  VideoState *is = (VideoState *)userdata;</span><br><span class=\"line\">  VideoPicture *vp;</span><br><span class=\"line\"></span><br><span class=\"line\">  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(vp-&gt;bmp) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// we already have one make another, bigger/smaller</span></span><br><span class=\"line\">    avpicture_free(vp-&gt;bmp);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(vp-&gt;bmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    vp-&gt;bmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Allocate a place to put our YUV image on that screen</span></span><br><span class=\"line\">  SDL_LockMutex(text_mutex);</span><br><span class=\"line\">  vp-&gt;bmp = (AVPicture*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(AVPicture));</span><br><span class=\"line\">  ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Could not allocate temporary picture: %s\\n&quot;</span>, av_err2str(ret));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  SDL_UnlockMutex(text_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">  vp-&gt;width = is-&gt;video_ctx-&gt;width;</span><br><span class=\"line\">  vp-&gt;height = is-&gt;video_ctx-&gt;height;</span><br><span class=\"line\">  vp-&gt;allocated = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>alloc_picture</code>\n函数负责分配视频帧存储空间，并处理与视频帧队列相关的内存管理。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-8\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">alloc_picture</span><span class=\"params\">(<span class=\"type\">void</span> *userdata)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-8\">参数</h3>\n<ul>\n<li><code>void *userdata</code>: 指向 <code>VideoState</code>\n结构的指针，包含了视频播放所需的所有信息和状态。</li>\n</ul>\n<h3 id=\"函数流程-8\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">VideoState *is = (VideoState *)userdata;</span><br><span class=\"line\">VideoPicture *vp;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>获取当前写入队列中的视频帧</strong>：\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>检查当前视频帧是否已经分配过内存</strong>：\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(vp-&gt;bmp) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// we already have one make another, bigger/smaller</span></span><br><span class=\"line\">  avpicture_free(vp-&gt;bmp);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(vp-&gt;bmp);</span><br><span class=\"line\">  vp-&gt;bmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>分配内存</strong>：</p>\n<ul>\n<li><strong>锁定互斥量以避免多线程冲突</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_LockMutex(text_mutex);</span><br></pre></td></tr></table></figure></li>\n<li><strong>分配 <code>AVPicture</code> 结构体</strong>：\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vp-&gt;bmp = (AVPicture*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(AVPicture));</span><br></pre></td></tr></table></figure></li>\n<li><strong>为 <code>AVPicture</code> 结构体分配内存，用于存储 YUV\n图像</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret = avpicture_alloc(vp-&gt;bmp, AV_PIX_FMT_YUV420P, is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Could not allocate temporary picture: %s\\n&quot;</span>, av_err2str(ret));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul></li>\n<li><p><strong>解锁互斥量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_UnlockMutex(text_mutex);</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>更新 <code>VideoPicture</code>\n结构体中的相关字段</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vp-&gt;width = is-&gt;video_ctx-&gt;width;</span><br><span class=\"line\">vp-&gt;height = is-&gt;video_ctx-&gt;height;</span><br><span class=\"line\">vp-&gt;allocated = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"作用-8\">作用</h3>\n<p><code>alloc_picture</code> 函数的主要作用是为\n<code>VideoPicture</code>\n分配内存，以便存储解码后的视频帧。它会根据当前视频的宽度和高度分配合适的内存，并确保多线程环境下的内存安全。</p>\n<h3 id=\"使用场景-3\">使用场景</h3>\n<p><code>alloc_picture</code>\n函数通常在视频播放的初始化阶段调用，或者在需要调整视频帧的存储空间时调用，例如视频尺寸发生变化时。</p>\n<h3 id=\"示例-3\">示例</h3>\n<p>在视频解码和播放过程中，当需要为新的视频帧分配内存时，可以调用\n<code>alloc_picture</code> 函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在初始化视频播放时，调用 alloc_picture 为每个 VideoPicture 分配内存</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; VIDEO_PICTURE_QUEUE_SIZE; i++) &#123;</span><br><span class=\"line\">    alloc_picture(video_state);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在视频尺寸发生变化时，重新分配内存</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (new_width != video_state-&gt;video_ctx-&gt;width || new_height != video_state-&gt;video_ctx-&gt;height) &#123;</span><br><span class=\"line\">    alloc_picture(video_state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，可以确保每个 <code>VideoPicture</code>\n都有足够的内存来存储解码后的视频帧，确保视频播放的顺畅性和稳定性。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">queue_picture</span><span class=\"params\">(VideoState *is, AVFrame *pFrame, <span class=\"type\">double</span> pts)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  VideoPicture *vp;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* wait until we have space for a new pic */</span></span><br><span class=\"line\">  SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;</span><br><span class=\"line\">\t!is-&gt;quit) &#123;</span><br><span class=\"line\">    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(is-&gt;quit)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// windex is set to 0 initially</span></span><br><span class=\"line\">  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* allocate or resize the buffer! */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!vp-&gt;bmp ||</span><br><span class=\"line\">     vp-&gt;width != is-&gt;video_ctx-&gt;width ||</span><br><span class=\"line\">     vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    vp-&gt;allocated = <span class=\"number\">0</span>;</span><br><span class=\"line\">    alloc_picture(is);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(is-&gt;quit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* We have a place to put our picture on the queue */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(vp-&gt;bmp) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    vp-&gt;pts = pts;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Convert the image into YUV format that SDL uses</span></span><br><span class=\"line\">    sws_scale(is-&gt;video_sws_ctx, (<span class=\"type\">uint8_t</span> <span class=\"type\">const</span> * <span class=\"type\">const</span> *)pFrame-&gt;data,</span><br><span class=\"line\">\t      pFrame-&gt;linesize, <span class=\"number\">0</span>, is-&gt;video_ctx-&gt;height,</span><br><span class=\"line\">\t      vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* now we inform our display thread that we have a pic ready */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class=\"line\">      is-&gt;pictq_windex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\">    is-&gt;pictq_size++;</span><br><span class=\"line\">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>queue_picture</code>\n函数用于将解码后的视频帧添加到视频帧队列中，以便在合适的时间进行显示。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-9\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">queue_picture</span><span class=\"params\">(VideoState *is, AVFrame *pFrame, <span class=\"type\">double</span> pts)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-9\">参数</h3>\n<ul>\n<li><code>VideoState *is</code>: 指向 <code>VideoState</code>\n结构的指针，包含视频播放所需的所有信息和状态。</li>\n<li><code>AVFrame *pFrame</code>: 解码后的视频帧。</li>\n<li><code>double pts</code>: 帧的展示时间戳 (Presentation\nTimestamp)。</li>\n</ul>\n<h3 id=\"返回值\">返回值</h3>\n<ul>\n<li><code>int</code>: 如果队列操作成功返回\n0，出现错误或用户请求退出时返回 -1。</li>\n</ul>\n<h3 id=\"函数流程-9\">函数流程</h3>\n<ol type=\"1\">\n<li><p><strong>定义局部变量</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VideoPicture *vp;</span><br></pre></td></tr></table></figure></p></li>\n<li><p><strong>等待队列有空间</strong>：</p>\n<ul>\n<li>锁定互斥量以确保线程安全。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_LockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure></li>\n<li>如果队列已满且程序未退出，则等待条件变量。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp; !is-&gt;quit) &#123;</span><br><span class=\"line\">  SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>解锁互斥量。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. **检查程序是否请求退出**：</span><br><span class=\"line\">   ```c</span><br><span class=\"line\">   if(is-&gt;quit)</span><br><span class=\"line\">     return -1;</span><br></pre></td></tr></table></figure></li>\n</ul></li>\n<li><p><strong>获取当前写入队列中的视频帧</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. **分配或调整缓冲区**：</span><br><span class=\"line\"></span><br><span class=\"line\">   - 如果 `VideoPicture` 没有分配内存或尺寸不匹配，则重新分配内存。</span><br><span class=\"line\">     ```c</span><br><span class=\"line\">     if(!vp-&gt;bmp || vp-&gt;width != is-&gt;video_ctx-&gt;width || vp-&gt;height != is-&gt;video_ctx-&gt;height) &#123;</span><br><span class=\"line\">       vp-&gt;allocated = 0;</span><br><span class=\"line\">       alloc_picture(is);</span><br><span class=\"line\">       if(is-&gt;quit) &#123;</span><br><span class=\"line\">         return -1;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>将解码后的帧转换为 YUV 格式并存储到队列</strong>：</p>\n<ul>\n<li>设置帧的展示时间戳。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vp-&gt;pts = pts;</span><br></pre></td></tr></table></figure></li>\n<li>使用 <code>sws_scale</code> 将图像转换为 SDL 使用的 YUV 格式。\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sws_scale(is-&gt;video_sws_ctx, (<span class=\"type\">uint8_t</span> <span class=\"type\">const</span> * <span class=\"type\">const</span> *)pFrame-&gt;data, pFrame-&gt;linesize, <span class=\"number\">0</span>, is-&gt;video_ctx-&gt;height, vp-&gt;bmp-&gt;data, vp-&gt;bmp-&gt;linesize);</span><br></pre></td></tr></table></figure> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">7. **更新写入索引并通知显示线程**：</span><br><span class=\"line\"></span><br><span class=\"line\">   - 更新写入索引。</span><br><span class=\"line\">     ```c</span><br><span class=\"line\">     if(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class=\"line\">       is-&gt;pictq_windex = 0;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></li>\n<li>锁定互斥量并更新队列大小，通知条件变量。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class=\"line\">is-&gt;pictq_size++;</span><br><span class=\"line\">SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">8. **返回成功状态**：</span><br><span class=\"line\">   ```c</span><br><span class=\"line\">   return 0;</span><br></pre></td></tr></table></figure></li>\n</ul></li>\n</ol>\n<h3 id=\"作用-9\">作用</h3>\n<p><code>queue_picture</code>\n函数的主要作用是将解码后的视频帧添加到显示队列中，并确保在多线程环境下操作的线程安全。它负责将帧转换为\nSDL 可处理的格式，并在队列有空间时将帧插入队列，供显示线程进行展示。</p>\n<h3 id=\"使用场景-4\">使用场景</h3>\n<p>该函数通常在视频解码后的流程中调用，用于将解码后的帧加入到待显示的队列中。例如，在解码线程中，当解码出一个新的视频帧时，可以调用\n<code>queue_picture</code> 将该帧加入显示队列：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!is-&gt;quit) &#123;</span><br><span class=\"line\">    AVFrame* frame = av_frame_alloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (avcodec_receive_frame(is-&gt;video_ctx, frame) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> pts = av_frame_get_best_effort_timestamp(frame);</span><br><span class=\"line\">        queue_picture(is, frame, pts);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    av_frame_free(&amp;frame);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，确保每个解码后的视频帧都能按照正确的时间顺序被显示，保证视频播放的连续性和同步性。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">synchronize_video</span><span class=\"params\">(VideoState *is, AVFrame *src_frame, <span class=\"type\">double</span> pts)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">double</span> frame_delay;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pts != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* if we have pts, set video clock to it */</span></span><br><span class=\"line\">    is-&gt;video_clock = pts;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* if we aren&#x27;t given a pts, set it to the clock */</span></span><br><span class=\"line\">    pts = is-&gt;video_clock;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* update the video clock */</span></span><br><span class=\"line\">  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);</span><br><span class=\"line\">  <span class=\"comment\">/* if we are repeating a frame, adjust clock accordingly */</span></span><br><span class=\"line\">  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  is-&gt;video_clock += frame_delay;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pts;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>synchronize_video</code> 函数用于同步视频帧的时间戳 (PTS,\nPresentation Timestamp)\n和视频时钟，确保视频播放的同步性。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-10\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">synchronize_video</span><span class=\"params\">(VideoState *is, AVFrame *src_frame, <span class=\"type\">double</span> pts)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-10\">参数</h3>\n<ul>\n<li><code>VideoState *is</code>: 指向 <code>VideoState</code>\n结构的指针，包含视频播放所需的所有信息和状态。</li>\n<li><code>AVFrame *src_frame</code>: 当前解码的视频帧。</li>\n<li><code>double pts</code>:\n视频帧的展示时间戳。如果没有有效的时间戳，则为 0。</li>\n</ul>\n<h3 id=\"返回值-1\">返回值</h3>\n<ul>\n<li><code>double</code>: 更新后的时间戳，用于同步视频时钟。</li>\n</ul>\n<h3 id=\"函数流程-10\">函数流程</h3>\n<ol type=\"1\">\n<li><strong>检查时间戳是否有效</strong>：\n<ul>\n<li>如果提供了有效的 PTS，则将视频时钟设置为该时间戳。\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(pts != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  is-&gt;video_clock = pts;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 如果没有提供有效的 PTS，则使用视频时钟的当前值 */</span></span><br><span class=\"line\">  pts = is-&gt;video_clock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul></li>\n<li><strong>更新视频时钟</strong>：\n<ul>\n<li>计算当前帧的显示延迟。<code>frame_delay</code>\n是根据帧率计算的基本时间间隔。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);</span><br></pre></td></tr></table></figure></li>\n<li>如果帧有重复字段，调整时间延迟。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class=\"number\">0.5</span>);</span><br></pre></td></tr></table></figure></li>\n<li>更新视频时钟，增加帧延迟以反映下一帧的预期显示时间。\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-&gt;video_clock += frame_delay;</span><br></pre></td></tr></table></figure></li>\n</ul></li>\n<li><strong>返回同步后的时间戳</strong>： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> pts;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"作用-10\">作用</h3>\n<p><code>synchronize_video</code>\n函数的主要作用是同步视频帧的时间戳和视频时钟，确保视频帧按照正确的时间顺序显示。该函数在以下情况下使用：\n- 当解码器提供了有效的 PTS 时，更新视频时钟。 - 当解码器未提供有效的 PTS\n时，使用当前视频时钟的值。 -\n根据帧率和重复字段调整视频时钟，以反映正确的显示时间。</p>\n<h3 id=\"使用场景-5\">使用场景</h3>\n<p>该函数通常在解码线程或视频显示线程中调用，用于确保每个解码后的视频帧都能按照正确的时间顺序被显示，保证视频播放的同步性和连续性。例如，在解码视频帧后，可以调用\n<code>synchronize_video</code> 函数更新时间戳：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> pts = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class=\"line\">    pts = frame-&gt;pts * av_q2d(video_st-&gt;time_base);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pts = synchronize_video(is, frame, pts);</span><br><span class=\"line\">queue_picture(is, frame, pts);</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，可以确保每个视频帧都按照正确的时间顺序显示，避免视频播放时出现同步问题。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">decode_video_thread</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span> &#123;</span><br><span class=\"line\">  VideoState *is = (VideoState *)arg;</span><br><span class=\"line\">  AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class=\"line\">  <span class=\"type\">int</span> frameFinished;</span><br><span class=\"line\">  AVFrame *pFrame;</span><br><span class=\"line\">  <span class=\"type\">double</span> pts;</span><br><span class=\"line\"></span><br><span class=\"line\">  pFrame = av_frame_alloc();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// means we quit getting packets</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pts = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Decode video frame</span></span><br><span class=\"line\">    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) &#123;</span><br><span class=\"line\">      pts = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Did we get a video frame?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(frameFinished) &#123;</span><br><span class=\"line\">      pts = synchronize_video(is, pFrame, pts);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(queue_picture(is, pFrame, pts) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    av_free_packet(packet);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  av_frame_free(&amp;pFrame);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>decode_video_thread</code>\n函数是用于解码视频数据的线程函数。该函数从视频包队列中获取数据包，对其进行解码，并将解码后的帧加入到显示队列中。以下是该函数的详细解释：</p>\n<h3 id=\"函数原型-11\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">decode_video_thread</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-11\">参数</h3>\n<ul>\n<li><code>void *arg</code>: 指向 <code>VideoState</code>\n结构的指针，包含视频播放所需的所有信息和状态。</li>\n</ul>\n<h3 id=\"返回值-2\">返回值</h3>\n<ul>\n<li><code>int</code>: 返回 0 表示线程正常退出。</li>\n</ul>\n<h3 id=\"详细流程\">详细流程</h3>\n<ol type=\"1\">\n<li><strong>初始化变量</strong>：\n<ul>\n<li><code>VideoState *is</code>: 将 <code>arg</code> 转换为\n<code>VideoState</code> 类型。</li>\n<li><code>AVPacket pkt1, *packet = &amp;pkt1</code>: 定义并初始化一个\n<code>AVPacket</code> 变量 <code>pkt1</code>，<code>packet</code> 指向\n<code>pkt1</code>。</li>\n<li><code>int frameFinished</code>: 标记是否解码出完整帧的标志。</li>\n<li><code>AVFrame *pFrame</code>: 用于存储解码后的视频帧。</li>\n<li><code>double pts</code>: 存储帧的显示时间戳。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VideoState *is = (VideoState *)arg;</span><br><span class=\"line\">AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class=\"line\"><span class=\"type\">int</span> frameFinished;</span><br><span class=\"line\">AVFrame *pFrame;</span><br><span class=\"line\"><span class=\"type\">double</span> pts;</span><br><span class=\"line\"></span><br><span class=\"line\">pFrame = av_frame_alloc();</span><br></pre></td></tr></table></figure></li>\n<li><strong>主解码循环</strong>：\n<ul>\n<li>不断从视频包队列中获取数据包进行解码，直到接收到退出信号或包队列为空。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(;;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// means we quit getting packets</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pts = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></li>\n<li><strong>解码视频帧</strong>：\n<ul>\n<li>使用 <code>avcodec_decode_video2</code> 解码视频包。</li>\n<li>获取解码后的时间戳，如果没有有效的时间戳，则设置为 0。</li>\n<li>将时间戳转换为秒。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) &#123;</span><br><span class=\"line\">  pts = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br></pre></td></tr></table></figure></li>\n<li><strong>处理解码后的帧</strong>：\n<ul>\n<li>如果解码出完整帧，则同步时间戳，并将帧加入显示队列。</li>\n<li>如果加入显示队列失败，则退出循环。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(frameFinished) &#123;</span><br><span class=\"line\">  pts = synchronize_video(is, pFrame, pts);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(queue_picture(is, pFrame, pts) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">av_free_packet(packet);</span><br></pre></td></tr></table></figure></li>\n<li><strong>清理资源</strong>：\n<ul>\n<li>解码循环结束后，释放分配的帧资源。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">av_frame_free(&amp;pFrame);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"函数用途\">函数用途</h3>\n<p><code>decode_video_thread</code>\n函数的主要用途是持续从视频包队列中获取数据包并进行解码，将解码后的帧添加到显示队列中。这是一个独立的线程函数，确保视频数据能够被持续解码并准备好进行显示，以保证视频播放的流畅性和同步性。</p>\n<h3 id=\"示例代码\">示例代码</h3>\n<p>以下是函数在视频解码线程中的调用示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VideoState *is = ...; <span class=\"comment\">// 初始化VideoState结构</span></span><br><span class=\"line\">SDL_Thread *video_thread = SDL_CreateThread(decode_video_thread, <span class=\"string\">&quot;Video Decode Thread&quot;</span>, is);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!video_thread) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Could not create video decode thread: %s\\n&quot;</span>, SDL_GetError());</span><br><span class=\"line\">  <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，可以创建并启动一个用于解码视频数据的线程，确保视频播放的正常进行。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">stream_component_open</span><span class=\"params\">(VideoState *is, <span class=\"type\">int</span> stream_index)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;</span><br><span class=\"line\">  AVCodecContext *codecCtx = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  AVCodec *codec = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  SDL_AudioSpec wanted_spec, spec;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(stream_index &lt; <span class=\"number\">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  codecCtx = avcodec_alloc_context3(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!codec) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Unsupported codec!\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set audio settings from codec info</span></span><br><span class=\"line\">    wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class=\"line\">    wanted_spec.format = AUDIO_S16SYS;</span><br><span class=\"line\">    wanted_spec.channels = <span class=\"number\">2</span>;<span class=\"comment\">//codecCtx-&gt;channels;</span></span><br><span class=\"line\">    wanted_spec.silence = <span class=\"number\">0</span>;</span><br><span class=\"line\">    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class=\"line\">    wanted_spec.callback = audio_callback;</span><br><span class=\"line\">    wanted_spec.userdata = is;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;SDL_OpenAudio: %s\\n&quot;</span>, SDL_GetError());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    is-&gt;audio_hw_buf_size = spec.size;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(avcodec_open2(codecCtx, codec, <span class=\"literal\">NULL</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Unsupported codec!\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(codecCtx-&gt;codec_type) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class=\"line\">    is-&gt;audioStream = stream_index;</span><br><span class=\"line\">    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class=\"line\">    is-&gt;audio_ctx = codecCtx;</span><br><span class=\"line\">    is-&gt;audio_buf_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    is-&gt;audio_buf_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;is-&gt;audio_pkt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(is-&gt;audio_pkt));</span><br><span class=\"line\">    packet_queue_init(&amp;is-&gt;audioq);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Out Audio Param</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> out_channel_layout=AV_CH_LAYOUT_STEREO;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//AAC:1024  MP3:1152</span></span><br><span class=\"line\">    <span class=\"type\">int</span> out_nb_samples= is-&gt;audio_ctx-&gt;frame_size;</span><br><span class=\"line\">    <span class=\"comment\">//AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> out_sample_rate=is-&gt;audio_ctx-&gt;sample_rate;</span><br><span class=\"line\">    <span class=\"type\">int</span> out_channels=av_get_channel_layout_nb_channels(out_channel_layout);</span><br><span class=\"line\">    <span class=\"comment\">//Out Buffer Size</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    int out_buffer_size=av_samples_get_buffer_size(NULL,</span></span><br><span class=\"line\"><span class=\"comment\">                                                   out_channels,</span></span><br><span class=\"line\"><span class=\"comment\">                                                   out_nb_samples,</span></span><br><span class=\"line\"><span class=\"comment\">                                                   AV_SAMPLE_FMT_S16,</span></span><br><span class=\"line\"><span class=\"comment\">                                                   1);</span></span><br><span class=\"line\"><span class=\"comment\">                                                   */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//uint8_t *out_buffer=(uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE*2);</span></span><br><span class=\"line\">    <span class=\"type\">int64_t</span> in_channel_layout=av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SwrContext</span> *<span class=\"title\">audio_convert_ctx</span>;</span></span><br><span class=\"line\">    audio_convert_ctx = swr_alloc();</span><br><span class=\"line\">    swr_alloc_set_opts(audio_convert_ctx,</span><br><span class=\"line\">                       out_channel_layout,</span><br><span class=\"line\">                       AV_SAMPLE_FMT_S16,</span><br><span class=\"line\">                       out_sample_rate,</span><br><span class=\"line\">                       in_channel_layout,</span><br><span class=\"line\">                       is-&gt;audio_ctx-&gt;sample_fmt,</span><br><span class=\"line\">                       is-&gt;audio_ctx-&gt;sample_rate,</span><br><span class=\"line\">                       <span class=\"number\">0</span>,</span><br><span class=\"line\">                       <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;swr opts: out_channel_layout:%lld, out_sample_fmt:%d, out_sample_rate:%d, in_channel_layout:%lld, in_sample_fmt:%d, in_sample_rate:%d&quot;</span>,</span><br><span class=\"line\">            out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate, in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt, is-&gt;audio_ctx-&gt;sample_rate);</span><br><span class=\"line\">    swr_init(audio_convert_ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">    is-&gt;audio_swr_ctx = audio_convert_ctx;</span><br><span class=\"line\"></span><br><span class=\"line\">    SDL_PauseAudio(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class=\"line\">    is-&gt;videoStream = stream_index;</span><br><span class=\"line\">    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class=\"line\">    is-&gt;video_ctx = codecCtx;</span><br><span class=\"line\"></span><br><span class=\"line\">    is-&gt;frame_timer = (<span class=\"type\">double</span>)av_gettime() / <span class=\"number\">1000000.0</span>;</span><br><span class=\"line\">    is-&gt;frame_last_delay = <span class=\"number\">40e-3</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    packet_queue_init(&amp;is-&gt;videoq);</span><br><span class=\"line\">    is-&gt;video_sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class=\"line\">\t\t\t\t is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,</span><br><span class=\"line\">\t\t\t\t is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P,</span><br><span class=\"line\">\t\t\t\t SWS_BILINEAR, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span></span><br><span class=\"line\">\t\t\t\t );</span><br><span class=\"line\">    is-&gt;video_tid = SDL_CreateThread(decode_video_thread, <span class=\"string\">&quot;decode_video_thread&quot;</span>, is);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>stream_component_open</code>\n函数用于打开并初始化音频或视频流，并为解码和播放做好准备。以下是该函数的详细解释：</p>\n<h3 id=\"函数原型-12\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">stream_component_open</span><span class=\"params\">(VideoState *is, <span class=\"type\">int</span> stream_index)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-12\">参数</h3>\n<ul>\n<li><code>VideoState *is</code>: 指向包含视频播放相关状态的结构体\n<code>VideoState</code>。</li>\n<li><code>int stream_index</code>: 要打开的流的索引。</li>\n</ul>\n<h3 id=\"返回值-3\">返回值</h3>\n<ul>\n<li><code>int</code>: 返回 0 表示成功，返回 -1 表示失败。</li>\n</ul>\n<h3 id=\"详细流程-1\">详细流程</h3>\n<ol type=\"1\">\n<li><strong>获取 <code>AVFormatContext</code></strong>：\n<ul>\n<li>从 <code>VideoState</code> 结构体中获取格式上下文\n<code>pFormatCtx</code>。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;</span><br></pre></td></tr></table></figure></li>\n<li><strong>检查流索引的有效性</strong>：\n<ul>\n<li>检查 <code>stream_index</code> 是否有效，如果无效则返回 -1。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (stream_index &lt; <span class=\"number\">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>分配和初始化解码器上下文</strong>：\n<ul>\n<li>分配一个新的解码器上下文 <code>codecCtx</code>。</li>\n<li>将流参数复制到解码器上下文中。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVCodecContext *codecCtx = avcodec_alloc_context3(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> ret = avcodec_parameters_to_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br></pre></td></tr></table></figure></li>\n<li><strong>查找解码器</strong>：\n<ul>\n<li>查找流对应的解码器，如果找不到则返回 -1。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!codec) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Unsupported codec!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>初始化音频流</strong>：\n<ul>\n<li>如果流是音频类型，设置音频的 SDL 音频规范并打开音频设备。</li>\n<li>初始化音频缓冲区大小，音频包队列，以及音频重采样上下文。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class=\"line\">  wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class=\"line\">  wanted_spec.format = AUDIO_S16SYS;</span><br><span class=\"line\">  wanted_spec.channels = <span class=\"number\">2</span>;</span><br><span class=\"line\">  wanted_spec.silence = <span class=\"number\">0</span>;</span><br><span class=\"line\">  wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</span><br><span class=\"line\">  wanted_spec.callback = audio_callback;</span><br><span class=\"line\">  wanted_spec.userdata = is;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;SDL_OpenAudio: %s\\n&quot;</span>, SDL_GetError());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  is-&gt;audio_hw_buf_size = spec.size;</span><br><span class=\"line\"></span><br><span class=\"line\">  is-&gt;audioStream = stream_index;</span><br><span class=\"line\">  is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class=\"line\">  is-&gt;audio_ctx = codecCtx;</span><br><span class=\"line\">  is-&gt;audio_buf_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  is-&gt;audio_buf_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;is-&gt;audio_pkt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(is-&gt;audio_pkt));</span><br><span class=\"line\">  packet_queue_init(&amp;is-&gt;audioq);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> out_channel_layout = AV_CH_LAYOUT_STEREO;</span><br><span class=\"line\">  <span class=\"type\">int</span> out_sample_rate = is-&gt;audio_ctx-&gt;sample_rate;</span><br><span class=\"line\">  <span class=\"type\">int64_t</span> in_channel_layout = av_get_default_channel_layout(is-&gt;audio_ctx-&gt;channels);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SwrContext</span> *<span class=\"title\">audio_convert_ctx</span> =</span> swr_alloc_set_opts(<span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                     out_channel_layout, AV_SAMPLE_FMT_S16, out_sample_rate,</span><br><span class=\"line\">                     in_channel_layout, is-&gt;audio_ctx-&gt;sample_fmt,</span><br><span class=\"line\">                     is-&gt;audio_ctx-&gt;sample_rate, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  swr_init(audio_convert_ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">  is-&gt;audio_swr_ctx = audio_convert_ctx;</span><br><span class=\"line\"></span><br><span class=\"line\">  SDL_PauseAudio(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>初始化视频流</strong>：\n<ul>\n<li>如果流是视频类型，初始化视频流相关的变量和上下文，并创建视频解码线程。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (codecCtx-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class=\"line\">  is-&gt;videoStream = stream_index;</span><br><span class=\"line\">  is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class=\"line\">  is-&gt;video_ctx = codecCtx;</span><br><span class=\"line\"></span><br><span class=\"line\">  is-&gt;frame_timer = (<span class=\"type\">double</span>)av_gettime() / <span class=\"number\">1000000.0</span>;</span><br><span class=\"line\">  is-&gt;frame_last_delay = <span class=\"number\">40e-3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  packet_queue_init(&amp;is-&gt;videoq);</span><br><span class=\"line\">  is-&gt;video_sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class=\"line\">             is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,</span><br><span class=\"line\">             is-&gt;video_ctx-&gt;height, AV_PIX_FMT_YUV420P,</span><br><span class=\"line\">             SWS_BILINEAR, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  is-&gt;video_tid = SDL_CreateThread(decode_video_thread, <span class=\"string\">&quot;decode_video_thread&quot;</span>, is);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>打开解码器</strong>：\n<ul>\n<li>打开解码器，如果失败则返回 -1。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (avcodec_open2(codecCtx, codec, <span class=\"literal\">NULL</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Unsupported codec!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"示例代码-1\">示例代码</h3>\n<p>以下是调用 <code>stream_component_open</code>\n函数的示例代码，用于打开视频和音频流：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VideoState *is = ...; <span class=\"comment\">// 初始化VideoState结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (stream_component_open(is, is-&gt;videoStream) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Failed to open video stream\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (stream_component_open(is, is-&gt;audioStream) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Failed to open audio stream\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，可以打开并初始化视频和音频流，为后续的解码和播放做好准备。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">demux_thread</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Uint32 pixformat;</span><br><span class=\"line\"></span><br><span class=\"line\">  VideoState *is = (VideoState *)arg;</span><br><span class=\"line\">  AVFormatContext *pFormatCtx;</span><br><span class=\"line\">  AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> video_index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> audio_index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">  is-&gt;videoStream=<span class=\"number\">-1</span>;</span><br><span class=\"line\">  is-&gt;audioStream=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  global_video_state = is;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Open video file</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>)!=<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// Couldn&#x27;t open file</span></span><br><span class=\"line\"></span><br><span class=\"line\">  is-&gt;pFormatCtx = pFormatCtx;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Retrieve stream information</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(avformat_find_stream_info(pFormatCtx, <span class=\"literal\">NULL</span>)&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// Couldn&#x27;t find stream information</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Dump information about file onto standard error</span></span><br><span class=\"line\">  av_dump_format(pFormatCtx, <span class=\"number\">0</span>, is-&gt;filename, <span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Find the first video stream</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class=\"line\">       video_index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      video_index=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class=\"line\">       audio_index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      audio_index=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(audio_index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    stream_component_open(is, audio_index);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(video_index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    stream_component_open(is, video_index);</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(is-&gt;videoStream &lt; <span class=\"number\">0</span> || is-&gt;audioStream &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;%s: could not open codecs\\n&quot;</span>, is-&gt;filename);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> fail;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  win = SDL_CreateWindow(<span class=\"string\">&quot;Media Player&quot;</span>,</span><br><span class=\"line\">     \t\t   SDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">\t\t   SDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">\t\t   is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class=\"line\">\t\t   SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  renderer = SDL_CreateRenderer(win, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  pixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class=\"line\">  texture = SDL_CreateTexture(renderer,</span><br><span class=\"line\">\t\t\t      pixformat, </span><br><span class=\"line\">\t\t\t      SDL_TEXTUREACCESS_STREAMING,</span><br><span class=\"line\">\t\t\t      is-&gt;video_ctx-&gt;width,</span><br><span class=\"line\">\t\t\t      is-&gt;video_ctx-&gt;height);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// main decode loop</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(is-&gt;quit) &#123;</span><br><span class=\"line\">      SDL_CondSignal(is-&gt;videoq.cond);</span><br><span class=\"line\">      SDL_CondSignal(is-&gt;audioq.cond);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// seek stuff goes here</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||</span><br><span class=\"line\">       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class=\"line\">      SDL_Delay(<span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\tSDL_Delay(<span class=\"number\">100</span>); <span class=\"comment\">/* no error; wait for user input */</span></span><br><span class=\"line\">\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Is this a packet from the video stream?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class=\"line\">      packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class=\"line\">      packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      av_free_packet(packet);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* all done - wait for it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!is-&gt;quit) &#123;</span><br><span class=\"line\">    SDL_Delay(<span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> fail:</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    SDL_Event event;</span><br><span class=\"line\">    event.type = FF_QUIT_EVENT;</span><br><span class=\"line\">    event.user.data1 = is;</span><br><span class=\"line\">    SDL_PushEvent(&amp;event);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>demux_thread</code>\n函数是负责解复用和解码视频文件的主线程。它打开文件，查找音频和视频流，并将数据包发送到相应的解码队列。以下是对该函数的详细解释：</p>\n<h3 id=\"函数原型-13\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">demux_thread</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-13\">参数</h3>\n<ul>\n<li><code>void *arg</code>: 一个指向 <code>VideoState</code>\n结构的指针，包含视频播放相关的状态信息。</li>\n</ul>\n<h3 id=\"返回值-4\">返回值</h3>\n<ul>\n<li><code>int</code>: 返回 0 表示成功，返回 -1 表示失败。</li>\n</ul>\n<h3 id=\"详细流程-2\">详细流程</h3>\n<ol type=\"1\">\n<li><strong>初始化变量</strong>：\n<ul>\n<li>定义变量\n<code>pixformat</code>、<code>VideoState</code>、<code>AVFormatContext</code>\n和 <code>AVPacket</code> 等。</li>\n<li>初始化视频和音频流索引 <code>video_index</code> 和\n<code>audio_index</code> 为 -1。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Uint32 pixformat;</span><br><span class=\"line\">VideoState *is = (VideoState *)arg;</span><br><span class=\"line\">AVFormatContext *pFormatCtx;</span><br><span class=\"line\">AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class=\"line\"><span class=\"type\">int</span> video_index = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> audio_index = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i;</span><br></pre></td></tr></table></figure></li>\n<li><strong>设置初始流索引和全局视频状态</strong>：\n<ul>\n<li>初始化 <code>VideoState</code> 结构体中的视频和音频流索引为\n-1。</li>\n<li>设置全局视频状态变量 <code>global_video_state</code>。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-&gt;videoStream = <span class=\"number\">-1</span>;</span><br><span class=\"line\">is-&gt;audioStream = <span class=\"number\">-1</span>;</span><br><span class=\"line\">global_video_state = is;</span><br></pre></td></tr></table></figure></li>\n<li><strong>打开视频文件</strong>：\n<ul>\n<li>尝试打开视频文件，如果失败则返回 -1。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// Couldn&#x27;t open file</span></span><br><span class=\"line\">is-&gt;pFormatCtx = pFormatCtx;</span><br></pre></td></tr></table></figure></li>\n<li><strong>获取流信息</strong>：\n<ul>\n<li>获取视频文件的流信息，如果失败则返回 -1。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (avformat_find_stream_info(pFormatCtx, <span class=\"literal\">NULL</span>) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// Couldn&#x27;t find stream information</span></span><br><span class=\"line\">av_dump_format(pFormatCtx, <span class=\"number\">0</span>, is-&gt;filename, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></li>\n<li><strong>查找音频和视频流</strong>：\n<ul>\n<li>遍历文件中的所有流，找到第一个视频流和音频流的索引。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; video_index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    video_index = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; audio_index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    audio_index = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>打开音频和视频流</strong>：\n<ul>\n<li>使用 <code>stream_component_open</code>\n函数打开找到的音频和视频流。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (audio_index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  stream_component_open(is, audio_index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (video_index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  stream_component_open(is, video_index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (is-&gt;videoStream &lt; <span class=\"number\">0</span> || is-&gt;audioStream &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;%s: could not open codecs\\n&quot;</span>, is-&gt;filename);</span><br><span class=\"line\">  <span class=\"keyword\">goto</span> fail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>创建 SDL 窗口和渲染器</strong>：\n<ul>\n<li>创建一个 SDL 窗口和渲染器，用于显示视频。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">win = SDL_CreateWindow(<span class=\"string\">&quot;Media Player&quot;</span>,</span><br><span class=\"line\">          SDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">          SDL_WINDOWPOS_UNDEFINED,</span><br><span class=\"line\">          is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,</span><br><span class=\"line\">          SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class=\"line\">renderer = SDL_CreateRenderer(win, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">pixformat = SDL_PIXELFORMAT_IYUV;</span><br><span class=\"line\">texture = SDL_CreateTexture(renderer,</span><br><span class=\"line\">              pixformat,</span><br><span class=\"line\">              SDL_TEXTUREACCESS_STREAMING,</span><br><span class=\"line\">              is-&gt;video_ctx-&gt;width,</span><br><span class=\"line\">              is-&gt;video_ctx-&gt;height);</span><br></pre></td></tr></table></figure></li>\n<li><strong>解复用主循环</strong>：\n<ul>\n<li>主循环从文件中读取数据包，并将它们放入相应的队列中。</li>\n<li>如果达到最大队列大小，则等待一段时间。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is-&gt;quit) &#123;</span><br><span class=\"line\">    SDL_CondSignal(is-&gt;videoq.cond);</span><br><span class=\"line\">    SDL_CondSignal(is-&gt;audioq.cond);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE || is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class=\"line\">    SDL_Delay(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      SDL_Delay(<span class=\"number\">100</span>); <span class=\"comment\">/* no error; wait for user input */</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class=\"line\">    packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class=\"line\">    packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    av_free_packet(packet);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>等待退出</strong>：\n<ul>\n<li>在退出之前等待，确保所有线程都正确退出。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!is-&gt;quit) &#123;</span><br><span class=\"line\">  SDL_Delay(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>错误处理和清理</strong>：\n<ul>\n<li>在出错的情况下，发送 <code>FF_QUIT_EVENT</code>\n事件，确保正确清理资源。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fail:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  SDL_Event event;</span><br><span class=\"line\">  event.type = FF_QUIT_EVENT;</span><br><span class=\"line\">  event.user.data1 = is;</span><br><span class=\"line\">  SDL_PushEvent(&amp;event);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"总结\">总结</h3>\n<p><code>demux_thread</code>\n函数是媒体播放器的核心，它处理文件的打开、解复用、解码和显示。通过结合\nSDL 和 FFmpeg\n库，该函数能够从视频文件中提取音频和视频流，并将它们分别送到音频和视频解码器进行处理，最终在屏幕上显示视频，并通过音频设备播放音频。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span>             ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  SDL_Event       event;</span><br><span class=\"line\"></span><br><span class=\"line\">  VideoState      *is;</span><br><span class=\"line\"></span><br><span class=\"line\">  is = av_mallocz(<span class=\"keyword\">sizeof</span>(VideoState));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(argc &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Usage: test &lt;file&gt;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Register all formats and codecs</span></span><br><span class=\"line\">  av_register_all();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Could not initialize SDL - %s\\n&quot;</span>, SDL_GetError());</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  text_mutex = SDL_CreateMutex();</span><br><span class=\"line\"></span><br><span class=\"line\">  av_strlcpy(is-&gt;filename, argv[<span class=\"number\">1</span>], <span class=\"keyword\">sizeof</span>(is-&gt;filename));</span><br><span class=\"line\"></span><br><span class=\"line\">  is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class=\"line\">  is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class=\"line\"></span><br><span class=\"line\">  schedule_refresh(is, <span class=\"number\">40</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  is-&gt;parse_tid = SDL_CreateThread(demux_thread, <span class=\"string\">&quot;demux_thread&quot;</span>, is);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!is-&gt;parse_tid) &#123;</span><br><span class=\"line\">    av_free(is);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SDL_WaitEvent(&amp;event);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(event.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> FF_QUIT_EVENT:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SDL_QUIT:</span><br><span class=\"line\">      is-&gt;quit = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"comment\">//SDL_Quit();</span></span><br><span class=\"line\">      <span class=\"comment\">//return 0;</span></span><br><span class=\"line\">      <span class=\"keyword\">goto</span> __QUIT;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> FF_REFRESH_EVENT:</span><br><span class=\"line\">      video_refresh_timer(event.user.data1);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">__QUIT:</span><br><span class=\"line\">  ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">__FAIL:</span><br><span class=\"line\"></span><br><span class=\"line\">  SDL_Quit();</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  if(audiofd)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    fclose(audiofd);</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  if(audiofd1)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    fclose(audiofd1);</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>main</code>\n函数是媒体播放器程序的入口点。它初始化库和框架，设置必要的结构和线程，并进入事件处理循环。以下是对\n<code>main</code> 函数的详细解释：</p>\n<h3 id=\"函数原型-14\">函数原型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数-14\">参数</h3>\n<ul>\n<li><code>int argc</code>: 命令行参数的个数。</li>\n<li><code>char *argv[]</code>: 命令行参数的数组。</li>\n</ul>\n<h3 id=\"返回值-5\">返回值</h3>\n<ul>\n<li><code>int</code>: 返回 0 表示成功，返回其他值表示失败。</li>\n</ul>\n<h3 id=\"详细流程-3\">详细流程</h3>\n<ol type=\"1\">\n<li><strong>定义变量</strong>：\n<ul>\n<li>定义返回值 <code>ret</code>，SDL 事件\n<code>event</code>，和视频状态结构 <code>VideoState</code> 的指针\n<code>is</code>。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">SDL_Event event;</span><br><span class=\"line\">VideoState *is;</span><br></pre></td></tr></table></figure></li>\n<li><strong>分配 <code>VideoState</code> 结构</strong>：\n<ul>\n<li>使用 <code>av_mallocz</code> 分配并初始化 <code>VideoState</code>\n结构。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is = av_mallocz(<span class=\"keyword\">sizeof</span>(VideoState));</span><br></pre></td></tr></table></figure></li>\n<li><strong>检查命令行参数</strong>：\n<ul>\n<li>确保至少有一个命令行参数（即文件名）。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Usage: test &lt;file&gt;\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>注册所有格式和编解码器</strong>：\n<ul>\n<li>调用 <code>av_register_all</code>\n注册所有可用的文件格式和编解码器。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">av_register_all();</span><br></pre></td></tr></table></figure></li>\n<li><strong>初始化 SDL</strong>：\n<ul>\n<li>使用 <code>SDL_Init</code> 初始化 SDL\n视频、音频和定时器子系统。如果初始化失败，输出错误信息并退出。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Could not initialize SDL - %s\\n&quot;</span>, SDL_GetError());</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>创建互斥锁</strong>：\n<ul>\n<li>创建一个用于文本的互斥锁 <code>text_mutex</code>。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text_mutex = SDL_CreateMutex();</span><br></pre></td></tr></table></figure></li>\n<li><strong>复制文件名</strong>：\n<ul>\n<li>使用 <code>av_strlcpy</code> 复制命令行参数中的文件名到\n<code>VideoState</code> 结构中的 <code>filename</code> 字段。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">av_strlcpy(is-&gt;filename, argv[<span class=\"number\">1</span>], <span class=\"keyword\">sizeof</span>(is-&gt;filename));</span><br></pre></td></tr></table></figure></li>\n<li><strong>初始化队列互斥锁和条件变量</strong>：\n<ul>\n<li>创建用于帧队列的互斥锁 <code>pictq_mutex</code> 和条件变量\n<code>pictq_cond</code>。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class=\"line\">is-&gt;pictq_cond = SDL_CreateCond();</span><br></pre></td></tr></table></figure></li>\n<li><strong>计划首次刷新</strong>：\n<ul>\n<li>调用 <code>schedule_refresh</code> 函数计划首次刷新事件。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schedule_refresh(is, <span class=\"number\">40</span>);</span><br></pre></td></tr></table></figure></li>\n<li><strong>创建解复用线程</strong>：\n<ul>\n<li>创建解复用线程 <code>parse_tid</code> 并传递 <code>VideoState</code>\n结构指针作为参数。如果线程创建失败，释放 <code>VideoState</code>\n结构并跳转到错误处理代码。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-&gt;parse_tid = SDL_CreateThread(demux_thread, <span class=\"string\">&quot;demux_thread&quot;</span>, is);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!is-&gt;parse_tid) &#123;</span><br><span class=\"line\">  av_free(is);</span><br><span class=\"line\">  <span class=\"keyword\">goto</span> __FAIL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>事件处理循环</strong>：\n<ul>\n<li>使用 <code>SDL_WaitEvent</code> 等待事件并处理不同类型的事件：\n<ul>\n<li><code>FF_QUIT_EVENT</code> 和 <code>SDL_QUIT</code>：设置\n<code>quit</code> 标志，跳转到退出处理代码。</li>\n<li><code>FF_REFRESH_EVENT</code>：调用 <code>video_refresh_timer</code>\n函数处理刷新事件。</li>\n<li>其他事件：忽略。</li>\n</ul></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">  SDL_WaitEvent(&amp;event);</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (event.type) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> FF_QUIT_EVENT:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> SDL_QUIT:</span><br><span class=\"line\">    is-&gt;quit = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> __QUIT;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> FF_REFRESH_EVENT:</span><br><span class=\"line\">    video_refresh_timer(event.user.data1);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>退出处理</strong>：\n<ul>\n<li>在 <code>__QUIT</code> 标签下，设置返回值 <code>ret</code> 为\n0。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__QUIT:</span><br><span class=\"line\">ret = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></li>\n<li><strong>错误处理和资源清理</strong>：\n<ul>\n<li>在 <code>__FAIL</code> 标签下，调用 <code>SDL_Quit</code> 退出\nSDL。如果有其他资源需要清理，可以在这里进行（此示例代码中被注释掉的部分）。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__FAIL:</span><br><span class=\"line\">SDL_Quit();</span><br><span class=\"line\"><span class=\"keyword\">return</span> ret;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"总结-1\">总结</h3>\n<p><code>main</code>\n函数负责初始化所有必要的组件和框架，创建解复用线程，并进入事件处理循环，响应各种\nSDL\n事件。通过这些步骤，它启动了媒体播放器的核心功能，包括解码、同步和显示视频，以及播放音频。</p>\n</blockquote>\n<figure>\n<img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/blog/source/_posts/音视频/player.jpg\"\nalt=\"player\" />\n<figcaption aria-hidden=\"true\">player</figcaption>\n</figure>\n<hr />\n<h2 id=\"pcm\">PCM</h2>\n<p>将音频数字化的常见技术方案是脉冲编码调制（PCM，Pulse Code\nModulation），主要过程是：采样 量化 编码。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/音视频/image-20240928223612862.png\"\nalt=\"image-20240928223612862\" />\n<figcaption aria-hidden=\"true\">image-20240928223612862</figcaption>\n</figure>\n<p>模拟信号的波形是无限光滑的，可以看成由无数个点组成，由于存储空间是相对有限的，数字编码过程中，必须要对波形的点进行采样。采样（Sampling）：每隔一段时间采集一次模拟信号的样本，是一个在时间上将模拟信号离散化（把连续信号转换成离散信号）的过程。</p>\n<p>每秒采集的样本数量，称为采样率（采样频率，采样速率，Sampling\nRate）。比如，采样率44.1kHz表示1秒钟采集44100个样本。</p>\n<p>根据<a\nhref=\"https://zh.wikipedia.org/wiki/采样定理\">采样定理</a>（奈奎斯特–香农采样定理，Nyquist-Shannon\nsampling\ntheorem）得知：只有当采样率高于声音信号最高频率的2倍时，才能把采集的声音信号唯一地还原成原来的声音。人耳能够感觉到的最高声音频率为20000Hz，因此为了满足人耳的听觉要求，需要至少每秒进行40000次采样（40kHz采样率）。这就是为什么常见的CD的采样率为44.1kHz。电话、无线对讲机、无线麦克风等的采样率是8kHZ。</p>\n<p>量化（Quantization）：将每一个采样点的样本值数字化。</p>\n<p>位深度（采样精度，采样大小，Bit\nDepth）：使用多少个二进制位来存储一个采样点的样本值。位深度越高，表示的振幅越精确。常见的CD采用16bit的位深度，能表示65536（216）个不同的值。DVD使用24bit的位深度，大多数电话设备使用8bit的位深度。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/blog/source/_posts/音视频/image-20240928223927838.png\"\nalt=\"image-20240928223927838\" />\n<figcaption aria-hidden=\"true\">image-20240928223927838</figcaption>\n</figure>\n<p>编码：将采样和量化后的数字数据转成二进制码流。</p>\n<p>单声道产生一组声波数据，双声道（立体声）产生两组声波数据。</p>\n<p>采样率44.1kHZ、位深度16bit的1分钟立体声PCM数据有多大？</p>\n<ul>\n<li>采样率 * 位深度 * 声道数 * 时间</li>\n<li><em>44100 * 16 * 2 * 60 / 8 ≈ 10.34MB</em></li>\n</ul>\n<p>1分钟10.34MB，这对于大部分用户来说是不能接受的。要想在不改变音频时长的前提下，降低音频数据的大小，只有2种方法：降低采样指标、压缩。降低采样指标是不可取的，会导致音频质量下降，用户体验变差，因此专家们研发了各种压缩方案。</p>\n<p>比特率（Bit\nRate），指单位时间内传输或处理的比特数量，单位是：比特每秒（bit/s或bps），还有：千比特每秒（Kbit/s或Kbps）、兆比特每秒（Mbit/s或Mbps）、吉比特每秒（Gbit/s或Gbps）、太比特每秒（Tbit/s或Tbps）。</p>\n<p>采样率44.1kHZ、位深度16bit的立体声PCM数据的比特率是多少？</p>\n<ul>\n<li>采样率 * 位深度 * 声道数</li>\n<li><em>44100 * 16 * 2 = 1411.2Kbps</em></li>\n</ul>\n<p>通常，采样率、位深度越高，数字化音频的质量就越好。从比特率的计算公式可以看得出来：比特率越高，数字化音频的质量就越好。</p>\n<p>信噪比（Signal-to-noise\nratio，SNR，S/N，讯噪比），指信号与噪声的比例，用于比较所需信号的强度与背景噪声的强度，以分贝（dB）为单位。</p>\n<h2 id=\"音频的编码与解码\">音频的编码与解码</h2>\n<p>PCM数据可以理解为是：未经压缩的原始音频数据，体积比较大，为了更便于存储和传输，一般都会使用某种音频编码对它进行编码压缩，然后再存成某种音频文件格式。</p>\n<p>压缩分为无损压缩和有损压缩。</p>\n<ul>\n<li>无损压缩\n<ul>\n<li>解压后可以完全还原出原始数据</li>\n<li>压缩比小，体积大</li>\n</ul></li>\n<li>有损压缩\n<ul>\n<li>解压后不能完全还原出原始数据，会丢失一部分信息</li>\n<li>压缩比大，体积小</li>\n<li>压缩比越大，丢失的信息就越多，还原后的信号失真就会越大</li>\n<li>一般是通过舍弃原始数据中对人类听觉不重要的部分，达成压缩成较小文件的目的</li>\n</ul></li>\n<li>压缩比 = 未压缩大小 / 压缩后大小</li>\n</ul>\n<p>当需要播放音频时，得先解码（解压缩）出PCM数据，然后再进行播放。</p>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2024/05/05/mysql/",
            "url": "https://chnhqz.github.io/2024/05/05/mysql/",
            "title": "mysql",
            "date_published": "2024-05-05T04:52:22.000Z",
            "content_html": "<h2 id=\"一sql语句\">一、SQL语句</h2>\n<h3 id=\"数据库表操作ddl\">1.数据库表操作（DDL）</h3>\n<p>查询所有数据库<code>SHOW DATABASES;</code>查询当前数据库<code>SELECTDATABASE();</code></p>\n<p>创建\n<code>CREATE DATABASE [IF NOT EXISTS] 数据库命 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</code></p>\n<p>删除<code>DROP DATABASE[IF EXISTS] 数据库名;</code></p>\n<p>使用<code>USE 数据库名;</code></p>\n<p>查询数据库中的表<code>show tables;'</code></p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-02 16.52.02.png\" alt=\"截屏2024-04-02 16.52.02\" style=\"zoom:30%;\" /></p>\n<p>查询表结构<code>DESC 表名;</code></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-02%2019.53.58.png\"\nalt=\"截屏2024-04-02 19.53.58\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-02 19.53.58</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-02%2020.01.47.png\"\nalt=\"截屏2024-04-02 20.01.47\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-02 20.01.47</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-02%2020.08.51.png\"\nalt=\"截屏2024-04-02 20.08.51\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-02 20.08.51</figcaption>\n</figure>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-02 20.11.50.png\" alt=\"截屏2024-04-02 20.11.50\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table emp(</span><br><span class=\"line\">\t<span class=\"built_in\">id</span> int comment <span class=\"string\">&#x27;编号&#x27;</span>,</span><br><span class=\"line\">  workno varchar(10) comment <span class=\"string\">&#x27;工号&#x27;</span>,</span><br><span class=\"line\">  name varchar(10) comment <span class=\"string\">&#x27;姓名&#x27;</span>,</span><br><span class=\"line\">  gender char(1) comment <span class=\"string\">&#x27;性别&#x27;</span>,</span><br><span class=\"line\">  age tinyint unsigned comment <span class=\"string\">&#x27;年龄&#x27;</span>,</span><br><span class=\"line\">  idcard char(18) comment <span class=\"string\">&#x27;身份证号&#x27;</span>,</span><br><span class=\"line\">  entrydate <span class=\"built_in\">date</span> comment <span class=\"string\">&#x27;入职时间&#x27;</span></span><br><span class=\"line\">) comment <span class=\"string\">&#x27;员工表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"表结构修改\"><strong>表结构修改</strong></h4>\n<p>添加字段\n<code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code></p>\n<p>修改字段<code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p>\n<p>修改字段名和字段类型\n<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></p>\n<p>删除字段<code>ALTER TABLE 表名 DROP 字段名;</code></p>\n<p>修改表名<code>ALTER TABLE 表名 RENAME TO 新表名;</code></p>\n<p>删除表<code>DROP TABLE [IF EXISTS] 表名;</code>\n删除指定表，并重新创建该表 <code>TRUNCATE TABLE 表名;</code>\n这种方式删除，是删除掉整张表的数据，再重新创建该表，等于清空表的数据，留下空表。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-08 19.20.52.png\" alt=\"截屏2024-04-08 19.20.52\" style=\"zoom:50%;\" /></p>\n<h3 id=\"dml增删改\">2.DML增删改</h3>\n<p>DML英文全称是Data Manipulation\nLanguage(数据操作语言)，用来对数据库中表的数据记录进行增删改操作。</p>\n<h4 id=\"添加数据insert\">1.<strong>添加数据INSERT</strong></h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-08%2019.34.50.png\"\nalt=\"截屏2024-04-08 19.34.50\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-08 19.34.50</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-08%2019.36.19.png\"\nalt=\"截屏2024-04-08 19.36.19\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-08 19.36.19</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-08%2019.36.59.png\"\nalt=\"截屏2024-04-08 19.36.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-08 19.36.59</figcaption>\n</figure>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-08 19.38.15.png\" alt=\"截屏2024-04-08 19.38.15\" style=\"zoom:50%;\" /></p>\n<hr />\n<h4 id=\"修改数据update\">2.<strong>修改数据UPDATE</strong></h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-08%2019.57.37.png\"\nalt=\"截屏2024-04-08 19.57.37\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-08 19.57.37</figcaption>\n</figure>\n<hr />\n<h4 id=\"删除数据delete\"><strong>3.删除数据DELETE</strong></h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-08%2020.13.36.png\"\nalt=\"截屏2024-04-08 20.13.36\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-08 20.13.36</figcaption>\n</figure>\n<hr />\n<h3 id=\"dql-介绍\">3.DQL-介绍</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-10%2012.01.20.png\"\nalt=\"截屏2024-04-10 12.01.20\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-10 12.01.20</figcaption>\n</figure>\n<p>DOL英文全称是Data Query\nLanguage(数据查询语言人，数据查询语言，用来查询数据库中表的记录。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-08 20.53.25.png\" alt=\"截屏2024-04-08 20.53.25\" style=\"zoom:50%;\" /></p>\n<h4 id=\"基本查询\"><strong>1.基本查询</strong></h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-09%2012.27.04.png\"\nalt=\"截屏2024-04-09 12.27.04\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-09 12.27.04</figcaption>\n</figure>\n<blockquote>\n<p>1.查询指定字段 name, workno, age 返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, workno, age from emp;\t\t\t\t </span><br></pre></td></tr></table></figure>\n<p>2.查询返回所有字段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp</span><br></pre></td></tr></table></figure>\n<p><strong>在开发的时候尽量不要写通配符</strong></p>\n<p>3.查询所有员工的工作地址，起别名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> workaddress from emp;</span><br><span class=\"line\"><span class=\"keyword\">select</span> workaddress as <span class=\"string\">&#x27;工作地址&#x27;</span> from emp;</span><br></pre></td></tr></table></figure>\n<p>4.查询公司员工的上班地址（不要重复）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> distinct workaddress <span class=\"string\">&#x27;工作地址&#x27;</span> from emp;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"条件查询where\"><strong>2.条件查询（WHERE）</strong></h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-10 11.58.31.png\" alt=\"截屏2024-04-10 11.58.31\" style=\"zoom:50%;\" /></p>\n<p><strong>1.查询年龄等于 88 的员工</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age = 88;</span><br></pre></td></tr></table></figure>\n<p><strong>2.查询年龄小于 20 的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age &lt; 88;</span><br></pre></td></tr></table></figure>\n<p><strong>3.查询年龄小于等于 20 的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age &lt;= 88;</span><br></pre></td></tr></table></figure>\n<p><strong>4.查询没有身份证号的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> idcard is null;</span><br></pre></td></tr></table></figure>\n<p><strong>5.查询有身份证号的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> idcard is not null;</span><br></pre></td></tr></table></figure>\n<p><strong>6.查询年龄不等于 88 的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age != 88;</span><br></pre></td></tr></table></figure>\n<p><strong>7.查询年龄在 15 岁（包含）到 20\n岁（包含）之间的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age &gt;= 15 and age &lt;= 20;</span><br><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age between 15 and 20;</span><br><span class=\"line\"><span class=\"comment\"># between and 既包含最小值又包含最大值</span></span><br></pre></td></tr></table></figure>\n<p><strong>8.查询性别为 女 且年龄小于 25 岁的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> gender = <span class=\"string\">&#x27;女&#x27;</span> and age &lt; 25;</span><br></pre></td></tr></table></figure>\n<p><strong>9.查询年龄等于 18 或 20 或 40 的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age = 10 or age = 20 or age = 40;</span><br><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> age <span class=\"keyword\">in</span>(18, 20, 40);</span><br></pre></td></tr></table></figure>\n<p><strong>10.查询姓名为两个字的员工的信息</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from emp where name like &#x27;__&#x27;;</span><br><span class=\"line\"># 两个下划线代表来两个个字符</span><br></pre></td></tr></table></figure>\n<p><strong>11.查询身份证号最后一位是 X 的员工信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">where</span> idcard like <span class=\"string\">&#x27;%X&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"聚合函数count-max-min-avg-sum\"><strong>3.聚合函数（COUNT, MAX,\nMIN, AVG, SUM）</strong></h4>\n<p>聚合函数是指将一列数据作为一个整体，进行纵向计算。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-10 16.44.40.png\" alt=\"截屏2024-04-10 16.44.40\" style=\"zoom:50%;\" /></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-10%2016.46.02.png\"\nalt=\"截屏2024-04-10 16.46.02\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-10 16.46.02</figcaption>\n</figure>\n<p><strong>1.统计该企业员工数量</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> count(*) from emp;</span><br><span class=\"line\"><span class=\"keyword\">select</span> count(<span class=\"built_in\">id</span>) from emp;</span><br></pre></td></tr></table></figure>\n<p><strong>2.统计该企业员工的平均年龄</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> avg(age) from emp;</span><br></pre></td></tr></table></figure>\n<p><strong>3.统计该企业员工的最大年龄</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> max(age) from emp;</span><br></pre></td></tr></table></figure>\n<p><strong>4.统计该企业员工的最小年龄</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> min(age) from emp;</span><br></pre></td></tr></table></figure>\n<p><strong>5.统计西安地区员工的年龄之和</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">sum</span>(age) from emp <span class=\"built_in\">where</span> workaddress = <span class=\"string\">&#x27;西安&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"分组查询group-by\"><strong>4.分组查询（GROUP BY）</strong></h4>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2024-04-10 17.05.18.png\" alt=\"截屏2024-04-10 17.05.18\" style=\"zoom:%;\" /></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-10%2017.06.47.png\"\nalt=\"截屏2024-04-10 17.06.47\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-10 17.06.47</figcaption>\n</figure>\n<p><strong>1.根据性别分组，统计男性员工 和 女性员工的数量</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> count(*) from emp group by gender ;</span><br><span class=\"line\"><span class=\"keyword\">select</span> gender, count(*) from emp group by gender;</span><br></pre></td></tr></table></figure>\n<p><strong>2.根据性别分组，统计男性员工和女性员工的平均年龄</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> gender, avg(age) from emp gruop by gender;</span><br></pre></td></tr></table></figure>\n<p><strong>3.查询年龄小于 45\n的员工，并根据工作地址分组，获取员工数量大于等于 3\n的工作地址</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> workaddress, count(*) from emp <span class=\"built_in\">where</span> age &lt; 45 group by workaddress having count(*) &gt;= 3;</span><br></pre></td></tr></table></figure>\n<h4 id=\"排序查询order-by\"><strong>5.排序查询（ORDER BY）</strong></h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-10%2021.18.46.png\"\nalt=\"截屏2024-04-10 21.18.46\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-10 21.18.46</figcaption>\n</figure>\n<p><strong>1.根据年龄对公司的员工进行升序排序</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp order by age asc;</span><br></pre></td></tr></table></figure>\n<p><strong>2.根据入职时间，对员工进行降序排序</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp order by entrydate desc;</span><br></pre></td></tr></table></figure>\n<p><strong>3.根据年龄对公司员工进行升序排序，年龄相同，再按照入职时间进行降序排序</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp order by age asc, entrydate desc;</span><br></pre></td></tr></table></figure>\n<h4 id=\"分页查询limit\"><strong>6.分页查询（LIMIT）</strong></h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2010.35.25.png\"\nalt=\"截屏2024-04-11 10.35.25\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 10.35.25</figcaption>\n</figure>\n<p><strong>1.查询第一页员工数据，每页展示 10 条记录</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">limit</span> 0, 10;</span><br></pre></td></tr></table></figure>\n<p><strong>2.查询第二页员工数据，每页展示 10 条记录 </strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp <span class=\"built_in\">limit</span> 10, 10;</span><br></pre></td></tr></table></figure>\n<h4 id=\"dql语句执行顺序\">7.DQL语句执行顺序</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2010.44.07.png\"\nalt=\"截屏2024-04-11 10.44.07\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 10.44.07</figcaption>\n</figure>\n<h3 id=\"dcl\">4.DCL</h3>\n<p>DCL（Data Control\nLanguage，数据控制语言），用来管理数据库用户、控制数据库的访问权限。</p>\n<h4 id=\"用户管理\">1.用户管理</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2010.49.01.png\"\nalt=\"截屏2024-04-11 10.49.01\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 10.49.01</figcaption>\n</figure>\n<p><strong>注意：主机名可以使用 % 通配。</strong></p>\n<h4 id=\"权限控制\">2.权限控制</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2011.02.56.png\"\nalt=\"截屏2024-04-11 11.02.56\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 11.02.56</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2011.04.52.png\"\nalt=\"截屏2024-04-11 11.04.52\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 11.04.52</figcaption>\n</figure>\n<h2 id=\"二函数\">二、函数</h2>\n<p>函数是指一段可以直接被另一段程序调用的程序或代码。</p>\n<h3 id=\"字符串函数\">1.字符串函数</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2011.33.01.png\"\nalt=\"截屏2024-04-11 11.33.01\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 11.33.01</figcaption>\n</figure>\n<p>由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update emp <span class=\"built_in\">set</span> workno = lpad(workno, 5, <span class=\"string\">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"数值函数\">2.数值函数</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2014.23.41.png\"\nalt=\"截屏2024-04-11 14.23.41\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 14.23.41</figcaption>\n</figure>\n<p>通过数据库的函数，生成一个六位数的随机验证码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> rand()*1000000;</span><br><span class=\"line\"><span class=\"keyword\">select</span> round(rand()*1000000, 0);</span><br><span class=\"line\"><span class=\"keyword\">select</span> lpad(round(rand()*1000000, 0),6, <span class=\"string\">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"日期函数\">3.日期函数</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2015.16.40.png\"\nalt=\"截屏2024-04-11 15.16.40\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 15.16.40</figcaption>\n</figure>\n<h3 id=\"流程函数\">4.流程函数</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2015.19.38.png\"\nalt=\"截屏2024-04-11 15.19.38\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 15.19.38</figcaption>\n</figure>\n<p>查询 emp 表的员工姓名和工作地址（北京/上海-&gt;&gt;&gt; 一线城市，\n其它-&gt;&gt;&gt;&gt;二线城市）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, （<span class=\"keyword\">case</span> workaddress when <span class=\"string\">&#x27;北京&#x27;</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;一线城市&#x27;</span> when <span class=\"string\">&#x27;上海&#x27;</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;一线城市&#x27;</span> <span class=\"keyword\">else</span> <span class=\"string\">&#x27;二线城市&#x27;</span> end） as <span class=\"string\">&#x27;工作地址&#x27;</span> from emp;</span><br></pre></td></tr></table></figure>\n<p>统计班级各个学员的成绩，展示规则：&gt;=85,展示优秀，&gt;=60展示及格，否则，展示不合格。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2015.47.51.png\"\nalt=\"截屏2024-04-11 15.47.51\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 15.47.51</figcaption>\n</figure>\n<h2 id=\"三约束\">三、约束</h2>\n<p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。保证数据库中数据的正确、有效性和完整性。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2015.57.06.png\"\nalt=\"截屏2024-04-11 15.57.06\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 15.57.06</figcaption>\n</figure>\n<p><strong>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束</strong></p>\n<h3 id=\"约束演示\">1.约束演示</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2019.29.38.png\"\nalt=\"截屏2024-04-11 19.29.38\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 19.29.38</figcaption>\n</figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table user (</span><br><span class=\"line\">\t<span class=\"built_in\">id</span> int primary key auto_increment,</span><br><span class=\"line\">  name varchar(10) not null unique,</span><br><span class=\"line\">  age int check (age &gt; 0 &amp;&amp; age &lt;= 120),</span><br><span class=\"line\">  status char(1) default <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">  gender char(1),</span><br><span class=\"line\">) comment <span class=\"string\">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"外键约束\">2.外键约束</h3>\n<p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-11%2020.01.23.png\"\nalt=\"截屏2024-04-11 20.01.23\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-11 20.01.23</figcaption>\n</figure>\n<p><strong>注意：目前上述的两张表，在数据库层面，并未建立外键关联，所以是无法保证数据的一致性和完整性的</strong></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2010.34.53.png\"\nalt=\"截屏2024-04-12 10.34.53\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 10.34.53</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2010.38.36.png\"\nalt=\"截屏2024-04-12 10.38.36\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 10.38.36</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2010.40.46.png\"\nalt=\"截屏2024-04-12 10.40.46\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 10.40.46</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2010.43.17.png\"\nalt=\"截屏2024-04-12 10.43.17\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 10.43.17</figcaption>\n</figure>\n<h2 id=\"四多表查询\">四、多表查询</h2>\n<h3 id=\"多表关系\">1.多表关系</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2010.52.50.png\"\nalt=\"截屏2024-04-12 10.52.50\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 10.52.50</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.04.18.png\"\nalt=\"截屏2024-04-12 11.04.18\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.04.18</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.06.00.png\"\nalt=\"截屏2024-04-12 11.06.00\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.06.00</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.10.06.png\"\nalt=\"截屏2024-04-12 11.10.06\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.10.06</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.10.28.png\"\nalt=\"截屏2024-04-12 11.10.28\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.10.28</figcaption>\n</figure>\n<p><strong>在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</strong></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.12.40.png\"\nalt=\"截屏2024-04-12 11.12.40\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.12.40</figcaption>\n</figure>\n<h3 id=\"多表查询概述\">2.多表查询概述</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.19.20.png\"\nalt=\"截屏2024-04-12 11.19.20\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.19.20</figcaption>\n</figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * from emp, dept <span class=\"built_in\">where</span> emp.dept_id = dept.id;</span><br></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.23.24.png\"\nalt=\"截屏2024-04-12 11.23.24\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.23.24</figcaption>\n</figure>\n<h3 id=\"内连接\">3.内连接</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.26.45.png\"\nalt=\"截屏2024-04-12 11.26.45\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.26.45</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.32.17.png\"\nalt=\"截屏2024-04-12 11.32.17\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.32.17</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.33.49.png\"\nalt=\"截屏2024-04-12 11.33.49\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.33.49</figcaption>\n</figure>\n<h3 id=\"外连接\">4.外连接</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.35.58.png\"\nalt=\"截屏2024-04-12 11.35.58\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.35.58</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.38.59.png\"\nalt=\"截屏2024-04-12 11.38.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.38.59</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.41.30.png\"\nalt=\"截屏2024-04-12 11.41.30\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.41.30</figcaption>\n</figure>\n<h3 id=\"自连接\">5.自连接</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.49.48.png\"\nalt=\"截屏2024-04-12 11.49.48\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.49.48</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.53.21.png\"\nalt=\"截屏2024-04-12 11.53.21\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.53.21</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2011.57.09.png\"\nalt=\"截屏2024-04-12 11.57.09\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 11.57.09</figcaption>\n</figure>\n<h3 id=\"联合查询\">6.联合查询</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2014.18.17.png\"\nalt=\"截屏2024-04-12 14.18.17\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 14.18.17</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2014.20.51.png\"\nalt=\"截屏2024-04-12 14.20.51\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 14.20.51</figcaption>\n</figure>\n<p><strong>会出现重复结果， 可以直接删除 all </strong></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2014.23.43.png\"\nalt=\"截屏2024-04-12 14.23.43\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 14.23.43</figcaption>\n</figure>\n<h3 id=\"子查询\">7.子查询</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2014.25.35.png\"\nalt=\"截屏2024-04-12 14.25.35\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 14.25.35</figcaption>\n</figure>\n<p>根据子查询位置，分为：WHERE之后、FROM之后、SELECT之后。</p>\n<h4 id=\"标量子查询\">标量子查询</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.31.52.png\"\nalt=\"截屏2024-04-12 15.31.52\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.31.52</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.34.59.png\"\nalt=\"截屏2024-04-12 15.34.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.34.59</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.36.59.png\"\nalt=\"截屏2024-04-12 15.36.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.36.59</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.37.35.png\"\nalt=\"截屏2024-04-12 15.37.35\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.37.35</figcaption>\n</figure>\n<h4 id=\"列子查询\">列子查询</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.40.18.png\"\nalt=\"截屏2024-04-12 15.40.18\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.40.18</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.43.23.png\"\nalt=\"截屏2024-04-12 15.43.23\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.43.23</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.46.48.png\"\nalt=\"截屏2024-04-12 15.46.48\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.46.48</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2015.49.46.png\"\nalt=\"截屏2024-04-12 15.49.46\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 15.49.46</figcaption>\n</figure>\n<h4 id=\"行子查询\">行子查询</h4>\n<p><img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2016.04.38.png\"\nalt=\"截屏2024-04-12 16.04.38\" /> <img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2016.10.30.png\"\nalt=\"截屏2024-04-12 16.10.30\" /></p>\n<h4 id=\"表子查询\">表子查询</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2016.16.11.png\"\nalt=\"截屏2024-04-12 16.16.11\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 16.16.11</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2016.19.22.png\"\nalt=\"截屏2024-04-12 16.19.22\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 16.19.22</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2016.27.04.png\"\nalt=\"截屏2024-04-12 16.27.04\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 16.27.04</figcaption>\n</figure>\n<h2 id=\"五事务\">五、事务</h2>\n<p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。典型案例是银行转账。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2016.37.59.png\"\nalt=\"截屏2024-04-12 16.37.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 16.37.59</figcaption>\n</figure>\n<p><strong>注意⚠️：默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</strong></p>\n<h3 id=\"事务操作\">1.事务操作</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2016.53.43.png\"\nalt=\"截屏2024-04-12 16.53.43\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 16.53.43</figcaption>\n</figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT @@autocommit;</span><br><span class=\"line\"></span><br><span class=\"line\"># @@autocommit = 1 : 自动提交；</span><br><span class=\"line\"># 控制事务，将 @@autocommit 设置为 0 ；当前语句不会直接提交，而是等待 COMMIT 指令</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">select @@autocommit;</span><br><span class=\"line\">set @@autocommit = 0;</span><br><span class=\"line\"></span><br><span class=\"line\"># 1.查询张三账户余额</span><br><span class=\"line\">select * from account where name = &#x27;张三&#x27;;</span><br><span class=\"line\"># 2.将张三账户余额-1000</span><br><span class=\"line\">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class=\"line\"># 3.将李四账户余额+1000</span><br><span class=\"line\">update account set money = money + 1000 where name = &#x27;张三&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交事务</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2017.21.37.png\"\nalt=\"截屏2024-04-12 17.21.37\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 17.21.37</figcaption>\n</figure>\n<h3 id=\"事务四大特性\">2.事务四大特性</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2020.29.10.png\"\nalt=\"截屏2024-04-12 20.29.10\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 20.29.10</figcaption>\n</figure>\n<h3 id=\"并发事务问题\">3.并发事务问题</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-12%2020.41.36.png\"\nalt=\"截屏2024-04-12 20.41.36\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-12 20.41.36</figcaption>\n</figure>\n<h3 id=\"事务隔离级别\">4.事务隔离级别</h3>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-13%2010.48.59.png\"\nalt=\"截屏2024-04-13 10.48.59\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-13 10.48.59</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-04-13%2010.52.56.png\"\nalt=\"截屏2024-04-13 10.52.56\" />\n<figcaption aria-hidden=\"true\">截屏2024-04-13 10.52.56</figcaption>\n</figure>\n<p><strong>SESSION 仅仅设置当前会话的的级别，GLOBAL\n设置为全部的</strong></p>\n<p><code>别担心，有一天我们地球的光会到达遥远的星系，在每个星系我们都会再次年轻，我们将永远在一起。</code></p>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2024/05/05/linux/linux-md/",
            "url": "https://chnhqz.github.io/2024/05/05/linux/linux-md/",
            "title": "linux.md",
            "date_published": "2024-05-05T04:26:02.000Z",
            "content_html": "<h3 id=\"linux学习笔记\">Linux学习笔记</h3>\n<p>以下是lInux设备添加v6的脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -s https://install.zerotier.com | sudo bash</span><br><span class=\"line\">cd /var/lib/zerotier-one</span><br><span class=\"line\">rm -rf planet</span><br><span class=\"line\">wget http://blog.nomao.top/planet -O planet</span><br><span class=\"line\">service zerotier-one restart</span><br><span class=\"line\"></span><br><span class=\"line\">sudo zerotier-cli join 93caa675b035c9d7</span><br><span class=\"line\">sudo zerotier-cli set 93caa675b035c9d7 allowGlobal=true</span><br><span class=\"line\">sudo zerotier-cli set 93caa675b035c9d7 allowDefault=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"linux命令\">2.Linux命令</h3>\n<h4 id=\"linux系统的目录结构\">2.1Linux系统的目录结构</h4>\n<p>Linux的目录结构是一个型结构，没有盘符的概念，只有一个根目录/，所有的文件都在它下面。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-26 11.50.33.png\" alt=\"截屏2023-12-26 11.50.33\" style=\"zoom:50%;\" /></p>\n<p>在Linux系统中，路径之间的层级关系，使用\n<code>:/</code>来表示。Windows则是 <code>:\\</code>。</p>\n<h4 id=\"linux命令入门\">2.2Linux命令入门</h4>\n<h5 id=\"linux命令基础\">2.2.1Linux命令基础</h5>\n<p>命令行：即Linux终端（Terminal），是一种命令提示符页面。以春“字符”的形式操作系统，可以使用各种字符化命令对系统发出操作指令。</p>\n<p>命令：即Linux程序。一个命令就是一个Linux的程序。命令没有图形化页面，可以在命令行（终端中）提供字符化反馈</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-26 13.16.32.png\" alt=\"截屏2023-12-26 13.16.32\" style=\"zoom:50%;\" /></p>\n<p>学习Linux就是在命令行界面去熟练的使用Linux的各类命令。</p>\n<p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的形式：<code>command [-options] [parameter]</code></p>\n<ul>\n<li><code>comman:d</code> 命令本身</li>\n<li><code>-options:</code>\n【可选，非必填】命令的一些选项，可以通过选项控制命令的行为细节</li>\n<li><code>parameter:</code>\n【可选，非必填】命令的参数，多数用于命令的指向目标等</li>\n</ul>\n<blockquote>\n<p><code>ls -l /home/itheima</code> ls是命令本身，-l是选项，\n/home/itheima是参数</p>\n</blockquote>\n<h5 id=\"ls命令入门\">2.2.2ls命令入门</h5>\n<p><code>ls</code>\n命令的作用是列出目录下的内容，语法细节:<code>ls [-a -l -h] [linux路径]</code>\n。当不使用选项和参数，直接使用ls命令本体，表示：以平铺形式，列出当前工作目录下的内容。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-26 14.59.20.png\" alt=\"截屏2023-12-26 14.59.20\" style=\"zoom:50%;\" /></p>\n<p>Linux系统的命令行终端，在启动的时候，默认会加载：</p>\n<ul>\n<li>当前登录用户的HOME目录作为当前工作目录，所以ls命令列出的是HOME目录的内容</li>\n<li>HOME目录：每个Linux操作用户在Linux系统的个人账户目录，路径在\n:<code>/home/用户名</code></li>\n</ul>\n<h5 id=\"ls命令的参数和选项\">2.2.3ls命令的参数和选项</h5>\n<ul>\n<li><code>-a</code>\n选项，表示：all的意思，即列出全部文件（包含隐藏的文件/文件夹）</li>\n<li><code>-l</code>\n选项，表示：以列表（竖向排列）的形式展示内容，并展示更多信息</li>\n<li><code>-h</code>\n选项，表示：以易于阅读的形式，列出文件大小，如K、M、G。注意：<code>-h</code>\n选项必须搭配 <code>-l</code>一起使用。</li>\n</ul>\n<p>ls命令选项的组合使用 <code>ls -a -l</code></p>\n<h4 id=\"目录切换相关命令cdpwd\">2.3目录切换相关命令（cd/pwd）</h4>\n<h5 id=\"cd-切换工作目录\">2.3.1cd 切换工作目录</h5>\n<p>当Linux终端（命令行）打开的时候，会默认以用户的HOME目录作为当前的工像目录</p>\n<p>我们可以通过cd命令，更改当前所在的工作目录。</p>\n<p><code>cd</code>命令来自英文：Change Directory</p>\n<p>浯法：cd[Linux路径］</p>\n<ul>\n<li>﻿<code>cd</code>命令无需选项，只有参数，表示要切换到哪个目录下</li>\n<li>﻿<code>﻿cd</code>命令直接执行，不写参数，表示回到用户的HOME目录</li>\n</ul>\n<h5 id=\"pwd-查看当前工作目录\">2.3.2pwd 查看当前工作目录</h5>\n<p>通过<code>ls</code>来验证当前的工作目录，其实是不恰当的。</p>\n<p>我们可以通过<code>pwd</code>命令，来查看当前所在的工作目录。</p>\n<p><code>pwd</code>命令来自：Print work Directory</p>\n<p>语法：<code>pwd</code></p>\n<ul>\n<li><code>pwd</code>命令，无选项，无参数，直接输入<code>pwd</code>即可</li>\n</ul>\n<h4\nid=\"相对路径绝对路径和特殊路径符\">2.4相对路径、绝对路径和特殊路径符</h4>\n<h5 id=\"相对路径和绝对路径\">2.4.1相对路径和绝对路径</h5>\n<ul>\n<li>绝对路径：以根目录为起点，描述路径的一种写法，路径描述以<code>/</code>开头</li>\n<li>相对路径：以当前目录为起点，描述路径的一种写法，路径描述无需以<code>/</code>开头</li>\n</ul>\n<h5 id=\"特殊路径符\">2.4.2特殊路径符</h5>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-26 17.03.10.png\" alt=\"截屏2023-12-26 17.03.10\" style=\"zoom:50%;\" /></p>\n<p>如图，当前工作目录处于：<code>/home/itheima/Desktop</code></p>\n<p>向上回退一级，切换目录到<code>/home/itheima</code>中</p>\n<ul>\n<li>可以直接通过<code>cd</code>，即可回到HOME目录</li>\n<li>也可以通过特殊路径符来完成</li>\n</ul>\n<p>特殊路径符：</p>\n<ul>\n<li><code>.</code> 表示当前目录，比如：<code>cd ./Desktop</code>\n表示切换到当前目录下的<code>Desktop</code> 目录内，和\n<code>cd Desktop</code> 效果一致</li>\n<li><code>..</code> 表示上一级目录，比如：<code>cd..</code>\n即可切换到上一级目录，<code>cd ../..</code> 切换到上二级的目录</li>\n<li><code>~</code> 表示HOME目录，比如：<code>cd~</code>\n即可切换到HOME目录或<code>cd ~/Desktop</code>\n，切换到HOME内的<code>Desktop</code> 目录</li>\n</ul>\n<h4 id=\"mkdir-命令\">2.5<code>mkdir</code> 命令</h4>\n<p>通过 <code>mkdir</code> 命令可以创建新的目录（文件夹）</p>\n<p><code>mkdir</code> 来自英文：Make Directory</p>\n<p>语法：<code>mkdir [-p] Linux路径</code></p>\n<ul>\n<li>参数必填，表示Linux路径，即要创建的文件夹的路径，相对路径或绝对路径均可</li>\n<li><code>-p</code>\n选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>\n</ul>\n<blockquote>\n<p>⚠️：创建文件夹需要修改权限，确保操作均在HOME目录内，不要在HOME外操作。涉及到权限问题，HOME外无法成功。</p>\n</blockquote>\n<h4 id=\"文件操作命令\">2.6文件操作命令</h4>\n<h5 id=\"touch-创建文件\">2.6.1<code>touch</code> 创建文件</h5>\n<p>可以通过<code>touch</code> 命令创建文件</p>\n<p>语法：<code>touch Linux路径</code></p>\n<p><code>touch</code>\n命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-26 17.46.02.png\" alt=\"截屏2023-12-26 17.46.02\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>文件夹与文件的区别，使用<code>ls -l</code>\n命令，发现文件夹是<code>d</code>开头，文件是<code>-</code>开头</p>\n</blockquote>\n<h5 id=\"cat-命令查看文件内容\">2.6.2<code>cat</code>\n命令查看文件内容</h5>\n<p>可以通过<code>cat</code> 查看内容</p>\n<p>语法：<code>cat Linux路径</code></p>\n<p><code>cat</code>\n同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-26 17.55.17.png\" alt=\"截屏2023-12-26 17.55.17\" style=\"zoom:50%;\" /></p>\n<h5 id=\"more-命令查看文件内容\">2.6.3<code>more</code>\n命令查看文件内容</h5>\n<p><code>more</code> 命令同样可以查看文件内容，同<code>cat</code>\n不同的是：</p>\n<ul>\n<li><code>cat</code> 是直接将内容全部显示出来</li>\n<li><code>more</code> 支持翻页，如果文件内容过多，可以一页页的展示</li>\n</ul>\n<p>语法：<code>more Linux路径</code></p>\n<p><code>more</code>\n同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径都可以使用</p>\n<h5 id=\"cp-复制文件文件夹\">2.6.4 <code>cp</code> 复制文件、文件夹</h5>\n<p><code>cp</code>\n命令可以用于复制文件，<code>cp</code>命令来自英文单词：copy</p>\n<p>语法：<code>cp [-r] 参数1 参数2</code></p>\n<ul>\n<li>﻿<code>-r</code>选项，可选，用于复制文件夹使用，表示递归</li>\n<li>﻿<code>﻿参数1</code>，Linux路径，表示被复制的文件或文件夹</li>\n<li>﻿<code>﻿参数2</code>，Linux路径，表示要复制去的地方</li>\n</ul>\n<h5 id=\"mv-移动文件文件夹\">2.6.5<code>mv</code> 移动文件、文件夹</h5>\n<p><code>mv</code>命令可以用于移动文件，<code>mv</code>命令来自英文单词：move</p>\n<p>语法：<code>mv 参数1 参数2</code></p>\n<ul>\n<li>﻿<code>参数1</code>，Linux路径，表示被移动的文件或文件夹</li>\n<li>﻿<code>﻿参数2</code>，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>\n</ul>\n<h5 id=\"rm-删除文件文件夹\">2.6.6<code>rm</code> 删除文件、文件夹</h5>\n<p><code>rm</code>命令可用于删除文件、文件夹。<code>rm</code>命令来自英文单词：remove</p>\n<p>语法：<code>rm [-r -f] 参数1 参数2 . . . . . 参数N</code></p>\n<ul>\n<li>﻿同<code>cp</code>命令一样，<code>-r</code>选项用于删除文件夹</li>\n<li>﻿<code>-f</code>表示force，强制删除（不会弹出提示确认信息）\n<ul>\n<li>﻿普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</li>\n<li>﻿所以一般普通用户用不到-选项</li>\n</ul></li>\n<li>﻿参数1、参数2、………参数N\n表示要州除的文件或文件夹路径，按照空格隔开</li>\n</ul>\n<p><code>rm</code>命令支持通配符<code>*</code>，用来做模糊匹配</p>\n<ul>\n<li>﻿符号<code>*</code> 表示通配符，即匹配任意内容（包含空），示例：</li>\n<li>﻿<code>﻿test*</code>，表示匹配任何以<code>test</code>开头的内容</li>\n<li>﻿<code>*test</code>，表示匹配任何以<code>test</code>结尾的内容</li>\n<li>﻿<code>﻿*test*</code>，表示匹配任何包含<code>test</code>的内容</li>\n</ul>\n<p><code>-f</code>\n可以通过<code>su -root</code>，并输入密码<code>123456</code>\n临时切换到<code>root</code> 用户体验。</p>\n<h5 id=\"which-查找命令的程序文件\">2.6.7<code>which</code>\n查找命令的程序文件</h5>\n<p>我们在前面学习到的Linux命令，起始它们的本体就是一个个的二进制可执行程序。和Windows系统中的.exe文件，是一个意思。</p>\n<p>我们可以通过<code>which</code>命令，查看所使用的一系列命令的程序文件存放在哪里。</p>\n<p>语法：<code>which 要查找的命令</code></p>\n<h5 id=\"find-查找指定文件\">2.6.8<code>find</code> 查找指定文件</h5>\n<p>语法：<code>find 起始路径 -name “被查找文件名”</code>\n这里查找文件也可以使用通配符。</p>\n<p><code>find</code> 可以按文件大小查找文件</p>\n<p>语法：<code>find 起始路径 -size +｜-n [kMG]</code></p>\n<ul>\n<li><code>+、-</code> 表示大于和小于</li>\n<li><code>n</code> 表示大小数字</li>\n<li><code>kMG</code>\n表示大小单位，<code>k</code>（小写字母）表示<code>kb</code>，<code>M</code>\n表示 <code>MB</code> ，<code>G</code>表示<code>GB</code>。</li>\n</ul>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-27 20.14.03.png\" alt=\"截屏2023-12-27 20.14.03\" style=\"zoom:50%;\" /></p>\n<h5 id=\"grep-过滤文件内容\">2.6.8<code>grep</code> 过滤文件内容</h5>\n<p>可以通过<code>grep</code> 命令，从文件中通过关键字过滤文件行。</p>\n<p>语法：<code>grep [-n] 关键字 文件路径</code></p>\n<ul>\n<li>选项<code>-n</code>，可选，表示在结果中显示匹配的行的行号</li>\n<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用“”将关键字包围起来。</li>\n<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口。</li>\n</ul>\n<h5 id=\"wc-统计内容数量\">2.6.9<code>wc</code> 统计内容数量</h5>\n<p>可以通过<code>wc</code> 命令统计文件的行数、单词数量等</p>\n<p>语法：<code>wc [-c -m -l -w] 文件路径</code></p>\n<ul>\n<li>选项，<code>-c</code>，统计bytes数量</li>\n<li>选项，<code>-m</code>，统计字符数量</li>\n<li>选项，<code>-l</code>，统计行数</li>\n<li>选项，<code>-w</code>，统计单词数量</li>\n<li>参数，<code>文件路径</code>，被统计的文件，可作为内容输入端口</li>\n</ul>\n<h5 id=\"管道符\">2.6.10 <code>管道符</code></h5>\n<p>管道符的含义是：将管道符左边命令的结果，作为右边命令的输入</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-27 20.42.07.png\" alt=\"截屏2023-12-27 20.42.07\" style=\"zoom:50%;\" /></p>\n<p>如上图：</p>\n<ul>\n<li><code>cat itheima.txt</code> 的输出结果（文件内容）</li>\n<li>作为右边<code>grep</code>命令的输入（被过滤文件）</li>\n</ul>\n<h5 id=\"echo-输出内容\">2.6.11 <code>echo</code> 输出内容</h5>\n<p>可以使用<code>echo</code>命令在命令行内输出制定内容</p>\n<p>语法：<code>echo 输出的内容</code></p>\n<ul>\n<li>无需选项，又有一个参试，表示要输出的内容，复杂内容可以用\"\"包围</li>\n<li><figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-27%2021.06.13.png\"\nalt=\"截屏2023-12-27 21.06.13\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-27 21.06.13</figcaption>\n</figure></li>\n</ul>\n<p>反引号的作用，我们可以通过将命令用反引号（通常也称之为飘号）`将其包围</p>\n<p>被`包围的内容，会被作为命令执行，而非普通字符。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-27 21.11.32.png\" alt=\"截屏2023-12-27 21.11.32\" style=\"zoom:50%;\" /></p>\n<h5 id=\"tail-跟踪文件更改\">2.6.12 <code>tail</code> 跟踪文件更改</h5>\n<p>使用<code>tail</code>命令，可以查看文件尾部内容，跟踪文件的最新更改，</p>\n<p>语法：<code>tail [-f -num] Linux路径</code></p>\n<ul>\n<li>参数，Linux路径，表示被跟踪的文件路径</li>\n<li>选项，<code>-f</code>，表示持续跟踪</li>\n<li>选项，<code>-num</code>，表示查看尾部多少行，不填默认10行</li>\n</ul>\n<h5 id=\"重定向符使用\">2.6.13 重定向符使用</h5>\n<p>重定向符：<code>&gt;和&gt;&gt;</code></p>\n<ul>\n<li><code>&gt;</code>，将左侧命令的结果，覆盖写入到符号右侧指定的文件中</li>\n<li><code>&gt;&gt;</code>，将左侧命令的结果，追加写入到符号右侧指定的文件中</li>\n</ul>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-28 17.08.09.png\" alt=\"截屏2023-12-28 17.08.09\" style=\"zoom:80%;\" /></p>\n<h4 id=\"vivim编辑器\">2.7 <code>vi\\vim</code>编辑器</h4>\n<p><code>vi\\vim</code>是\n<code>visual interface</code>的简称，是Linux中最经典的文本编辑器，同图形化界面中的文本编辑器一样，<code>vi</code>是命令行下对文本文件进行编辑的绝佳选择。</p>\n<p><code>vim</code>是<code>vi</code>的加强版本，兼容<code>vi</code>的所有指令，不仅能编辑文本，而且还具有<code>shell</code>程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p>\n<p><strong><code>vi\\vim</code>编辑器的三种工作模式</strong></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-28%2017.35.03.png\"\nalt=\"截屏2023-12-28 17.35.03\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-28 17.35.03</figcaption>\n</figure>\n<p>命令：<code>vim 文件路径</code></p>\n<ul>\n<li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li>\n<li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li>\n</ul>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-28%2019.50.59.png\"\nalt=\"截屏2023-12-28 19.50.59\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-28 19.50.59</figcaption>\n</figure>\n<p>通过<code>vi\\vim</code>命令编辑文件，会打开一个新的窗口，此时这个窗口就是，命令窗口，命令模式是<code>vim</code>编辑器的入口和出口</p>\n<ul>\n<li>进入<code>vim</code>编辑器会进入命令模式</li>\n<li>通过命令模式输入键盘指令，可以进入输入模式</li>\n<li>输入模式需要退回到命令模式，然后通过命令可以进入底线命令模式</li>\n</ul>\n<table>\n<thead>\n<tr class=\"header\">\n<th>模式</th>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>命令模式</td>\n<td>i</td>\n<td>在当前光标位置进入输入模式</td>\n</tr>\n<tr class=\"even\">\n<td>命令模式</td>\n<td>a</td>\n<td>在当前光标位置 之后 进入输入模式</td>\n</tr>\n<tr class=\"odd\">\n<td>命令模式</td>\n<td>I</td>\n<td>在当前行的开头，进入输入模式</td>\n</tr>\n<tr class=\"even\">\n<td>命令模式</td>\n<td>A</td>\n<td>在当前行的结尾，进入输入模式</td>\n</tr>\n<tr class=\"odd\">\n<td>命令模式</td>\n<td>o</td>\n<td>在当前光标下一行进入输入模式</td>\n</tr>\n<tr class=\"even\">\n<td>命令模式</td>\n<td>O</td>\n<td>在当前光标上一行进入输入模式</td>\n</tr>\n<tr class=\"odd\">\n<td>输入模式</td>\n<td>esc</td>\n<td>任何情况下输入esc 都能回到命令模式</td>\n</tr>\n</tbody>\n</table>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-28%2021.17.03.png\"\nalt=\"截屏2023-12-28 21.17.03\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-28 21.17.03</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-28%2022.19.15.png\"\nalt=\"截屏2023-12-28 22.19.15\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-28 22.19.15</figcaption>\n</figure>\n<h3 id=\"linux用户和权限\">3.Linux用户和权限</h3>\n<h4 id=\"linux的root用户\">3.1.Linux的root用户</h4>\n<p><strong>root用户（超级管理员）</strong></p>\n<p>无论是Windows、MacOS、Linux均采用多用户的管理模式进行权限管理。</p>\n<ul>\n<li>在Linux系统中，拥有最大权限的账户名为：<code>root</code>（超级管理员）</li>\n</ul>\n<p>root用户拥有最大的系统操作权限，而普通用户在许多地方的权限是受限的。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-28 22.53.06.png\" alt=\"截屏2023-12-28 22.53.06\" style=\"zoom:50%;\" /></p>\n<p>切换root用户</p>\n<p>命令：<code>su - root</code> 本机 root 密码 与 开机密码一致。</p>\n<p>普通用户的权限，一般在其HOME目录内是不受限的，一旦出了\nHOME目录，大多数地方，普通用户仅有只读和执行权限，无修改权限。</p>\n<p><strong><code>su</code> 和 <code>exit</code> 命令</strong></p>\n<p>语法：<code>su [-] [用户名]</code></p>\n<ul>\n<li>-符号是可选的，表示是否在切换用户后加载环境变量（后续讲解），建议带上</li>\n<li>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root</li>\n<li>切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl+d</li>\n<li>使用普通用户，切换到其它用户需要输入密码，如切换到root用户</li>\n<li>使用root用户切换到其它用户，无需密码，可以直接切换</li>\n</ul>\n<p><strong><code>sudo</code>命令</strong></p>\n<p>在我们得知root密码的时候，可以通过<code>su</code>\n命令切换到root得到最大权限，但是不建议长期使用root用户，避免带来系统损坏。</p>\n<p>我们可以使用<code>sudo</code>命令，为普通的命令授权，临时以root身份执行。</p>\n<p>语法：<code>sudo 其他命令</code></p>\n<ul>\n<li>在其他命令之前，带上 <code>sudo</code>\n，既可为这一条命令临时赋予root授权</li>\n<li>但是并不是所有用户，都有权利使用 <code>sudo</code>\n，我们需要为普通用户配置<code>sudo</code>认证</li>\n</ul>\n<p><strong>为普通用户配置sudo认证</strong></p>\n<ol type=\"1\">\n<li>切换到root用户，执行<code>visudo</code>命令，会自动通过<code>vi</code>编辑器打开，<code>/etc/sudoers</code></li>\n<li>在文件的最后添加：<img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-28 23.16.24.png\" alt=\"截屏2023-12-28 23.16.24\" style=\"zoom:50%;\" />其中最后的<code>NOPASSWD:ALL</code>\n表示使用<code>sudo</code>命令，无需输入密码</li>\n<li>最后通过 <code>wq</code>保存</li>\n</ol>\n<h4 id=\"用户用户组\">3.2.用户、用户组</h4>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-28%2023.29.43.png\"\nalt=\"截屏2023-12-28 23.29.43\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-28 23.29.43</figcaption>\n</figure>\n<p>Linux中关于权限的管控级别有2个级别，分别是：</p>\n<ul>\n<li>针对用户的权限控制</li>\n<li>针对用户组的权限控制</li>\n</ul>\n<p>比如，针对某文件，可以控制用户的权限，也可以控制用户组的权限。所以，我们需要学习在Linux中进行用户、用户组管理的基础命令，为后面学习权限控制打下基础。</p>\n<p><strong>用户组管理</strong></p>\n<p>以下命令需root用户执行</p>\n<ul>\n<li>创建用户组 <code>groupadd 用户组名</code></li>\n<li>删除用户组<code>groupdel 用户组名</code></li>\n</ul>\n<p><strong>用户管理</strong></p>\n<p>以下命令需root用户执行</p>\n<ul>\n<li>创建用户 <code>useradd [-g -d] 用户名</code>\n<ul>\n<li>﻿选项：<code>-g</code>指定用户的组，不指定<code>-g</code>，会创建同名组并自动加入，指定<code>-g</code>需要组己经存在，如己存在同名组，必须使用<code>-g</code></li>\n<li>﻿选项：<code>-d</code>指定用户<code>HOME路径</code>，不指定，<code>HOME</code>目录默认在：<code>/home/用户名</code></li>\n</ul></li>\n<li>删除用户 <code>userdel [-r] 用户名</code>\n<ul>\n<li>选项：<code>-r</code>，删除用户的<code>HOME</code>目录，不使用\n<code>-r</code>，删除用户时，<code>HOME</code>目录保留</li>\n</ul></li>\n<li>查看用户所属组 <code>id [用户名]</code>\n<ul>\n<li>参数：用户名，被查看的用户，如果不提供则查看自身</li>\n</ul></li>\n<li>修改用户所属组<code>usermod -aG 用户组 用户名</code>\n，将指定用户加入指定用户组</li>\n</ul>\n<p><strong><code>getent</code></strong></p>\n<p>使用<code>getent</code> 命令，可以查看当前系统中有哪些用户。</p>\n<p>语法 <code>getent passwd</code></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2000.20.13.png\"\nalt=\"截屏2023-12-29 00.20.13\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 00.20.13</figcaption>\n</figure>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-29 00.21.25.png\" alt=\"截屏2023-12-29 00.21.25\" style=\"zoom:50%;\" /></p>\n<h4 id=\"查看权限控制信息\">3.3.查看权限控制信息</h4>\n<p><strong>认知权限信息</strong></p>\n<p>通过<code>ls -l</code>可以以列表形式查看内容，并显示权限细节</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-12-29 00.24.17.png\" alt=\"截屏2023-12-29 00.24.17\" style=\"zoom:50%;\" /></p>\n<ul>\n<li>序号1，表示文件、文件夹的权限控制信息</li>\n<li>序号2，表示文件、文件夹所属用户</li>\n<li>序号3，表示文件、文件夹所属用户组</li>\n</ul>\n<p>解析序号1，权限细节，权限细节总共分为10个槽位</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2000.31.57.png\"\nalt=\"截屏2023-12-29 00.31.57\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 00.31.57</figcaption>\n</figure>\n<p><strong>rwx</strong></p>\n<ul>\n<li>r表示读权限</li>\n<li>w表示写权限</li>\n<li>x表示执行权限</li>\n</ul>\n<p>针对文件、文件夹的不同，rwx的含义有细微差别</p>\n<ul>\n<li>r，针对文件可以查看文件内容\n<ul>\n<li>针对文件夹，可以查看文件夹内容，如<code>ls</code>命令</li>\n</ul></li>\n<li>w，针对文件表示可以修改此文件\n<ul>\n<li>针对文件夹，可以在文件夹内：创建、删除、改名等操作</li>\n</ul></li>\n<li>x，针对文件表示可以将文件作为程序执行\n<ul>\n<li>针对文件夹，表示可以更改工作目录到此文件夹，即<code>cd</code>进入</li>\n</ul></li>\n</ul>\n<h4 id=\"chmod命令\">3.4.<code>chmod</code>命令</h4>\n<p>我们可以使用<code>chmod</code>命令，修改文件、文件夹的权限信息。</p>\n<p>注意⚠️，只有文件、文件夹的所属用户或root用户可以修改</p>\n<p>语法：<code>chmod [-R] 权限 文件或文件夹</code></p>\n<ul>\n<li>选项：<code>-R</code> ，对文件夹内的全部内容应用同样的操作</li>\n</ul>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2001.13.16.png\"\nalt=\"截屏2023-12-29 01.13.16\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 01.13.16</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2001.25.39.png\"\nalt=\"截屏2023-12-29 01.25.39\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 01.25.39</figcaption>\n</figure>\n<p>命令：<code>chmod [-R] *** 文件、文件夹</code></p>\n<h4 id=\"chown-命令\">3.5.<code>chown</code> 命令</h4>\n<p>使用 <code>chown</code>\n命令，可以修改文件、文件夹的所属用户和用户组</p>\n<p>普通用户无法修改所属为其它用户或组，所以此命令只适用于root用户执行</p>\n<p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p>\n<ul>\n<li>选项，<code>-R</code>\n，同<code>chmod</code>，对文件夹内全部内容应用相同规则</li>\n<li>选项，用户，修改所属用户</li>\n<li>选项，用户组，修改所属用户组</li>\n<li><code>:</code> 用于分隔用户和用户组</li>\n</ul>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2001.35.41.png\"\nalt=\"截屏2023-12-29 01.35.41\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 01.35.41</figcaption>\n</figure>\n<h3 id=\"linux操作\">4.Linux操作</h3>\n<h4 id=\"各类小技巧快捷键\">4.1.各类小技巧快捷键</h4>\n<p><code>ctrl+c</code>强制停止</p>\n<ul>\n<li>Linux某些程序的运行，如果想要强制停止它，可以使用快捷键<code>ctrl+c</code></li>\n<li>命令输入错误，也可以通过快捷键<code>ctrl+c</code>，退出当前输入，重新输入</li>\n</ul>\n<p><code>ctrl+d</code>退出或登出</p>\n<ul>\n<li>可以通过快捷键：<code>ctrl+d</code>，退出账户的登录</li>\n<li>或者退出某些特定程序的专属页面</li>\n</ul>\n<p>⚠️：不能用于退出<code>vi/vim</code></p>\n<p><code>history</code>历史命令搜索</p>\n<ul>\n<li>可以通过<code>history</code>命令，查看历史输入过的命令</li>\n<li>可以通过：<code>!</code>命令前缀，自动执行上一次匹配前缀的命令</li>\n<li>可以通过快捷键：<code>ctrl+r</code>，输入内容去匹配历史命令\n<ul>\n<li>如果搜索到的内容是你需要的，那么：\n<ul>\n<li>回车键可以直接执行</li>\n<li>键盘左右键，可以得到此命令（不执行）</li>\n</ul></li>\n</ul></li>\n</ul>\n<p><strong>光标移动快捷键</strong></p>\n<ul>\n<li><code>ctrl+a</code>，跳到命令开头</li>\n<li><code>ctrl+e</code>，跳到命令结尾</li>\n<li><code>ctrl+键盘左键</code> ，向左跳一个单词</li>\n<li><code>ctrl+键盘右键</code>，向右跳一个单词</li>\n</ul>\n<h4 id=\"软件安装\">4.2.软件安装</h4>\n<h5 id=\"yum为centos系统安装软件\">4.2.1.\n<code>yum</code>为CentOS系统安装软件</h5>\n<p>操作系统安装软件有许多方式，一般分为：</p>\n<ul>\n<li>下载安装包自行安装</li>\n<li>系统内应用商店安装</li>\n</ul>\n<p><code>yum命令</code></p>\n<p><code>yum</code>:RPM包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题。</p>\n<p>语法：<code>yum [-y] [install | remove | search] 软件名称</code></p>\n<ul>\n<li>选项：<code>-y</code>，自动确认，无需手动确认安装或卸载过程</li>\n<li><code>install</code>：安装</li>\n<li><code>remove</code>：卸载</li>\n<li><code>search</code>：搜素</li>\n</ul>\n<p><code>yum</code>命令需要root权限，可以<code>su</code>切换到root，或使用<code>sudo</code>提权。<code>yum</code>命令需要联网。</p>\n<h5 id=\"apt为ubuntu安装软件\">4.2.2.<code>apt</code>为Ubuntu安装软件</h5>\n<p>前面学习的各类Linux命令，都是通用的。但是软件安装，CentOs系统和Ubuntu是使用不同的包管理器。centos使用yum管理器，Ubuntu使用apt管理器通过前面学习的WSL环境，我们可以得到Ubuntu运行环境。</p>\n<p>语法：<code>apt [-y] [install | remove | search] 软件名称</code></p>\n<p>用法和<code>yum</code>一致，同样需要root杈限</p>\n<ul>\n<li>﻿﻿<code>apt install wget</code>, 安装wget</li>\n<li>﻿﻿<code>apt remove wget</code>,移除wget</li>\n<li>﻿﻿<code>apt search wget</code>,搜索wget</li>\n</ul>\n<h4\nid=\"systemctl控制软件启动关闭\">4.3.<code>systemctl</code>控制软件启动关闭</h4>\n<p>Linux系统很多软件(内置或第三方）均支持使用systemct命令控制：启动、停止、开机自启。能够被systemctl管理的软件，一般也称之为：服务。</p>\n<p>语法：<code>systemctl start | stop | status | enable | disable 服务名</code></p>\n<ul>\n<li>start 启动</li>\n<li>stop 关闭</li>\n<li>status 查看状态</li>\n<li>enable 开启开机自启</li>\n<li>disable 关闭开机自启</li>\n</ul>\n<p>除了内置的服务外，部分第三方软件安装后，如果它们内部有服务，也可以通过<code>systemctl</code>进行控制。</p>\n<h4 id=\"ln命令创建软链接\">4.4.<code>ln</code>命令创建软链接</h4>\n<p>在系统中创建软链接，可以将文件、文件夹链接到其它位置。</p>\n<p>类似Windows系统中的《快捷方式》</p>\n<p>语法：<code>In -s 参数1 参数2</code></p>\n<ul>\n<li><code>﻿-s</code>选项，创建软连接</li>\n<li><code>﻿参数1</code>：被链接的文件或文件夹</li>\n<li><code>﻿参数2</code>：要链接去的目的地</li>\n</ul>\n<p>实例：</p>\n<ul>\n<li>﻿﻿<code>In -s /etc/yum.conf ~/yum.conf</code></li>\n<li>﻿﻿<code>﻿﻿In -s /etc/yum ~/yum</code></li>\n</ul>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2015.10.21.png\"\nalt=\"截屏2023-12-29 15.10.21\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 15.10.21</figcaption>\n</figure>\n<h4 id=\"ip地址和主机名\">4.5.IP地址和主机名</h4>\n<p><strong>IP地址</strong></p>\n<p>每一台联网的电脑都会有一个地址，用于和其它计算机进行通讯</p>\n<p>IP地址主要有2个版本，V4版本和V6版本（V5很少用，课程暂不涉及）</p>\n<p>IPV4版本的地址格式是：a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101就是一个标准的IP地址</p>\n<p>可以通过命令：<code>ifconfig</code>，\n查看本机的ip地址，如无法使用<code>ifconfig</code>命令，可以安装：<code>yum-y install net-tools</code></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2015.23.44.png\"\nalt=\"截屏2023-12-29 15.23.44\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 15.23.44</figcaption>\n</figure>\n<p><strong>特殊IP地址</strong></p>\n<ul>\n<li><code>127.0.0.1</code> ，这个IP地址用于指代本机</li>\n<li><code>0.0.0.0</code>，特殊IP地址\n<ul>\n<li>可以用来指代本机</li>\n<li>可以在端口绑定中用来确定绑定关系</li>\n<li>在一些IP地址限制中，表示所有IP的意思，如放行规则设置为<code>0.0.0.0</code>，表示允许任意IP访问。</li>\n</ul></li>\n</ul>\n<p><strong>域名解析</strong></p>\n<p>IP地址实在是难以记忆，有没有什么办法可以通过主机名或替代的字符地址去代替数宇化的IP地址呢？</p>\n<p>实际上，我们一直都是通过宇符化的地址去访问服务器，很少指定IP地址</p>\n<p>比如，我们在浏览器内打开：www.baidu.com，会打开百度的网址</p>\n<p>其中，www.baidu.com，是百度的网址，我们称之为：域名</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2015.50.17.png\"\nalt=\"截屏2023-12-29 15.50.17\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 15.50.17</figcaption>\n</figure>\n<p><strong>固定IP</strong></p>\n<p>当前我们虛拟机的Linux操作系统，其1P地址是通过DHGP服务获取的。</p>\n<p>DHCP：动态获取(P地址，即每汉重启设备后都会获取一次，可能导致1卩地址频繁变更</p>\n<p>原因1：办公电脑IP地址变化无所谓，但是我们要远程连接到Linux系统，如果IP地址经常变化我们就要频繁修改适配很麻</p>\n<p>烦</p>\n<p>原因2：在刚刚我们配置了虚拟机IP地址和主机名的映射，如果1P频繁更改，我们也需要频繁更新映射关系</p>\n<p>综上所述，我们需要1P地址固定下来，不要变化了。</p>\n<h4 id=\"网络请求和下载\">4.6.网络请求和下载</h4>\n<p>可以通过<code>ping</code>命令，检查指定的网络服务器是否是可连通状态</p>\n<p>语法：<code>ping [-c num] ip或主机名</code></p>\n<ul>\n<li>选项：<code>-c</code>，检查的次数，不使用<code>-c</code>选项，将无限次数持续检查</li>\n<li>参数：<code>-ip或主机名</code>\n，被检查的服务器的ip地址或主机名地址</li>\n</ul>\n<p>wget是非交互式的文件下载器，可以在命令行内下载网络文件</p>\n<p>语法：<code>wget [-b] url</code></p>\n<ul>\n<li>﻿选项：<code>-b</code>，可选，后台下载，会将日志写入到当前工作目录的wget-log文件</li>\n<li>﻿参数：<code>url</code>，下载链接</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li><p>下载apache-hadoop\n3.3.0版本：<code>wget http://archive.apache.org/ dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz</code></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2016.50.51.png\"\nalt=\"截屏2023-12-29 16.50.51\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 16.50.51</figcaption>\n</figure></li>\n<li><p>在后台下载：<code>wget -b http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz</code></p></li>\n<li><p>通过<code>tail</code>命令可以监控后台下载进度：<code>tail -f wget-log</code></p></li>\n</ul>\n<p><code>curl</code>命令</p>\n<p><code>curl</code>可以发送<code>http</code>网络请求，可用于：下载文件、获取信息等</p>\n<p>语法：<code>curl [-O] url</code></p>\n<ul>\n<li>选项：<code>-O</code>，用于下载文件，当<code>url</code>是下载链接时，可以使用此选项保存文件</li>\n<li>参数：<code>url</code>，要发起请求的网络地址</li>\n</ul>\n<h4 id=\"网络传输\">4.7.网络传输</h4>\n<p>端口</p>\n<p>端口，是设备与外界通讯交流的出入口。端口可以分为：物理端口和虛拟端口两类</p>\n<ul>\n<li>物理端口：叉可称之为接口，是可见的端口，如USB接口，尺J45网口，HDM端口等</li>\n<li>虛拟端口：是指计算机内部的端口，是不可见的，是用来操作系统和外部进行交互使用的</li>\n</ul>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2020.01.09.png\"\nalt=\"截屏2023-12-29 20.01.09\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 20.01.09</figcaption>\n</figure>\n<p>端口（虚拟）</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2020.03.36.png\"\nalt=\"截屏2023-12-29 20.03.36\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 20.03.36</figcaption>\n</figure>\n<p>如上图所示，两台计算机可以通过IP地址来进行互相之间的访问，但是，两台计算机之间的服务之间如何进行互相访问？如果只通过IP地址，那么就不太精确，所以我们可以通过虚拟出来的端口来进行访问。</p>\n<p>Linux系统是一个超大号小区，可以支持65535个端口，这6万多个端口分为3类进行使用：</p>\n<ul>\n<li>公认端口：1～1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口</li>\n<li>注册端口：1024～49151，通常可以随意使用，用于松散的绑定一些程序、服务</li>\n<li>动态端口：49152～65535，通常不会固定绑定程序，二十当程序对外进行网络链接时，用于临时使用</li>\n</ul>\n<p>查看端口占用</p>\n<p>可以通过Linux命令去查看端口的占用情况</p>\n<ul>\n<li>使用<code>nmap</code>命令，安装<code>nmap:yum -y install nmap</code></li>\n</ul>\n<p>语法：<code>nmap 被查看的IP地址</code></p>\n<p>可以通过<code>netstat</code>命令，查看指定端口的占用情况</p>\n<p>语法：<code>netstat -anp|grep 端口号</code></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2020.31.34.png\"\nalt=\"截屏2023-12-29 20.31.34\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 20.31.34</figcaption>\n</figure>\n<h4 id=\"进程管理\">4.8.进程管理</h4>\n<p>程序运行在操作系统中，是被操作系统所管理的。</p>\n<p>为管理运行的程序，每一个程序在运行的时候，便被操作系统注册为系统中的一个：进程</p>\n<p>并会为每一个进程都分配一个独有的：进程1D（进程号）</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2021.51.55.png\"\nalt=\"截屏2023-12-29 21.51.55\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 21.51.55</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.07.06.png\"\nalt=\"截屏2023-12-29 22.07.06\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.07.06</figcaption>\n</figure>\n<p>在Linux中，可以通过<code>kill</code>命令关闭进程。</p>\n<p>语法：<code>kill [-9] 进程ID</code></p>\n<p>选项：<code>-9</code>，表示强制关闭进程。不使用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制。</p>\n<h4 id=\"主机状态监控\">4.9.主机状态监控</h4>\n<p><strong>查看系统资源占用</strong></p>\n<p>可以通过<code>top</code>命令查看CPU、内存使用情况，类似Windows的任务管理器。默认每5秒刷新一次，语法：直接输入<code>top</code>即可。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.24.51.png\"\nalt=\"截屏2023-12-29 22.24.51\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.24.51</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.30.16.png\"\nalt=\"截屏2023-12-29 22.30.16\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.30.16</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.32.06.png\"\nalt=\"截屏2023-12-29 22.32.06\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.32.06</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.37.39.png\"\nalt=\"截屏2023-12-29 22.37.39\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.37.39</figcaption>\n</figure>\n<p>磁盘信息监控</p>\n<p>使用<code>df</code>命令，可以查看磁盘的使用情况</p>\n<p>语法：<code>df [-h]</code></p>\n<p>选项：<code>-h</code> ，以更加人性化的单位显示</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.48.24.png\"\nalt=\"截屏2023-12-29 22.48.24\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.48.24</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.49.59.png\"\nalt=\"截屏2023-12-29 22.49.59\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.49.59</figcaption>\n</figure>\n<p><strong>网络状态监控</strong></p>\n<p>可以使用<code>sar</code>命令查看网络的相关统计（<code>sar</code>命令非常复杂，这里仅简单用于统计网络）</p>\n<p>语法：<code>sar -n DEV nums1 num2</code></p>\n<p>选项：<code>-n</code>，查看网络，<code>DEV</code>表示查看网络接口，<code>num1</code>：刷新间隔（不填就查看一次结束）,<code>num2</code>：查看次数（不填无限次数）</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2023-12-29%2022.55.30.png\"\nalt=\"截屏2023-12-29 22.55.30\" />\n<figcaption aria-hidden=\"true\">截屏2023-12-29 22.55.30</figcaption>\n</figure>\n<h4 id=\"环境变量\">4.10.环境变量</h4>\n<p><strong>环境变量的作用</strong></p>\n<p>在讲解which命令的时候，我们知道使用的一系列命令其实本质上就是一个个的可执行程序。比如，cd命令的本体就是：<code>/usr/bin/cd</code>\n这个程序文件。</p>\n<p>那么为什么，无论当前工作目录在哪里，都能够执行:<code>/usr/bin/cd</code>\n这个程序呢？这就是环境变量的作用。</p>\n<p>环境变量是操作系统(windows、Linux、Mac)在运行的时候，记录的一些关键性信息，用以辅助系统运行。在Linux系统中执行：env命令即可查看当前系统中记录的环境变量环境变量是一种Keyvalue型结构，即名称和值，如下图：</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-01-01%2014.03.30.png\"\nalt=\"截屏2024-01-01 14.03.30\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 14.03.30</figcaption>\n</figure>\n<p>无论当前工作目录是什么，都能执行<code>/usr/bin/cd</code>这个程序，这个就是借助环境变量中<code>PATH</code>这个项目的值来做到的。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-01-01%2014.06.32.png\"\nalt=\"截屏2024-01-01 14.06.32\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 14.06.32</figcaption>\n</figure>\n<p><code>PATH</code>记录了系统中执行任何命令的搜索路径，如上图记录了（路径之间以<code>:</code>隔开）：</p>\n<ul>\n<li><code>/usr/local/bin</code></li>\n<li><code>/usr/bin</code></li>\n<li><code>/usr/local/sbin</code></li>\n<li><code>/usr/sbin</code></li>\n<li><code>/home/itheima/.local/bin</code></li>\n<li><code>/home/itheima/bin</code></li>\n</ul>\n<p>当执行任何命令，都会按照顺序，从上述路径中搜索要执行的程序的本体。比如要执行<code>cd</code>命令，就从第二个目录<code>/usr/bin</code>中搜索到了<code>cd</code>命令，并执行。</p>\n<p><strong><code>$</code>符号的作用</strong></p>\n<p>在Linux系统中，<code>$</code>符号被用于取\"变量\"的值。环境变量记录的信息，除了给操作系统自己使用外，如果我们想要取用，也可以使用。取得环境变量的值就可以通过语法：<code>$环境变量名</code>来取得。</p>\n<p>比如：<code>echo $PATH</code></p>\n<p>就可以取得<code>PATH</code>这个环境变量的值，并通过<code>echo</code>语句输出出来。</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-01-01%2014.18.49.png\"\nalt=\"截屏2024-01-01 14.18.49\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 14.18.49</figcaption>\n</figure>\n<p>又或者：<code>echo $&#123;PATH&#125;ABC</code></p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-01-01%2014.19.22.png\"\nalt=\"截屏2024-01-01 14.19.22\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 14.19.22</figcaption>\n</figure>\n<p>当和其他内容混合在一起的时候，可以通过<code>&#123;&#125;</code>来标注取的变量是谁。\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-01-01%2014.26.56.png\"\nalt=\"截屏2024-01-01 14.26.56\" /></p>\n<p><strong>自定义环境变量PATH</strong></p>\n<p>环境变量PATH这个项目里面记录了系统执行命令的搜索路径。这些搜索路径我们也可以自行添加到PATH中去。</p>\n<p>测试：</p>\n<ul>\n<li>﻿在当前HOME目录内创建文件夹，myenv，在文件夹内创建文件mkhaha</li>\n<li>﻿通过vim编辑器，在mkhaha文件内填入：echo 哈哈哈哈哈</li>\n</ul>\n<p>完成上述操作后，随意切换工作目录，执行mkhaha命令尝试一下，会发现无法执行</p>\n<p>修改PATH的值</p>\n<p>临时修改PATH:export\nPATH=$PATH：/home/itheima/myenv，再次执行mkhaha，无论在哪里都能执行或格expotPATI=PATH:/om管里面退录的邊氁瑞的瘦缘路径文件中去</p>\n<h4 id=\"linux文件的压缩和解压\">4.11.Linux文件的压缩和解压</h4>\n<p><strong>压缩格式</strong></p>\n<p>市面上有非常多的压缩格式</p>\n<ul>\n<li>zip格式：Linux、Windows、macOS，常用</li>\n<li>7zip：Windows系统常用</li>\n<li>rar：Windows系统常用</li>\n<li>tar：Linux、MacOS常用</li>\n<li>gzip：Linux、MacOS常用</li>\n</ul>\n<p><strong><code>tar</code>命令</strong></p>\n<p>Linux和Mac系统常用有2种压缩格式，后级名分别是：</p>\n<ul>\n<li><code>tar</code>，称之为<code>tarball</code>，归档文件，即简单的将文件组装到一个<code>.tar</code>的文件内，并没有太多文件体积的减少，仅仅是简单的封装</li>\n<li><code>gz</code>,也常见为,<code>.tar.gz</code>,<code>gzip</code>格式压缩文件，即使用gzip压缩算法将文件压缩到一个文件内，可以极大的减少压缩后的体积。</li>\n</ul>\n<p>针对这两种格式，使用<code>tar</code>命令均可以进行压缩和解压缩的操作</p>\n<p>语法：<code>tar [-c -v -x -f -z -C〕参数1参数2 ... 参数N</code></p>\n<ul>\n<li><p>﻿<code>-c</code>，创建压缩文件，用于压缩模式</p></li>\n<li><p>﻿<code>﻿-v</code>,显示压缩、解压过程，用于查看进度</p></li>\n<li><p>﻿<code>-x</code>，解压模式</p></li>\n<li><p>﻿<code>-f</code>，要创建的文件，或要解压的文件，-f选项必须在所有选项中位置处于最后一个</p></li>\n<li><p>﻿<code>-z,gzip</code>模式，不使用-z就是普通的tarball格式</p></li>\n<li><p>﻿<code>-C</code> 选择解压的目的地，用于解压模式</p></li>\n</ul>\n<p><code>tar命令压缩</code></p>\n<p><code>tar</code>的常用组合为：</p>\n<ul>\n<li><code>tar -cvf test.tar 1 1.txt 2.txt 3.txt</code>\n将<code>1.txt 2.txt 3.txt</code>压缩到<code>test.tar</code>文件内</li>\n<li><code>tar -zcvf test.tar.gz 1.txt 2.txt 3.txt</code>将<code>1.txt 2.txt 3.txt</code>压缩到<code>test.tar.gz</code>文件内，使用<code>gzip</code>模式。</li>\n</ul>\n<p>⚠️注意：</p>\n<ul>\n<li><code>-z</code>选项如果使用，一般处于选项的第一位</li>\n<li><code>-f</code>则必须在最后一个</li>\n</ul>\n<p><strong><code>tar</code>解压</strong></p>\n<p>常用的<code>tar</code>解压组合</p>\n<ul>\n<li><code>tar -xvf test.tar</code> 解压<code>test.tar</code>\n，将文件解压至当前目录</li>\n<li><code>tar -xvf test.tar -C /home/itheima</code>\n解压<code>test.tar</code>，将文件解压至指定目录\n(<code>/home/itheima</code>)</li>\n<li><code>tar -zxvf test.tar.gz -C /home/itheima</code>\n以<code>Gzip</code> 模式解压\n<code>test.tar.gz</code>，将文件解压至指定目录内(<code>/home/itheima</code>)</li>\n</ul>\n<p><strong><code>zip</code>命令压缩文件</strong></p>\n<p>可以使用<code>zip</code>命令，压缩文件为<code>zip</code>压缩包</p>\n<p>语法：<code>zip [-r] 参数1 参数2 ... 参数N</code></p>\n<p>•<code>-r</code>，被压缩的包含文件夹的时候，需要使用<code>-r</code>选项，和<code>rm</code>、<code>cp</code>等命令的<code>-r</code>效果一致</p>\n<p>示例：</p>\n<p>• <code>zip test.zip a.txt b.txt c.txt</code></p>\n<p>将<code>a.txt b.txt c.txt</code>压缩到<code>test.zip</code>文件内</p>\n<p>•<code>zip -r test.zip test itheima a.txt</code></p>\n<p>将<code>test、itheima</code>两个文件夹和<code>a.tx</code>t文件，压缩到<code>test.zip</code>文件内</p>\n<figure>\n<img\nsrc=\"/Users/huangqiuzhao/Library/Application%20Support/typora-user-images/截屏2024-01-01%2019.57.45.png\"\nalt=\"截屏2024-01-01 19.57.45\" />\n<figcaption aria-hidden=\"true\">截屏2024-01-01 19.57.45</figcaption>\n</figure>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2023/06/08/papper/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-1/",
            "url": "https://chnhqz.github.io/2023/06/08/papper/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-1/",
            "title": "论文阅读",
            "date_published": "2023-06-08T06:26:00.000Z",
            "content_html": "\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2023/06/07/test/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/",
            "url": "https://chnhqz.github.io/2023/06/07/test/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/",
            "title": "我的第一篇博客文章",
            "date_published": "2023-06-07T10:34:09.000Z",
            "content_html": "<p><strong>YouTube</strong></p>\n<ol type=\"1\">\n<li>morning</li>\n<li>niha</li>\n<li>hell</li>\n</ol>\n<p><span class=\"math display\">\\[a_1\\]</span></p>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2023/06/07/test/hello-world/",
            "url": "https://chnhqz.github.io/2023/06/07/test/hello-world/",
            "title": "Hello World",
            "date_published": "2023-06-07T10:29:13.923Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very\nfirst post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for\nmore info. If you get any problems when using Hexo, you can find the\nanswer in <a\nhref=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or\nyou can ask me on <a\nhref=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\">Quick Start</h2>\n<p>hello ### Create a new post</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int </span><br></pre></td></tr></table></figure>\n<h3 id=\"run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        },
        {
            "id": "https://chnhqz.github.io/2023/05/22/papper/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/",
            "url": "https://chnhqz.github.io/2023/05/22/papper/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/",
            "title": "",
            "date_published": "2023-05-22T11:36:53.668Z",
            "content_html": "<h3 id=\"如何读文献\">如何读文献</h3>\n<h4\nid=\"每一篇文献自带了一份通往同一领域相关论文的地图它叫做参考文献\">每一篇文献自带了一份通往同一领域相关论文的地图，它叫做“参考文献”</h4>\n<ul>\n<li>背景介绍部分的参考文献，告诉你这个领域为什么重要，这个研究问题为什么有意义。</li>\n<li>对于研究问题及相关研究部分的参考文献，告诉你之前都有谁做了什么相似/相关的工作</li>\n<li>实验设计、实验方法部分的参考文献，告诉你这种设计/方法最早来自何处</li>\n<li>数据讨论部分的参考文献，告诉你什么样已知的理论研究支持了这些假设和结论</li>\n<li>总结展望部分的参考文献，告诉你最新的综述有哪些、待解決的问题有哪些、最最近的研究有哪些</li>\n<li>实验部分的参考文献，告诉你这些实验操作最原始的出处在哪里</li>\n</ul>\n<h4\nid=\"读完文献至少应该能够回答的四个问题\">读完文献，至少应该能够回答的四个问题</h4>\n<ul>\n<li>这篇文章，到底在解决什么问题？（摘要、前言部分）</li>\n<li>这个问题为什么在这个领域重要？（前言部分）</li>\n<li>这些作者是怎么解决这个问题的？（具体的实验设计、优化部分）</li>\n<li>这个问题的解决有什么亮点、局限，有什么应用？（数据分析、应用展示、结论、展望部分）</li>\n</ul>\n<p>注意把握核心文献，那些被多次提及以及多次引用的文献。</p>\n<p>还有一点是几乎很多人的读文献视频都没讲过的，但是似乎很多人都知道的事情：</p>\n<p>对于重要的研究性文献，你应该也看看它们的非正文部分，包括注释、脚注、以及supporting</p>\n<p>information（就是包含实验部分的附属文件），因为这些部分往往会包含一些作者不太想告诉你但是又不得不告诉你的关于这篇文章的事实，比如说这篇文章的局限性、缺点、尚且解决不了的一部分问题等等。</p>\n<ul>\n<li>﻿除了读新文献之外，还有一种文献非常值得读，那就是那些可能与你的研究没有非常直接的关联，但叉有一定关联，一定不算做你研究领域“核心文献〞，而且通常发在那些你看不起的“低影响因子小期\n刊〞，通常都是文字很多图很少，你甚至没有听过作者名字的，老文献</li>\n<li>﻿“现在的科研工作者，很多都是挖尸体的人〞 大约等于\n“你不站在巨人的肩膀上，如何能够得着夜空中的明月”。</li>\n<li>﻿提供一个有用的思路：你可以通过一篇文章中引用的一篇老文献找到通讯作者，然后看看这个“你没听过名字的〞教授一辈子学术生涯都做了什么，你往往会有意想不到的收获</li>\n</ul>\n<h3 id=\"文献列表\">文献列表</h3>\n<p>[1]\n吴英杰．隐私保护数据发布：模型与算法[M]．北京：清华大学出版社，2016</p>\n<p>[2] <a\nhref=\"https://www.zhihu.com/search?q=周志华&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2382359427%7D\">周志华</a>．机器学习\n[ M]．北京：清华大学出版社 2016</p>\n<p>[3] 刘俊旭 , <a\nhref=\"https://www.zhihu.com/search?q=孟小峰&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2382359427%7D\">孟小峰</a>\n. 机器学习的隐私保护研究综述 [J]. <a\nhref=\"https://www.zhihu.com/search?q=计算机研究与发展&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2382359427%7D\">计算机研究与发展</a>\n, 2020, 57( 2): 346</p>\n<p>[4] 熊平 , <a\nhref=\"https://www.zhihu.com/search?q=朱天清&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2382359427%7D\">朱天清</a>\n, 王晓峰 . 差分隐私保护及其应用 [J]. <a\nhref=\"https://www.zhihu.com/search?q=计算机学报&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2382359427%7D\">计算机学报</a>\n,2014, 37(1): 101 122</p>\n<h4 id=\"dp-theory\">DP theory</h4>\n<ul>\n<li>Gaussian differential privacy <a\nhref=\"https://arxiv.org/pdf/1905.02383\">[paper]</a> by Jinshuo Dong,\nAaron Roth, Weijie J. Su. 2019</li>\n<li>Average-Case Averages: Private Algorithms for Smooth Sensitivity and\nMean Estimation<a\nhref=\"https://arxiv.org/pdf/1906.02830.pdf\">[paper]</a> by Mark Bun and\nThomas Steinke. 2019</li>\n<li>New Differentially Private Algorithms for Learning Mixtures of\nWell-Separated Gaussians<a\nhref=\"https://arxiv.org/pdf/1909.03951.pdf\">[paper]</a> by Gautam\nKamath, Or Sheffet, Vikrant Singhal, Jonathan Ullman. 2019</li>\n<li>Private Hypothesis Selection <a\nhref=\"https://arxiv.org/pdf/1905.13229.pdf\">[paper]</a> by Mark Bun,\nGautam Kamath, Thomas Steinke,Steven Wu. 2019</li>\n<li>Privacy Amplification by Iteration <a\nhref=\"https://arxiv.org/abs/1808.06651\">[paper]</a> by Vitaly Feldman,\nIlya Mironov, Kunal Talwar, Abhradeep Thakurta. 2018</li>\n<li>pMSE Mechanism: Differentially Private Synthetic Data with Maximal\nDistributional Similarity <a\nhref=\"https://arxiv.org/pdf/1805.09392.pdf\">[paper]</a> by Joshua Snoke\nand Aleksandra Slavkovic. 2018</li>\n<li>Differentially Private Continual Learning <a\nhref=\"https://arxiv.org/pdf/1902.06497.pdf\">[paper]</a> by S.Farquhar\nand Yarin Gal. 2018</li>\n<li>Individual Fairness Under Composition <a\nhref=\"http://www.fatml.org/media/documents/individual_fairness_under_composition.pdf\">[paper]</a>\nby Cynthia Dwork and Christina Ilvento. 2018<br />\n</li>\n<li>Differentially Private Fair Learning <a\nhref=\"https://arxiv.org/abs/1812.02696\">[paper]</a> by Matthew\nJagielski, Michael Kearns, Jieming Mao, Alina Oprea, Aaron Roth, Saeed\nSharifi-Malvajerdi, Jonathan Ullman. 2018<br />\n</li>\n<li>Differentially Private False Discovery Rate Control <a\nhref=\"https://arxiv.org/abs/1807.04209\">[paper]</a> by Cynthia Dwork,\nWeijie J. Su, Li Zhang. 2018<br />\n</li>\n<li>Accuracy First: Selecting a Differential Privacy Level for\nAccuracy-Constrained ERM <a\nhref=\"https://arxiv.org/abs/1705.10829\">[paper]</a> <a\nhref=\"https://github.com/steven7woo/Accuracy-First-Differential-Privacy\">[code]</a>\nby Katrina Ligett, Seth Neel, Aaron Roth, Bo Waggoner, Z. Steven Wu.\n2017<br />\n</li>\n<li>Penalizing Unfairness in Binary Classification <a\nhref=\"https://arxiv.org/abs/1707.00044\">[paper]</a> by Yahav Bechavod,\nKatrina Ligett. 2017<br />\n</li>\n<li>Concentrated Differential Privacy <a\nhref=\"https://arxiv.org/abs/1603.01887\">[paper]</a> by Cynthia Dwork,\nGuy N. Rothblum. 2016<br />\n</li>\n<li>Protecting Privacy when Disclosing Information: k-Anonymity and Its\nEnforcement through Generalization and Suppression <a\nhref=\"https://epic.org/privacy/reidentification/Samarati_Sweeney_paper.pdf\">[paper]</a>\nby Pierangela Samarati and Latanya Sweeney</li>\n</ul>\n<h4 id=\"local-differential-privacy\">Local Differential Privacy</h4>\n<ul>\n<li>Answering multi-dimensional analytical queries under local\ndifferential privacy <a\nhref=\"https://par.nsf.gov/servlets/purl/10194803\">[paper]</a> by Tianhao\nWang, Bolin Ding, Jingren Zhou, Cheng Hong, Zhicong Huang, Ninghui Li,\nSomesh Jha. 2019</li>\n<li>Locally Private Gaussian Estimation <a\nhref=\"https://arxiv.org/abs/1811.08382\">[paper]</a> by Matthew Joseph,\nJanardhan Kulkarni, Jieming Mao, Zhiwei Steven Wu. 2019<br />\n</li>\n<li>Local Differential Privacy for Evolving Data <a\nhref=\"https://arxiv.org/abs/1802.07128\">[paper]</a> by Matthew Joseph,\nAaron Roth, Jonathan Ullman, Bo Waggoner. 2018<br />\n</li>\n<li>Privacy at Scale: Local Differential Privacy in Practice <a\nhref=\"http://dimacs.rutgers.edu/~graham/pubs/papers/ldptutorial.pdf\">[paper]</a>\nby Graham Cormode, Somesh Jha, Tejas kulkarni, Ninghui Li, Divesh\nSrivastava, Tianhao Wang. 2018<br />\n</li>\n<li>Locally Private Gaussian Estimation <a\nhref=\"https://arxiv.org/abs/1811.08382\">[paper]</a> by Matthew Joseph,\nJanardhan Kulkarni, Jieming Mao, Zhiwei Steven Wu. 2018<br />\n</li>\n<li>Locally differentially private protocols for frequency estimation <a\nhref=\"https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-wang-tianhao.pdf\">[paper]</a>\nby Tianhao Wang, Jeremiah Blocki, Ninghui Li, Somesh Jha. 2017</li>\n</ul>\n<h4 id=\"image-privacy\">Image Privacy</h4>\n<ul>\n<li>Learning to Anonymize Faces for Privacy Preserving Action Detection\n<a\nhref=\"https://web.cs.ucdavis.edu/~yjlee/projects/eccv2018-privacy.pdf\">[paper]</a>\nby Zhongzheng Ren, Yong Jae Lee and Michael S.Ryoo. 2019</li>\n<li>Image Privacy Prediction Using Deep Neural Networks <a\nhref=\"https://arxiv.org/pdf/1903.03695.pdf\">[paper]</a> by Ashwini\nTonge, Cornelia Caragea. 2019</li>\n</ul>\n<h4 id=\"adversarial-examples-and-robustness\">Adversarial Examples and\nRobustness</h4>\n<ul>\n<li>A unified view on differential privacy and robustness to adversarial\nexamples <a href=\"https://arxiv.org/abs/1906.07982\">[paper]</a> by\nRafael Pinot, et al. 2019<br />\n</li>\n<li>Certified Robustness to Adversarial Examples with Differential\nPrivacy <a href=\"https://arxiv.org/abs/1802.03471\">[paper]</a> by\nMathias Lecuyer, Vaggelis Atlidakis, Roxana Geambasu, Daniel Hsu, Suman\nJana. 2018</li>\n</ul>\n<h4 id=\"privacy-and-generative-model\">Privacy and Generative Model</h4>\n<ul>\n<li>Generalization in Generative Adversarial Networks:A Novel\nPerspective from Privacy Protection <a\nhref=\"https://arxiv.org/pdf/1908.07882.pdf\">[paper]</a> by Bingzhe Wu\netc. 2019</li>\n<li>DP-CGAN : Differentially Private Synthetic Data and Label Generation\n<a\nhref=\"http://openaccess.thecvf.com/content_CVPRW_2019/papers/CV-COPS/Torkzadehmahani_DP-CGAN_Differentially_Private_Synthetic_Data_and_Label_Generation_CVPRW_2019_paper.pdf\">[paper]</a>\nby Peter Kairouz etc. 2019</li>\n<li>Siamese Generative Adversarial Privatizer for Biometric Data <a\nhref=\"https://arxiv.org/pdf/1804.08757.pdf\">[paper]</a> <a\nhref=\"https://github.com/WUT-ML/privacy\">[code]</a> by WUT and peter\nkairouz. 2018</li>\n<li>Generative Adversarial Models for Learning Private and Fair\nRepresentations(GAPF) <a\nhref=\"https://arxiv.org/abs/1807.05306\">[paper]</a> <a\nhref=\"https://github.com/cabreraalex/private-fair-GAN\">[code]</a> by\nChong Huang, Peter Kairouz, Lalitha Sankar. 2018</li>\n<li>Context-Aware Generative Adversarial Privacy(GAP) <a\nhref=\"https://arxiv.org/abs/1710.09549\">[paper]</a> by Chong Huang,\nPeter Kairouz, Xiao Chen, Lalitha Sankar, Ram Rajagopal. 2017<br />\n</li>\n<li>Differentially Private Generative Adversarial Networks for Time\nSeries, Continuous, and Discrete Open Data <a\nhref=\"https://arxiv.org/abs/1901.02477\">[paper]</a> by Lorenzo Frigerio,\nAnderson Santana de Oliveira, Laurent Gomez, Patrick Duverger.\n2018<br />\n</li>\n<li>Generative Adversarial Nets <a\nhref=\"https://arxiv.org/abs/1406.2661\">[paper]</a> by Ian J. Goodfellow,\nJean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil\nOzair, Aaron Courville, Yoshua Bengio. 2014</li>\n</ul>\n<h4 id=\"privacy-in-federated-learning\">Privacy in Federated\nLearning</h4>\n<ul>\n<li>Beyond Inferring Class Representatives: User-Level Privacy Leakage\nFrom Federated Learning <a\nhref=\"https://arxiv.org/pdf/1812.00535.pdf\">[paper]</a> by Zhibo Wang,\netc. 2019</li>\n<li>Exploiting Unintended Feature Leakage in Collaborative Learning <a\nhref=\"https://arxiv.org/pdf/1805.04049.pdf\">[paper]</a> <a\nhref=\"https://github.com/csong27/property-inference-collaborative-ml\">[code]</a>\nby Vitaly's group. 2019</li>\n<li>How To Backdoor Federated Learning <a\nhref=\"https://arxiv.org/abs/1807.00459\">[paper]</a> <a\nhref=\"https://github.com/ebagdasa/backdoor_federated_learning\">[code]</a>\nby Vitaly's group. 2018</li>\n<li>Deep Models Under the GAN: Information Leakage from Collaborative\nDeep Learning <a href=\"https://arxiv.org/abs/1702.07464\">[paper]</a> by\nBriland Hitaj, Giuseppe Ateniese, Fernando Perez-Cruz. 2017</li>\n</ul>\n<h4 id=\"private-ml\">Private ML</h4>\n<ul>\n<li>Towards practical differentially private convex optimization <a\nhref=\"http://www.omthakkar.com/papers/TPDPCO.pdf\">[paper]</a> by Roger\nIyengar, Joseph P Near, Dawn Song, Om Thakkar, Abhradeep Thakurta, Lun\nWang. 2019</li>\n<li>Bolt-on Differential Privacy for Scalable Stochastic Gradient\nDescent-based Analytics <a\nhref=\"https://dl.acm.org/doi/pdf/10.1145/3035918.3064047\">[paper]</a> by\nXi Wu, Fengan Li, Arun Kumar, Kamalika Chaudhuri, Somesh Jha, Jeffrey F\nNaughton. 2017</li>\n<li>Deep learning with differential privacy <a\nhref=\"https://arxiv.org/pdf/1607.00133.pdf%20\">[paper]</a> by Martin\nAbadi, Andy Chu, Ian Goodfellow, H Brendan McMahan, Ilya Mironov, Kunal\nTalwar, Li Zhang. 2016</li>\n<li>Learning with differential privacy: stability, learnability and the\nsufficiency and necessity of ERM principle <a\nhref=\"https://dl.acm.org/citation.cfm?id=3053465\">[paper]</a> by\nYu-Xiang Wang, Jing Lei, Stephen E.Fienberg. 2016<br />\n</li>\n<li>Privacy-Preserving Deep Learning <a\nhref=\"https://www.cs.cornell.edu/~shmat/shmat_ccs15.pdf\">[paper]</a> by\nReza Shokri and Vitaly Shmatikov.2015<br />\n</li>\n<li>Differential Privacy and Machine Learning: a Survey and Review <a\nhref=\"https://arxiv.org/abs/1412.7584\">[paper]</a> by Zhanglong Ji,\nZachary C. Lipton, Charles Elkan. 2014</li>\n</ul>\n<h4 id=\"privacy-in-mab\">Privacy in MAB</h4>\n<ul>\n<li>Privacy-Preserving Contextual Bandits <a\nhref=\"https://arxiv.org/pdf/1910.05299.pdf\">[paper]</a> by Facebook AI\nResearch. 2019</li>\n<li>Differentially Private Contextual Linear Bandits <a\nhref=\"https://arxiv.org/pdf/1810.00068.pdf\">[paper]</a> by Roshan\nShariff and Or Sheffet. 2018<br />\n</li>\n<li>Achieving Privacy in the Adversarial Multi-Armed Bandit <a\nhref=\"https://arxiv.org/abs/1701.04222\">[paper]</a> by Aristide C. Y.\nTossou, Christos Dimitrakakis. 2017<br />\n</li>\n<li>Differentially Private Policy Evaluation <a\nhref=\"https://arxiv.org/abs/1603.02010\">[paper]</a> by Borja Balle,\nMaziar Gomrokchi, Doina Precup. 2016<br />\n</li>\n<li>Algorithms for Differentially Private Multi-Armed Bandits <a\nhref=\"https://arxiv.org/abs/1511.08681\">[paper]</a> by Aristide Tossou,\nChristos Dimitrakakis. 2015<br />\n</li>\n<li>MAB problems <a\nhref=\"http://web.eecs.umich.edu/faculty/teneketzis/papers/MAB-Survey.pdf\">[paper]</a>\nby Aditya Mahajan and D.teneketzis<br />\n</li>\n<li>(Nearly) Optimal Differentially Private Stochastic Multi-Arm Bandits\n<a href=\"http://auai.org/uai2015/proceedings/papers/58.pdf\">[paper]</a>\nby Nikita Mishra and Abhradeep Thakurta<br />\n</li>\n<li>Taming the Monster: A Fast and Simple Algorithm for Contextual\nBandits <a\nhref=\"http://proceedings.mlr.press/v32/agarwalb14.pdf\">[paper]</a> by\nA.A, D.H, S.K, J.L, L.L, R.E.S</li>\n</ul>\n<h4 id=\"privacy-preserving-encrypted-neural-network\">Privacy-preserving\nEncrypted Neural Network</h4>\n<ul>\n<li>SHE: A Fast and Accurate Deep Neural Network for Encrypted Data <a\nhref=\"https://arxiv.org/abs/1906.00148\">[paper]</a> <a\nhref=\"https://github.com/safednn/SHE\">[code]</a> by Qian Lou, Lei Jiang.\n2019</li>\n<li>2P-DNN : Privacy-Preserving Deep Neural Networks Based on\nHomomorphic Cryptosystem <a\nhref=\"https://arxiv.org/abs/1807.08459\">[paper]</a> <a\nhref=\"https://github.com/zhustrong/pigstrong/tree/master/pigstrong\">[code]</a>\nby Qiang Zhu, Xixiang Lv. 2018</li>\n<li>ABY3 A Mixed Protocol Framework for Machine Learning <a\nhref=\"https://eprint.iacr.org/2018/403.pdf\">[paper]</a> by Payman\nMohassel, Peter Rindal . 2018</li>\n<li>Secureml: A system for scalable privacy-preserving machine learning\n<a\nhref=\"http://web.eecs.umich.edu/~mosharaf/Readings/SecureML.pdf\">[paper]</a>\nby Payman Mohassel, Yupeng Zhang. 2017</li>\n</ul>\n<h4 id=\"differential-privacy-tutorial\">Differential Privacy\nTutorial</h4>\n<ul>\n<li>For dummies <a\nhref=\"https://robertovitillo.com/2016/07/29/differential-privacy-for-dummies/\">[link]</a></li>\n<li>Emory University CS 573 Data Privacy and Security, Fall 2018 <a\nhref=\"http://www.cs.emory.edu/~lxiong/cs573/\">[course website]</a></li>\n<li>KDD 2018 Privacy tutorial <a\nhref=\"https://sites.google.com/view/kdd2018privacytutorial\">[link]</a></li>\n<li>KDD 2018 Privacy at scale: Local Differential Privacy in Practice\n[[link]](</li>\n</ul>\n<h3 id=\"年6月份文献阅读\">2023年6月份文献阅读</h3>\n<h4\nid=\"differential-privacy-protection-on-weighted-graph-in-wireless-networks\">Differential\nprivacy protection on weighted graph in wireless networks</h4>\n<p>无线网络中加权图差分隐私保护</p>\n<p>差分隐私（differential\nprivacy）是一种隐私保护框架，可以在涉及个人数据的情况下，对敏感信息进行保护。差分隐私的基本思想是，对于输入数据中的任何一条记录，其存在或不存在对最终输出结果的影响应该很小。因此，在加噪声时使用随机化技术来保护数据隐私，同时通过引入随机扰动等方法来减少攻击者获取敏感信息的概率。差分隐私已被广泛应用于数据挖掘、机器学习、社交网络和隐私保护等领域。差分隐私是一种隐私保护的概念和技术，旨在对个体的敏感数据进行隐私保护，同时保持对整体数据的有意义的统计分析。差分隐私的核心思想是通过向个体数据添加噪声来保护隐私，确保即使在具有所有其他数据的情况下，个体的隐私仍然得到保护。具体而言，差分隐私通过引入随机性和噪声来模糊个体数据，使得任何单个个体的贡献都无法被准确地确定。这样，即使攻击者具有访问和分析整体数据集的能力，也无法推断出个体的准确信息。通过在计算或数据发布过程中应用差分隐私，可以确保数据的隐私性，防止个人身份的泄露以及敏感信息的暴露。差分隐私的实现方法通常涉及添加噪声、扰动数据或限制查询等技术手段。它可以应用于各种场景，包括数据挖掘、机器学习、统计分析等领域，以保护个人隐私并促进数据共享和研究。同时，差分隐私也涉及一些数学理论和算法，用于量化隐私保护的强度以及在保护和分析之间取得平衡的方法。</p>\n<p>网络图数据包含着大量的用户信息。（如何包含？）</p>\n<p>网络图数据包含着大量的用户信息，主要是因为网络图记录了用户之间的连接和交互关系。这些关系可以包括社交网络中的朋友关系、通信网络中的通话记录、互联网上的浏览历史等。通过分析网络图数据，可以获得用户的社交圈子、兴趣爱好、交流频率、行为模式等信息。例如，通过分析社交网络图，可以了解一个用户的朋友数量、朋友之间的联系强度，甚至可以推断出用户的兴趣爱好和社交影响力。在通信网络中，通过分析通话图可以了解用户之间的通话频率、通话时长、通话时间段等，这些信息可以用于用户行为分析、社交推荐、广告定向等应用。此外，网络图数据还可以包含用户的位置信息、IP地址、设备信息等。这些附加信息可以与网络图中的连接关系结合起来，进一步揭示用户的行为模式、偏好和用户群体特征。因此，网络图数据对于了解用户行为、社交关系和个人特征具有重要意义，同时也带来了隐私保护的挑战，需要采取适当的隐私保护措施来保护用户的个人隐私。</p>\n<p>只是简单的删除或者替换图中的节点ID，这种简单的隐藏节点信息仍然会有隐私泄漏的风险，因为结构数据仍然能够推导出用户的隐私。更多的在加权网络图中，权值也有</p>\n<p>hierarchical random graph：层次随机图（hierarchical random\ngraph）是一种具有层级结构的随机图模型，它可以用于描述复杂系统中的层次结构特征。在这个模型中，每个节点都被划分为不同的层级，并且每个层级中的节点之间存在不同的概率连接。这种模型在网络科学、社会学、生物学等领域有广泛的应用。</p>\n<p>Markov Monte Carlo：马尔可夫蒙特卡罗（Markov Monte\nCarlo，简称MCMC）是一种常用的随机采样方法，它可以用于从复杂的概率分布中采样得到样本。它基于马尔可夫链的性质，通过在状态空间中进行转移来达到采样的目的。MCMC可以应用于很多领域，比如贝叶斯统计、机器学习等。</p>\n<p>k-anonymity\nmethod：k-匿名（k-anonymity）是一种隐私保护方法，它可以在传输数据时保证数据中的每个个体都至少有k个相似的邻居，从而实现个体身份的隐私保护。具体来说，在k-匿名中，通过对原始数据进行通用化、泛化等操作，将具有相同属性值的记录合并为一个组，从而达到隐藏个体身份的目的。该方法在数据挖掘、隐私保护等领域得到了广泛的应用。在使用k-匿名保护方法时，由于需要对数据进行通用化、泛化等处理，因此会存在一定的背景知识假设。如果攻击者能够获取到更多的背景知识，则可能会推断出原始数据中的一些敏感信息。因此，k-匿名方法的相对有效性可能不是非常强，需要针对具体场景采用不同的隐私保护方法。</p>\n<p>本文通过结合边权重值和图结构设计了一种隐私保护算法。</p>\n<p><em>𝜀</em>- differential privacy：𝜀-差分隐私 (epsilon-differential\nprivacy)\n是一种差分隐私的度量方式之一，用于衡量随机化算法的隐私保护强度。表示在相同的输入数据集中，可能输出不同的结果（比如添加了随机噪声），但每个结果的隐私保护程度都保持一致。𝜀-差分隐私是指对于任意两个互相独立的数据集\nS 和 S'，它们只有微小的区别（比如只有一个记录不同），随机化算法保证以 𝜀\n的概率输出的结果具有相似的隐私保护程度。𝜀\n越小则表示隐私保护程度越高，但可能会降低数据实用性和准确性。</p>\n<p>本文主要贡献：</p>\n<ol type=\"1\">\n<li>根据边的频率，在图形生成过程中使用差分隐私的拉普拉斯噪声扰动，并设计合理的图形生成规则。</li>\n<li>在获取扰动图形集之后，设计了边权重保护算法，包括合理的隐私预算分配策略。</li>\n<li>然后，将扰动边权重集成到图形的编码过程中，并挖掘图谱的频繁子图。在挖掘过程中，使用差分隐私的拉普拉斯机制和指数机制来保护图形结构，从而提高数据效用。</li>\n</ol>\n<p><strong>Definition\n2.1</strong>给定一个随机算法𝑀，𝑅𝑎𝑛𝑔𝑒(𝑀)表示算法𝑀的所有可能输出结果的集合。对于任意两个相邻的数据集𝐷和𝐷′以及任意子集𝑆⊆𝑅𝑎𝑛𝑔𝑒(𝑀)，如果满足𝑃𝑟(𝑀(𝐷)∈𝑆)≤𝑃𝑟(𝑀(𝐷′)∈𝑆)×exp(𝜀)，则算法𝑀就满足𝜀-差分隐私。此外，差分隐私有两种常见的机制，拉普拉斯机制和指数机制\n[25]。拉普拉斯机制用于数值隐私保护，而指数机制用于非数值隐私保护。两种机制定义如下。噪声机制的选择决定了查询的准确性。</p>\n<p><strong>Definition 2.2</strong> (<em>Laplace\nMechanism</em>)给定数据集𝐷，函数𝑓∶𝐷<span\nclass=\"math inline\">\\(→r_d\\)</span>\n满足灵敏度，记为△𝑓，那么随机算法𝑀(𝐷)=𝐹(𝐷)+𝐿𝑎𝑝(△𝑓/𝜀)满足𝜀-差分隐私。其中，𝐿𝑎𝑝(△𝑓/𝜀)是随机噪声，是拉普拉斯分布，其比例因子为△𝑓/𝜀。噪声的大小直接与△𝑓成正比，与𝜀成反比。</p>\n<p><strong>Definition 2.3</strong> (<em>Global\nSensitivity</em>)给定函数𝑓∶𝐷→ <span\nclass=\"math inline\">\\(r_d\\)</span>，输入为数据集𝐷，输出为一个𝑑维实数向量。对于任意相邻的数据集𝐷和𝐷′，△𝑓\n= <span\nclass=\"math inline\">\\(max_{D,D&#39;}\\)</span>‖𝑓(𝐷)−𝐹(𝐷′)‖是𝑓的全局灵敏度。其中，𝑅代表映射的实数空间，𝐿1距离表示𝑓(𝐷)和𝑓(𝐷′)之间的距离。</p>\n<p><strong>Definition 2.4</strong> (<em>Exponential Mechanism</em>)</p>\n<p>差分隐私还具有序列组合和并行组合两个属性[10]。序列组合强调隐私预算可以在方法的不同步骤中分配，而并行组合确保算法在其数据集的非重叠子集中满足差分隐私的隐私性。</p>\n<p>在本文中，我们提出了一种隐私保护算法，以保护物联网中的加权图，主要采用差分隐私保护模型来保护边权重和图结构。首先，我们扰乱整个图集并在图生成过程中添加噪声；其次，我们为扰乱的图集设计了边权重保护算法，然后对图进行编码并将扰乱的边权重整合到其中。然后，我们挖掘和保护图集中的频繁图结构，在挖掘过程中使用差分隐私。最后，我们在真实数据集上进行实验证明，我们的方法是可行和有效的。</p>\n<h4\nid=\"a-survey-of-dummy-based-location-privacy-protection-techniques-for-location-based-services\">A\nSurvey of Dummy-Based Location Privacy Protection Techniques for\nLocation-Based Services</h4>\n<p>《基于虚假数据的位置隐私保护技术在基于位置的服务中的调查》是一篇研究论文或文章，提供了对基于位置的服务（LBS）中用于保护位置隐私的各种技术的概述和分析。</p>\n<p>在这项调查中，重点关注基于虚假数据的技术，这些技术涉及生成和利用虚假或伪造的位置信息，以在保护用户隐私的同时允许提供LBS。这些技术旨在防止或减轻可能危及使用LBS应用程序的个人隐私的位置跟踪和推断攻击。</p>\n<p>调查可能涵盖一系列基于虚假数据的技术，例如：</p>\n<ol type=\"1\">\n<li>虚假注入：将伪造或虚假的位置更新与用户的真实位置一起引入，以困惑对手并使其难以准确追踪用户。</li>\n<li>虚假选择：从预定义的集合中选择合适的虚假位置，或基于特定标准选择虚假位置，以确保隐私保护同时保持LBS的效用。</li>\n<li>虚假移动：通过生成逼真的虚假位置更新来模拟用户的移动模式或轨迹，从而混淆用户的实际移动。</li>\n<li>虚假更新策略：确定虚假位置更新的频率、时间和特征，以增强隐私保护并尽量减少对LBS功能的影响。</li>\n</ol>\n<p>调查可能讨论不同基于虚假数据技术的优点、局限性和权衡，考虑隐私保护、LBS的效用、计算开销和通信成本等因素。</p>\n<p>总的来说，这项调查是了解基于虚假数据的位置隐私保护技术在基于位置的服务中的现状的全面资源。它可以提供对这一研究领域的挑战、进展和未来方向的洞察。</p>\n<p>Dummy-based location privacy protection：基于虚假位置的隐私保护</p>\n<p>基于虚假数据的位置隐私保护是一种技术方法，旨在保护个人在使用位置相关服务时的位置隐私。该方法通过引入虚假或伪造的位置信息，使得攻击者难以确定用户的真实位置，从而保护用户的隐私。</p>\n<p>在基于虚假数据的位置隐私保护中，主要的思想是在用户的真实位置信息中添加一些虚假的位置数据，使得攻击者无法准确追踪用户的位置。这些虚假数据可以包括虚假位置坐标、虚假位置更新时间或者虚假移动轨迹。</p>\n<p>使用虚假数据的好处是可以提供一定的隐私保护，同时仍然可以享受位置相关服务的便利性。通过引入虚假数据，用户的真实位置更难以被追踪或推断出来，从而保护用户的隐私。</p>\n<p>虽然基于虚假数据的位置隐私保护可以提供一定程度的隐私保护，但也存在一些限制和挑战。其中一项挑战是如何选择合适的虚假数据以平衡隐私保护和服务的实用性。虚假数据的选择需要考虑用户的行为模式、位置需求以及攻击者的推断能力。另外，虚假数据的生成和管理也需要考虑计算和通信开销等方面的因素。</p>\n<p>因此，基于虚假数据的位置隐私保护是一种重要的技术手段，用于在位置相关服务中保护用户的隐私。它通过引入虚假数据来混淆用户的真实位置，从而提高用户的位置隐私保护水平。</p>\n<p>Level of privacy (LoP):\"Level of\nprivacy\"（隐私水平）指的是个人或组织在其个人信息或数据处理过程中所期望的或实现的隐私保护程度。</p>\n<p>\"Quality of Service\"（服务质量）通常缩写为\nQoS，指的是在计算机网络和通信领域中，用于描述网络或通信系统所提供的服务的质量水平。</p>\n<ul>\n<li><p>这篇文章，到底在解决什么问题？（摘要、前言部分）</p></li>\n<li><p>这个问题为什么在这个领域重要？（前言部分）</p></li>\n<li><p>这些作者是怎么解决这个问题的？（具体的实验设计、优化部分）</p></li>\n<li><p>这个问题的解决有什么亮点、局限，有什么应用？（数据分析、应用展示、结论、展望部分）</p></li>\n</ul>\n<h4\nid=\"dp-ltod-differential-privacy-latent-trajectory-community-discovering-services-over-location-based-social-networks\">DP-LTOD:\nDifferential Privacy Latent Trajectory Community Discovering Services\nover Location-Based Social Networks</h4>\n<ul>\n<li><p>这篇文章，到底在解决什么问题？（摘要、前言部分）</p>\n<p>这篇论文解决了两个问题：</p>\n<p>1、根据用户的轨迹，将用户分类</p>\n<p>2、设计了一个新的模糊轨迹的方法</p>\n<p>首先，由于大规模无线通信网络的应用，基于位置的社交网络也大规模出现并应用。但是很多应用在使用用户的位置权限时。会存在泄漏用户位置隐私的可能。这些位置信息包含用户的位置轨迹。</p>\n<p>所以本篇文章提出了一种差分隐私潜在轨迹团发现方案（DP-\nLTOD，Differential Privacy Latent Trajectory Community Discovering\n）。通过将原始轨迹序列模糊化为符合差分隐私的轨迹序列来保护轨迹隐私。</p>\n<p>还开发了一种轨迹聚类算法，根据语义距离和地理距离将轨迹分类到不同类型的聚类中。</p></li>\n<li><p>这个问题为什么在这个领域重要？（前言部分）</p>\n<p>1、历史轨迹反应了用户的随时间的位置变化。通过分析收集大量用户的历史轨迹，可以把有相似爱好、兴趣、行为的用户聚类在一起。</p>\n<p>2、轨迹信息可以为许多应用软件提供支持。</p>\n<p>那么问题就来了，有些不被信任的第三方泄漏用户信息来做一些恶意事件。或者攻击者得到数据后分析用户数据做一些恶意事件。</p></li>\n<li><p>这些作者是怎么解决这个问题的？（具体的实验设计、优化部分）</p>\n<p>对于用户轨迹分类问题：</p>\n<p>该论文考虑了两方面：语义分类，地理位置分类。综合这两种方法，可以有效的将用户轨迹分类。</p>\n<p>对于用户轨迹信息的保护，该论文设计了一个挑选模糊位置的方法。这个方法可以挑选出最接近真实位置的模糊位置。之后设计了两种攻击方式。贝叶斯、马尔可夫。并针对这两种攻击分别进行了拉普拉斯噪声、指数噪声的添加。使得之后的扰乱矩阵既能保护隐私又能兼顾数据的使用。</p></li>\n<li><p>这个问题的解决有什么亮点、局限，有什么应用？（数据分析、应用展示、结论、展望部分）</p></li>\n</ul>\n<p>在本文中，我们研究了在严格的差分隐私模型下的潜在轨迹社区发现问题。首先，我们介绍了考虑用户兴趣和偏好的潜在轨迹社区发现（LTOD）方法。然后，我们探讨了设计差分隐私潜在轨迹社区发现（DP-LTOD）方案的可能性，以确保隐私和数据效用的良好性能。我们发现，在DP-LTOD中，模糊化轨迹序列的特征对于提高LTOD的准确性至关重要。如果我们能够有效地选择最优的模糊化轨迹，可以显著改善效用和隐私的权衡。为此，我们制定了一个轨迹模糊化问题，选择与原始轨迹差异最小的最优轨迹。我们证明了这个问题是NP难问题，并提出了一种启发式的轨迹模糊化算法来解决该问题。在我们的DP-LTOD方案中，另一个核心是在轨迹模糊化阶段添加差分隐私所需的噪声。为了防止贝叶斯攻击和马尔可夫攻击，我们在位置模糊化矩阵生成和轨迹序列函数生成阶段分别添加基于拉普拉斯分布和指数分布的噪声。通过形式化的隐私分析，我们证明了DP-LTOD方案满足\u0015-差分隐私。通过实验证明，我们的DP-LTOD方案能够以高准确性私密地发现潜在轨迹社区。</p>\n<p>对于未来的工作，我们将进一步完善攻击模型，考虑社交连接图或内容文本等因素。将利用深度学习技术训练位置模糊化矩阵，以智能感知用户的实际位置并选择模糊化位置。此外，我们将考虑更多的维度（例如时间或速度等）来发现潜在轨迹社区。将发现的潜在轨迹社区应用于LBSNs中为用户推荐个性化服务将是一个有趣的研究方向。</p>\n<h4\nid=\"privacy-attitudes-and-privacy-behaviour-a-review-of-current-research-on-the-privacy-paradox-phenomenon\">Privacy\nattitudes and privacy behaviour: A review of current research on the\nprivacy paradox phenomenon</h4>\n<p>隐私态度和隐私行为：对隐私悖论现象的当前研究进行综述。综述论文。</p>\n<h3 id=\"june-5-2023week-1\">1.JUNE 5, 2023(WEEK 1)</h3>\n<h4 id=\"decision-tree\">Decision tree</h4>\n<table>\n<colgroup>\n<col style=\"width: 15%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 1%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 15%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Title</th>\n<th>Publication</th>\n<th>Year</th>\n<th>Authors</th>\n<th>Area</th>\n<th>Problem</th>\n<th>Main Method</th>\n<th>Datasets</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>LSTM-TrajGAN: A Deep Learning Approach to Trajectory Privacy\nProtection</strong></td>\n<td>ACM Subject Classification Security and privacy</td>\n<td>2020</td>\n<td>Jinmen Rao <br />Song Gao</td>\n<td>Deep Learning Trajectory Privacy Protection</td>\n<td>如何生成与原始数据相似度大的伪造轨迹，从而保护原始轨迹隐私并使得原始数据的使用影响降到最小。</td>\n<td>使用一种深度学习模型来训练生成伪造轨迹</td>\n<td>Foursquare weekly trajectory dataset in New York City</td>\n</tr>\n<tr class=\"even\">\n<td><strong>trajGANs: Using generative adversarial networks for\ngeo-privacy protection of trajectory data (Vision paper)</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Differentially Private Triangle and 4-Cycle Counting in the\nShuffle Model</strong></td>\n<td>CCS</td>\n<td>2022</td>\n<td>Jacob Imola Takao Murakami</td>\n<td><a\nhref=\"https://dl.acm.org/doi/proceedings/10.1145/3548606\">Computer and\nCommunications Security</a></td>\n<td></td>\n<td></td>\n<td>https://github.com/Triangle4CycleShuffle/Triangle4CycleShuffle</td>\n</tr>\n<tr class=\"even\">\n<td><strong>Personalized Differential Privacy Preservation Method for\nTrajectory Based on Regional Density Analysis</strong></td>\n<td>2023 2nd International Conference on Big Data, Information and\nComputer Network (BDICN)</td>\n<td>2023</td>\n<td>Weicheng zhi</td>\n<td>差分隐私 轨迹隐私</td>\n<td>如何平衡虚假轨迹的轨迹隐私保护和轨迹的服务利用率</td>\n<td>通过将轨迹中比较集中的点用一个点来代替，生成一个新的轨迹，之后再对这个点添加噪声</td>\n<td>Geolife<br />T-drive</td>\n</tr>\n</tbody>\n</table>\n<h5\nid=\"lstm-trajgan-a-deep-learning-approach-to-trajectory-privacy-protection\"><strong>LSTM-TrajGAN:\nA Deep Learning Approach to Trajectory Privacy Protection</strong></h5>\n<blockquote>\n<p>这篇论文在解决什么问题？（摘要、前言）</p>\n</blockquote>\n<p>随着位置服务的兴起，如何保护用户的位置、轨迹隐私？</p>\n<blockquote>\n<p>这个问题为什么重要？</p>\n</blockquote>\n<p>现如今通用的方法是从用户轨迹数据中移除一些敏感数据（用户名字、ID）。但是这些数据可能能通过空间、时间、地理位置的语义信息被推断出。而另一种把用户数据整合进地理位置的方法不仅不能保护用户隐私，反而也造成空间分析的低效。因此，为了平衡用户隐私保护和用户数据在应用中的使用，作者提出了<strong>LSTM-\nTrajGAN</strong>模型。</p>\n<blockquote>\n<p>作者是如何解决这个问题？（具体的实验设计、优化部分）</p>\n</blockquote>\n<p><strong>大体思路：</strong></p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-06-07 22.41.13.png\" alt=\"截屏2023-06-07 22.41.13\" style=\"zoom:50%;\" /></p>\n<p>将轨迹信息（空间、时间、语义信息）编码，之后送入LSTM- TrajGAN\n模型，之后利用伪造轨迹数据进行应用。</p>\n<p><strong>轨迹编码：</strong></p>\n<p>轨迹的编码主要分为location、time、user id 、trajectory id、other\noptional attributes。</p>\n<p>location：标准化经纬度（具体的方法是，得到数据集中所有位置点的质心点，然后所有的位置的经纬度跟这个质心的偏差来作为位置经纬度的标准化）这样的方法可以使得模型更好的学习到两个不同的轨迹点的空间偏差。</p>\n<p>time：使用one-hot encoders 去编码。具体编码为周、小时这两种。</p>\n<p>other optional attributes：编码为10维的二进制向量</p>\n<p>不对用户ID和轨迹ID编码。因为它们仅用于指示点所属的用户和轨迹。</p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-06-07 22.55.30.png\" alt=\"截屏2023-06-07 22.55.30\" style=\"zoom:50%;\" /></p>\n<p><strong>轨迹填充：</strong></p>\n<p>填0</p>\n<p><strong>LSTM-TrajGAN Model:</strong></p>\n<p><img loading=\"lazy\" data-src=\"/Users/huangqiuzhao/Library/Application Support/typora-user-images/截屏2023-06-07 22.57.27.png\" alt=\"截屏2023-06-07 22.57.27\" style=\"zoom:50%;\" /></p>\n<p>主要是两部分，轨迹生成器和轨迹分辨器。在轨迹生成器中，首先是将噪声和经过多层感知机的真实的轨迹数据组合在一起（这里起到添加噪声的作用），然后经过全连接层再经过LSTM，之后经过全连结层和3个softmax生成了伪造轨迹。之后将真实轨迹和伪造数据一起送入轨迹分辨器中，进行分辨。在进行对抗训练中，本文的一大亮点，重新设计了损失函数（<strong>TrajLoss\nfor Measuring Trajectory Similarity Losses</strong>） <span\nclass=\"math display\">\\[\nTrajLoss(y^r,y^p,t^r,t^s)=\\alpha L_{BCE}(y^r,y^p)+\\beta\nL_{s}(t^r,t^s)+\\gamma L_{t}(t^r,t^s)+cL_{c}(t^r,t^s)\n\\]</span> 其中 <span class=\"math inline\">\\(y^r\\)</span> 和 <span\nclass=\"math inline\">\\(y^p\\)</span>\n表示真实的标签和通过分类器预测的结果。 <span\nclass=\"math inline\">\\(t^r\\)</span> 和 <span\nclass=\"math inline\">\\(t^s\\)</span> 则表示真实轨迹和伪造轨迹。</p>\n<blockquote>\n<p>这个问题的解决有什么亮点、局限，有什么应用？（数据分析、应用展示、结论、展望部分）</p>\n</blockquote>\n<h5\nid=\"personalized-differential-privacy-preservation-method-for-trajectory-based-on-regional-density-analysis\"><strong>Personalized\nDifferential Privacy Preservation Method for Trajectory Based on\nRegional Density Analysis</strong></h5>\n<blockquote>\n<p>将基于区域密度分析的个性化差分隐私保护方法应用于轨迹数据</p>\n</blockquote>\n<ul>\n<li>这篇文章，到底在解决什么问题？（摘要、前言部分）</li>\n</ul>\n<blockquote>\n<p>目前大部分方法都对轨迹中的所有点进行噪声的添加，同时对轨迹中的点分配同样的隐私预算。这样不能对轨迹中的用户的特征进行个性化的轨迹隐私保护。</p>\n</blockquote>\n<ul>\n<li>这个问题为什么在这个领域重要？（前言部分）</li>\n<li>这些作者是怎么解决这个问题的？（具体的实验设计、优化部分）</li>\n</ul>\n<blockquote>\n<p>针对这个问题，提出了一种基于区域密度分析的轨迹保护方法。分析每个用户的停留区域，计算停留点，并根据时间和距离阈值重构轨迹集。使用基于局部密度峰值的最小生成树聚类算法获取用户轨迹的隐私敏感位置点和活动热点区域。根据设计的隐私重要程度表达式，计算每个敏感位置点的隐私得分，并为其分配适当的隐私预算值。</p>\n</blockquote>\n<ul>\n<li>这个问题的解决有什么亮点、局限，有什么应用？（数据分析、应用展示、结论、展望部分）</li>\n</ul>\n<blockquote>\n<p>主要的亮点在于，使用经纬度和时间，找到了一个密度最高区域。并将其重构，然后根据设计的隐私重要程度表达式，计算每个敏感位置的隐私得分，并为其分配适当的隐私预算值。这其实算是将轨迹中的重要的点找出来（毕竟轨迹中的的点有很多，每一个点其实所包含的信息是不一样的。比如在街道上的一些点和在餐厅的点，它们包含的信息当然不同），为其分配不同的隐私预算值。其实这个的隐私预算值可以视为权重值。含有信息不同的轨迹的点自然需要不同的权重值。然后根据隐私预算为这个重构的轨迹图添加噪声。</p>\n<p>我觉得这个问题的解决还有一个点可以考虑进去，首先作者只是考虑了经纬度、时间。一些点所处位置的语义信息并没有被考虑进去。是否可以将这个语义信息考虑进去？不同的点他们所处的位置可能是咖啡店、书店等等。这个信息其实也有较大的影响。</p>\n</blockquote>\n<p>这篇文章，到底在解决什么问题？（摘要、前言部分）</p>\n<p>这个问题为什么在这个领域重要？（前言部分）</p>\n<p>这些作者是怎么解决这个问题的？（具体的实验设计、优化部分）</p>\n<p>这个问题的解决有什么亮点、局限，有什么应用？（数据分析、应用展示、结论、展望部分）</p>\n",
            "tags": []
        }
    ]
}